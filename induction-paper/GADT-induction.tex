% For double-blind review submission, w/o CCS and ACM Reference (max
% submission space)
\documentclass[acmsmall,screen,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{Haskell Symposium} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2021}
\acmMonth{8}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations
%\citestyle{acmnumeric}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\usepackage[utf8]{inputenc}
\usepackage{ccicons}
\usepackage{verbatim}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amscd}
%\usepackage{MnSymbol}
\usepackage{xcolor}

\usepackage{bbold}
\usepackage{url}
\usepackage{upgreek}
%\usepackage{stmaryrd}

\usepackage{lipsum}
\usepackage{tikz-cd}
\usetikzlibrary{cd}
\usetikzlibrary{calc}
\usetikzlibrary{arrows}

\usepackage{bussproofs}
\EnableBpAbbreviations

\input{macros}
\input{mytheorem}

\theoremstyle{definition}
\newtheorem{exmpl}{Example}

\renewcommand{\greyout}[1]{}

\newcommand{\new}[1]{{\color{blue} {#1}}}


\newcommand{\emptyfun}{{[]}}
\newcommand{\cal}{\mathcal}
\newcommand{\F}{\mathcal{F}}
\newcommand{\G}{\mathcal{G}}
\newcommand{\N}{\mathcal{N}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\B}{\mathcal{B}}
\renewcommand{\P}{\mathcal{A}}
\newcommand{\pred}{\mathsf{Fam}}
\newcommand{\env}{\mathsf{Env}}
\newcommand{\set}{\mathsf{Set}}
\renewcommand{\S}{\mathcal S}
\newcommand{\C}{\mathcal{C}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\A}{\mathcal{A}}
\renewcommand{\id}{\mathit{id}}
\newcommand{\map}{\mathsf{map}}
\newcommand{\pid}{\underline{\mathit{id}}}
\newcommand{\pcirc}{\,\underline{\circ}\,}
\newcommand{\pzero}{\underline{0}}
\newcommand{\pone}{\underline{1}}
\newcommand{\psum}{\,\underline{+}\,}
\newcommand{\pinl}{\underline{\mathit{inL}}\,}
\newcommand{\pinr}{\underline{\mathit{inR}}\,}
\newcommand{\ptimes}{\,\underline{\times}\,}
\newcommand{\ppi}{\underline{\pi_1}}
\newcommand{\pppi}{\underline{\pi_2}}
\newcommand{\pmu}{\underline{\mu}}
\newcommand{\semmap}{\mathit{map}}
\newcommand{\subst}{\mathit{subst}}

\newcommand{\tb}[1]{~~ \mbox{#1} ~~}
\newcommand{\listt}[1]{(\mu \phi. \lambda \beta . \onet + \beta \times
  \phi \beta) #1} 
\newcommand{\filtype}{\Nat^\emptyset 
 (\Nat^\emptyset \, \alpha \, \mathit{Bool})\, (\Nat^\emptyset 
  (List \, \alpha) \, (List \, \alpha))} 
\newcommand{\filtypeGRose}{\Nat^\emptyset 
 (\Nat^\emptyset \, \alpha \, \mathit{Bool})\, (\Nat^\emptyset 
  (\mathit{GRose}\,\psi \, \alpha) \, (\mathit{GRose}\,\psi \, (\alpha
  + \onet)))} 
\newcommand{\maplist}{\mathit{map}_{\lambda A. \setsem{\emptyset; \alpha
      \vdash \mathit{List} \, \alpha} \rho[\alpha := A]}} 
\newcommand{\PLeaves}{\mathsf{PLeaves}}
\newcommand{\swap}{\mathsf{swap}}
\newcommand{\reverse}{\mathsf{reverse}}
\newcommand{\Bcons}{\mathit{Bcons}}
\newcommand{\Bnil}{\mathit{Bnil}}


\title[(Deep) Induction for GADTs]{(Deep) Induction for GADTs}

\author{Patricia Johann, Enrico Ghiorzi, and Daniel Jeffries}
\affiliation{ \institution{Appalachian State University}}
\email{johannp@appstate.edu, ghiorzie@appstate.edu,
  jeffriesd@appstate.edu}

\begin{document}

\begin{abstract}
Abstract
\end{abstract}

\maketitle

\section{Introduction}\label{sec:intro}



\section{Deep induction for ADTs and nested types}

%\begin{itemize}
%\item Say what ADTs and nested types are (look~\cite{jp20,jgj21})
%\item Examples: $\mathsf{List}$ and $\mathsf{PTree}$ and $\mathsf{Bush}$
%\item Explain induction for $\mathsf{List}$ and $\mathsf{PTree}$ (refer paper Patricia Neil Clement 2010) notice it does not extend to truly nested types like $\mathsf{Bush}$
%\item To get induction rule for truly nested types such as $\mathsf{Bush}$ requires deep induction (refer to~\cite{jp20}) (explain various pieces of deep induction, including lifting, informally)
%\item Deep induction makes sense for other structures as well (not just truly nested types)
%\end{itemize}

\subsection{Syntax of ADTs and nested types}\label{ssec:syntax-adts}

\emph{(Polynomial) algebraic data types} (ADTs), both built-in and user-defined,
have long been at the core of functional languages such as Haskell, ML, Agda, Epigram, and Idris.
ADTs are used extensively in functional programming to structure computations,
to express invariants of the data over which computations are defined,
and to ensure the type safety of programs specifying those computations.
ADTs include unindexed types, such as the type of natural numbers,
and types indexed over other types, such as the quintessential example of an ADT,
the type of lists (here coded in Agda)
{\color{blue}(Ask Daniel which flavor of syntax, paper as literate Agda, naming conventions?)}
\begin{equation}\label{eq:list}
\begin{array}{l}
%\mathsf{data\, List : Set \to Set\,where}\\
\mathsf{data\, List\,(a : Set) : Set\,where}\\
\mathsf{\;\;\;\;\;\;\;\;Nil\,\,\,\,\,\, :\, List\,a}\\
\mathsf{\;\;\;\;\;\;\;\;Cons\, :\, a \to List\,a \to List\,a} 
\end{array}
\end{equation}
Notice that all occurrences of $\mathsf{List}$ in the above encoding are instantiated at the same index $\mathsf{a}$.
Thus, the instances of $\mathsf{List}$ at various indices are defined independently from one another.
That is a defining feature of ADTs:
an ADT defines a \emph{family of inductive types}, one for each index type.

Over time, there has been a notable trend toward data types
whose non-regular indexing can capture invariants and other sophisticated properties
that can be used for program verification and other applications.
A simple example of such a type is given by Bird and Meertensâ€™~\cite{bm98} prototypical \emph{nested type}
\begin{equation}\label{eq:ptree}
\begin{array}{l}
\mathsf{data\, PTree\,(a : Set) : Set\,where}\\
\mathsf{\;\;\;\;\;\;\;\;PLeaf\,\,\, :\, a \to PTree\,a}\\
\mathsf{\;\;\;\;\;\;\;\;PNode\, :\, PTree\,(a \times a) \to PTree\,a} 
\end{array}
\end{equation}
of perfect trees, which can be thought of as constraining lists to have lengths that are powers of 2.
In the above code, the constructor $\mathsf{PNode}$ uses data of type $\mathsf{PNode\,(a \times a)}$ to construct data of type $\mathsf{PNode\,a}$.
Thus, it is clear that the instantiations of $\mathsf{PNode}$ at various indices cannot be defined independently, so that the entire family of types must actually be defined at once.
A nested type thus defines not a family of inductive types, but rather an \emph{inductive family of types}.

Nested types include simple nested types, like perfect trees,
none of whose recursive occurrences occur below another type constructor,
and \emph{truly} nested types, such as the nested type
\begin{equation}\label{eq:ptree}
\begin{array}{l}
\mathsf{data\, Bush\,(a : Set) : Set\,where}\\
\mathsf{\;\;\;\;\;\;\;\;BNil\,\,\,\,\,\, :\, Bush\,a}\\
\mathsf{\;\;\;\;\;\;\;\;BCons\, :\, a \to Bush\,(Bush\,a) \to Bush\,a} 
\end{array}
\end{equation}
of bushes, whose recursive occurrences appear below their own type constructors.
Note that, while the constructors of a nested type can contain occurrences of the type instantiated at any index,
the return types of its constructors still have to be the same type instance of the type being defined.
In other words, all constructors of $\mathsf{PTree\,a}$ have to return an element of type $\mathsf{PTree\,a}$,
and all constructors of $\mathsf{Bush\,a}$ have to return an element of type $\mathsf{Bush\,a}$.
%the return types of the constructors are still required to be instantiated at the same variable $\mathsf{a}$.}
%As previously noted, the return types of the constructors of a nested
%type have to be the same type instance of the type being defined.


\subsection{Induction principles for ADTs and nested types}\label{ssec:induction-nested}

An induction principle for a data type allows proving
that a predicate holds for every element of that data type,
provided that it holds for every element inductively produced by the type's constructors.
In this paper, we are interested in induction principles for proof-relevant predicates.
A proof-relevant predicate on a type $\mathsf{a}$ is a function $\mathsf{a \to Set}$
(where $\mathsf{Set}$ is the type of sets)
mapping each $\mathsf{x : a}$ to the set of proofs that the predicate holds for $\mathsf{x}$.
For example, the induction principle for $\mathsf{List}$ is
\begin{multline}
\mathsf{\forall (a : Set) (P : List\,a \to Set) \to P\,Nil \to \big( \forall (x : a) (xs: List\,a) \to P\,xs \to P\,(Cons\,x\,xs)\big)} \\
\mathsf{\to \forall (xs : List\,a) \to P\, xs }
\end{multline}
Note that the data inside a structure of type $\mathsf{List}$ is treated monolithically (i.e., ignored) by this induction rule.
Indeed, the induction rule inducts over only the top-level structures of data types,
leaving any data internal to the top-level structure untouched.
Since this kind of induction principle is only concerned with the structure of the type,
and unconcerned with the contained data,
we will then refer to it as \emph{structural induction}.

We can extend such a structural induction principle to some nested types, such as $\mathsf{PTree}$.
The only difference from the induction principle for ADTs is that,
since a nested type is defined as a whole inductive family of types at once,
its induction rule has to necessary involve a polymorphic predicate.
Thus, the induction rule for $\mathsf{PTree}$ is
\begin{multline}
\mathsf{\forall (P : \forall (a : Set) \to PTree\, a \to Set)
\to \big( \forall (a : Set) (x : a) \to P\,a\,(PLeaf\, x) \big)} \\
\mathsf{\to \big( \forall (a : Set) (x : PTree\,(a \times a)) \to P\,(a \times a)\,x \to P\,a\,(PNode\,x)\big)} \\
\mathsf{\to \forall (a : Set) (x : PTree\,a) \to P\,a\,x }
\end{multline}

%This kind of induction principles, which we will call \emph{structural induction},
Structural induction principles cannot be extended to truly nested types, such as $\mathsf{Bush}$.
%To induce over a truly nested type, we need to use a \emph{deep induction} principle~\cite{jp20}.
Instead, for such data types it is necessary to use a \emph{deep induction} principle~\cite{jp20}.
Such a principle, unlike structural induction, inducts over all of the structured data present,
by traversing not just the outer structure with a predicate $\mathsf{P}$,
but also each data element contained in the data type with a custom predicate $\mathsf{Q}$.
This additional predicate is lifted to predicates on any internal structure containing these data, and the resulting predicates on these internal structures are lifted to predicates on any internal structures containing structures at the previous level, and so on, until the internal structures at all levels of the data type definition, including the top level, have been so processed.
Satisfaction of a predicate by the data at one level of a structure is then conditioned upon satisfaction of the appropriate predicates by all of the data at the preceding level.

For example, the deep induction rule for $\mathsf{Bush}$ is
\begin{multline}
\mathsf{\forall (P : \forall (a : Set) \to (a \to Set) \to Bush\, a \to Set)
\to \big( \forall (a : Set) \to P\,a\,BNil \big)} \\
\mathsf{\to \big( \forall (a : Set) (Q : a \to Set) (x : a) (y : Bush\,(Bush\,a))} \\
\mathsf{\to Q\,x \to P\,(Bush\,a)\,(Bush^{\wedge}\,a\,Q)\,y \to P\,a\,Q\,(BCons\,x\,y) \big)} \\
\mathsf{\to \forall (a : Set) (Q : a \to Set) (x : Bush\,a) \to Bush^{\wedge}\,a\,Q\,x \to P\,a\,Q\,x }
\end{multline}
where $\mathsf{Bush^{\wedge} : \forall (a : Set) \to (a \to Set) \to Bush\,a \to Set}$ lifts a predicate $\mathsf{Q}$ on data of type $\mathsf{a}$ to a predicate on data of type $\mathsf{Bush\,a}$ asserting that $\mathsf{Q}$ holds for every element of type $\mathsf{a}$ contained in its argument bush.
%where $\mathsf{Bush^{\wedge} : \forall (a : Set) \to ( a \to Set ) \to Bush\,a \to Set}$
%is the polymorphic function that lifts predicates to $\mathsf{Bush}$,
It is defined as
\begin{align*}
\mathsf{Bush^{\wedge}\,a\,Q\,BNil} &= \mathsf{1} \\
\mathsf{Bush^{\wedge}\,a\,Q\,(BCons\,x\,y)} &= \mathsf{Q\,x \times Bush^{\wedge}\,(Bush\,a)\,(Bush^{\wedge}\,a\,Q)\,y}
\end{align*}

Despite deep induction being motivated by the need to produce an induction principle for truly nested types,
it can equally be applied to all other ADTs and nested types.
For example, the deep induction principle for $\mathsf{List}$ is
\begin{multline}
\mathsf{\forall (a : Set) (P : List\, a \to Set) (Q : a \to Set)} \\
\mathsf{\to P\,Nil \to \big( \forall (x : a) (xs: List\,a) \to Q\,x \to P\,xs \to P\,(Cons\,x\,xs)\big)} \\
\mathsf{\to \forall (xs : List\,a) \to List^{\wedge}\,a\,Q\,xs \to P\, xs }
\end{multline}
where $\mathsf{List^{\wedge} : \forall (a : Set) \to (a \to Set) \to List\,a \to Set}$ lifts a predicate $\mathsf{Q}$ on data of type $\mathsf{a}$ to a predicate on data of type $\mathsf{List\,a}$ asserting that $\mathsf{Q}$ holds for every element of its argument list.
Finally, the deep induction rule for $\mathsf{PTree}$ is
\begin{multline}
\mathsf{\forall (P : \forall (a : Set) \to (a \to Set) \to PTree\, a \to Set)} \\
\mathsf{\to \big( \forall (a : Set) (Q : a \to Set) (x : a) \to Q\,x \to P\,a\,Q\,(PLeaf\, x) \big)} \\
\mathsf{\to \big( \forall (a : Set) (Q : a \to Set) (x : PTree\,(a \times a)) \to P\,(a \times a)\,(Pair^{\wedge}\,a\,Q)\,x \to P\,a\,Q\,(PNode\,x)\big)} \\
\mathsf{\to \forall (a : Set) (Q : a \to Set) (x : PTree\,a) \to PTree^{\wedge}\,a\,Q\,x \to P\,a\,Q\,x }
\end{multline}
where $\mathsf{Pair^{\wedge} : \forall (a : Set) \to (a \to Set) \to a \times a \to Set}$ lifts a predicate $\mathsf{Q}$ on $\mathsf{a}$ to a predicate on pairs of type $\mathsf{a \times a}$,
so that $\mathsf{Pair^{\wedge}\,a\,Q\,(x,y) = Q\,x \times Q\,y}$,
and $\mathsf{PTree^{\wedge} : \forall (a : Set) \to (a \to Set) \to PTree\,a \to Set}$ lifts a predicate $\mathsf{Q}$ on data of type $\mathsf{a}$ to a predicate on data of type $\mathsf{PTree\,a}$ asserting that $\mathsf{Q}$ holds for every element of type $\mathsf{a}$ contained in its argument perfect tree.



\section{Introducing GADTs}

%\begin{itemize}
%\item Say what GADTs are
%\item Example: $\mathsf{Equal}$
%\[\begin{array}{l}
%\mathsf{data\, Equal\,a\,b\,where}\\
%\mathsf{\;\;\;\;\;\;\;\;Refl ::\, Equal\,c\,c}
%\end{array}\]
%\item GADTs' encoding using $\mathsf{Equal}$
%\item Example (in Haskell syntax):
%%Haskell definition of $\mathsf{Seq}$ %(this encoding might have been introduced after the other one, see phantom types)
%\begin{equation}\label{eq:seq}
%\begin{array}{l}
%\mathsf{data\, Seq\,a\,where}\\
%\mathsf{\;\;\;\;\;\;\;\;Const ::\, a \to Seq\,a}\\
%\mathsf{\;\;\;\;\;\;\;\;SPair\,\, ::\, Seq \,a \to Seq\,b \to
%  Seq\,(a \times b)}
%\end{array}
%\end{equation}
%\item Traditionally GADTs are understood in terms of $\mathsf{Equal}$ data type (see Cheney Hinze or Tim Sheard)
%For example
%\begin{equation}\label{eq:eq_seq}
%\begin{array}{l}
%\mathsf{data\, Seq\,a\,where}\\
%\mathsf{\;\;\;\;\;\;\;\;Const ::\, a \to Seq\,a}\\
%\mathsf{\;\;\;\;\;\;\;\;SPair\,\, ::\, \exists (b : Set) (c : Set).\,Equal\,a\,(b \times c) \to Seq\,b \to Seq\,c \to
%  Seq\,a}\\ 
%\end{array}
%\end{equation}
%(This gives the kind of Church encoding that is in Bob's paper) (might omit)
%\item Add example for GADT with deep structure (Ask Daniel which one)
%\end{itemize}
%%Equality version of $\mathsf{Seq}$ (see Cheney Hinze or Tim Sheard)

As noted in Subsection~\ref{ssec:syntax-adts},
the return types of the constructors of a nested
type have to be the same type instance of the type being defined.
As a further generalization of ADTs and nested types,
\emph{generalized algebraic data types} (GADTs)~\cite{ch03,xcc03,sp04}
relax the restriction on the type instances appearing in a data
type definition by allowing their constructors both to take as
arguments \emph{and return as results} data whose types involve type
instances of the GADT other than the one being defined.

GADTs are used in precisely those situations in which different
behaviors at different instances of a data type are desired. This is
achieved by allowing the programmer to give the type signatures of the
GADT's data constructors independently, and then using pattern
matching to force the desired type refinement. Applications of GADTs
include generic programming, modeling programming languages via
higher-order abstract syntax, maintaining invariants in data
structures, and expressing constraints in embedded domain-specific
languages. GADTs have also been used, e.g., to implement tagless
interpreters~\cite{pl04,pr06,pvww06}, to improve memory
performance~\cite{min15}, and to design APIs~\cite{pen20}.



%\subsection{Agda syntax (bad title, revise)}

As a first and notable example of GADT, we consider the the $\mathsf{Equal}$ type.
This GADT is parametrized by two type indices,
but it is only possible to construct a data element if the two indices are instantiated at the same type.
In Agda, we code it as
\begin{equation}\label{eq:eq}
\begin{array}{l}
\mathsf{data\, Equal\,(a\,b : Set) : Set\,where}\\
\mathsf{\;\;\;\;\;\;\;\;Refl :\, Equal\,c\,c}
\end{array}
\end{equation}
$\mathsf{Equal}$ has thus a single data element when its two type arguments
are the same and no data elements otherwise.

A more complex example for a GADT is
\begin{equation}\label{eq:eq-seq}
\begin{array}{l}
\mathsf{data\, Seq\,(a : Set) : Set\,where}\\
\mathsf{\;\;\;\;\;\;\;\;Const :\, a \to Seq\,a}\\
\mathsf{\;\;\;\;\;\;\;\;SPair\,\, :\, Seq \,a \to Seq\,b \to
  Seq\,(a \times b)}
\end{array}
\end{equation}
which comprises sequences of any type $\mathsf{a}$
and sequences obtained by pairing the data in two already existing sequences.
Such GADTs can be understood in terms of the $\mathsf{Equal}$ data type~\cite{ch03,sp04}.
For example, we can rewrite the $\mathsf{Seq}$ type as
\begin{equation}\label{eq:eq_seq}
\begin{array}{l}
\mathsf{data\, Seq\,(a : Set) : Set\,where}\\
\mathsf{\;\;\;\;\;\;\;\;Const :\, a \to Seq\,a}\\
\mathsf{\;\;\;\;\;\;\;\;SPair\,\, :\, \exists (b : Set) (c : Set).\,Equal\,a\,(b \times c) \to Seq\,b \to Seq\,c \to
  Seq\,a}\\ 
\end{array}
\end{equation}
where the requirement that the $\mathsf{SPair}$ constructor produce an instance of $\mathsf{Seq}$ at a product type has been replaced with the requirement that the instance of $\mathsf{Seq}$ returned by $\mathsf{SPair}$ is \emph{equal} to a product.
This encoding is particularly convenient when representing GADTs as Church encodings~\cite{vw10,atk12}.

Add third example here.

%{\color{blue} Do we really need the existential quantifiers?}


%To determine the possible shapes of a GADT's container we must
%pattern-match on the type of the data to be contained.
%For this, it is essential that a GADT calculus support an equality type
%$\mathsf{Equal}$ that is a singleton set when its two type arguments
%are the same and is the empty set otherwise.
%That is, the type $\mathsf{Equal}$ must be the syntactic reflection
%of semantic equality function $\mathit{Equal}$.
%The type $\mathsf{Equal}$ can either be
%defined via GADT syntax, as in
%\[\begin{array}{l}
%\mathsf{data\, Equal\,a\,b\,where}\\
%\mathsf{\;\;\;\;\;\;\;\;Refl ::\, Equal\,c\,c}
%\end{array}\]





\section{(Deep) induction for GADTs}

%\begin{itemize}
%    \item Recall structural induction does not work for GADTs because it does not work for truly nested types.
%    \item Induction rules are traditionally derived using functoriality
%    \item This cannot be extended to GADTs in this setting because they have no functorial semantics
%    \item This paper nevertheless shows how to extend (deep) induction to GADTs.
%\end{itemize}

As we have seen in Subsection~\ref{ssec:induction-nested},
truly nested types do not support a structural induction rule,
which is the reason why it was necessary to introduce a deep induction rule supporting them.
Consequently, GADTs do not support a structural induction rule either,
as they generalize nested types.
Still, there is hope for GADTs to support a deep induction rule,
like nested types do.

Induction rules, and specifically deep induction rules for nested types,
are traditionally derived using the functorial semantics of data types
in the setting of a parametric model~\cite{jp20}.
In particular, relational parametricity is used to validate the induction principle because induction is, itself,
a form of unary parametricity, where binary relations have been replaced with predicates,
which are essentially unary relations.
%in the sense that induction involves predicates, which are unary relations,
%as opposed to the binary relations involved in relational parametricity.

Unfortunately, this approach cannot possibly be employed
to prove a deep induction rule for GADTs,
as these types do not allow for a functorial interpretation,
at least in a parametric model~\cite{Haskell-paper}.

Nevertheless, this paper shows how to extend deep induction to some GADTs.
We will first demonstrate how to derive the deep induction rule for some example GADTs,
and then provide a general principle that works for GADTs not featuring nesting in their definition.



\subsection{(Deep) induction for $\mathsf{Equal}$}

%\begin{itemize}
%\item Define $\mathsf{Equal}^{\wedge}$
%\[
%\mathsf{Equal^{\wedge} : \forall (a : Set) (b : Set) \to (a \to Set) \to (b \to Set) \to Equal\,a\,b \to Set}
%\]
%is defined by
%\[
%\mathsf{Equal^{\wedge}\,a\,a\,Q\,Q'\,Refl = \forall (x : a) \to Equal\,(Q\,x)(Q'\,x)}
%\]
%\item (Deep) induction rule for $\mathsf{Equal}$
%\item Prove deep induction for $\mathsf{Equal}$ (define term)
%\end{itemize}

As a first example, we derive the induction rule for the $\mathsf{Equal}$ type.
This will provide a simple case study that will help with the derivation of the induction rule for more complex GADTs.
Moreover, since we define GADTs using the $\mathsf{Equal}$ type,
as for example in Equation~\ref{eq:eq-seq},
this example will be instrumental in the induction rule of other GADTs.

%We first need to represent $\mathsf{Equal}$ as 
%\begin{equation}\label{eq:alt-eq}
%\begin{array}{l}
%\mathsf{data\, Equal\,(a\,b : Set) : Set\,where}\\
%\mathsf{\;\;\;\;\;\;\;\;Refl :\, \exists (c : Set) \to Equal\,a\,c \to Equal\,b\,c \to Equal\,a\,b}
%\end{array}
%\end{equation}
%\begin{multline}
%\mathsf{\forall (P : \forall (a\,b : Set) \to (a \to Set) \to (b \to Set) \to Equal\,a\,b \to Set)} \\
%\mathsf{\to \big( \forall (a : Set) (b : Set) (c : Set) (Q_a : a \to Set) (Q_b : b \to Set) (Q_c : c \to Set) (e_a: Equal\,a\,c) (e_b: Equal\,b\,c)}\\
%	\mathsf{\to Equal^{\wedge}\,a\,c\,Q_a\,Q_c\,e_a \to Equal^{\wedge}\,b\,c\,Q_b\,Q_c\,e_b \to P\,c\,c\,Q_c\,Q_c\,Refl \big)} \\
%\mathsf{\to \big( \forall (a : Set) (b : Set) (Q_a : a \to Set) (Q_b : b \to Set) (e: Equal\,a\,b)
%	\to Equal^{\wedge}\,a\,b\,Q_a\,Q_b\,e \to P\,a\,b\,Q_a\,Q_b\,e \big)}
%\end{multline}

To define the induction rule for $\mathsf{Equal}$ we first need a predicate-lifting operation
\[
\mathsf{Equal^{\wedge} : \forall (a : Set) (b : Set) \to (a \to Set) \to (b \to Set) \to Equal\,a\,b \to Set}
\]
defined as
\[
\mathsf{Equal^{\wedge}\,a\,a\,Q\,Q'\,Refl = \forall (x : a) \to Equal\,(Q\,x)(Q'\,x)}
\]

Let $\mathsf{CRefl}$ be the following type associated to the $\mathsf{Refl}$ constructor:
\begin{multline*}
\mathsf{\forall (P : \forall (a\,b : Set) \to (a \to Set) \to (b \to Set) \to Equal\,a\,b \to Set)} \\
\mathsf{\to \forall (c : Set) (Q : c \to Set) (Q' : c \to Set) \to Equal^{\wedge}\,c\,c\,Q\,Q'\,Refl \to P\,c\,c\,Q\,Q'\,Refl}
\end{multline*}


The induction rule for $\mathsf{Equal}$ is the type
\begin{multline*}
\mathsf{\forall (P : \forall (a\,b : Set) \to (a \to Set) \to (b \to Set) \to Equal\,a\,b \to Set)} \\
%\mathsf{\to \big( \forall (c : Set) (Q : c \to Set) (Q' : c \to Set) \to Equal^{\wedge}\,c\,c\,Q\,Q'\,Refl \to P\,c\,c\,Q\,Q'\,Refl \big)} \\
\mathsf{\to CRefl\,P \to \forall (a : Set) (b : Set) (Q_a : a \to Set) (Q_b : b \to Set) (e: Equal\,a\,b)} \\
	\mathsf{\to Equal^{\wedge}\,a\,b\,Q_a\,Q_b\,e \to P\,a\,b\,Q_a\,Q_b\,e}
\end{multline*}
We define a term $\mathsf{DIEqual}$ of such type as
\[
\mathsf{DIEqual\,P\,crefl\,a\,a\,Q_a\,Q_a'\,Refl\,L_E = crefl\,a\,Q_a\,Q_a'\,L_E}
\]
where
$\mathsf{crefl : CRefl\,P}$,
%$\mathsf{PRefl : \forall (c : Set) (Q : c \to Set) (Q' : c \to Set) \to Equal^{\wedge}\,c\,c\,Q\,Q'\,Refl \to P\,c\,c\,Q\,Q'\,Refl}$
$\mathsf{Q_a : a \to Set}$, $\mathsf{Q_a' : a \to Set}$
and $\mathsf{L_E : Equal^{\wedge}\,a\,a\,Q_a\,Q_a'\,Refl}$.
Having provided a well-defined term for it,
we have shown that the induction rule for $\mathsf{Equal}$ holds.



\subsection{(Deep) induction for $\mathsf{Seq}$}

Next, we shall provide an induction rule for the $\mathsf{Seq}$ type defined in Equation~\ref{eq:eq_seq}.
Again, the first step in deriving the induction rule for $\mathsf{Seq}$ consists in defining the predicate-lifting function over it, 
\[
\mathsf{Seq^{\wedge} : \forall (a : Set) \to (a \to Set) \to Seq\,a \to Set}
\]
which is given by pattern-matching as
\[
\mathsf{Seq^{\wedge}\,a\,Q_a\,(Const\,x) = Q_a\,x}
\]
where $\mathsf{Q_a : a \to Set}$ and $\mathsf{x : a}$,
and
\begin{multline*}
\mathsf{Seq^{\wedge}\,a\,Q_a\,(SPair\,b\,c\,e\,s_b\,s_c)} \\
\mathsf{=
\exists (Q_b : b \to Set) (Q_c : c \to Set)
\to Equal^{\wedge}\,a\, (b \times c)\, Q_a\, (Q_b \times Q_c) \, e \times Seq^{\wedge}\,b\,Q_b\,s_b \times Seq^{\wedge}\,c\,Q_c\,s_c
}
\end{multline*}
where $\mathsf{e : Equal\,a\,(b \times c)}$,
$\mathsf{s_b : Seq\,b}$ and $\mathsf{s_c : Seq\,c}$.
We also need the lifting of predicates over the polymorphic type of pairs, $\mathsf{Pair = \forall (b : Set)(c : Set) \to b \times c}$, which is 
\[
\mathsf{Pair^{\wedge} : \forall (b : Set)(c : Set) \to (b \to Set) \to (c \to Set) \to Pair\,b\,c \to Set}
\]
and it is defined as
\[
\mathsf{Pair^{\wedge}\,b\,c\,Q_b\,Q_c\,(y, z) = Q_b\,y \times Q_c\,z}
\]
where $\mathsf{Q_b : b \to Set}$, $\mathsf{Q_c : c \to Set}$, $\mathsf{y : b}$ and $\mathsf{z : c}$.

Finally, let $\mathsf{CConst}$ be the type
\begin{multline*}
\mathsf{\forall (P : \forall (a : Set) \to (a \to Set) \to Seq\,a \to Set)} \\
\mathsf{\to \forall (a : Set) (Q_a : a \to Set) (x : a) \to Q_a\,x \to P\,a\,Q_a\,(Const\,x)}
\end{multline*}
associated to the $\mathsf{Const}$ constructor,
and let $\mathsf{CSPair}$ be the type
\begin{multline*}
\mathsf{\forall (P : \forall (a : Set) \to (a \to Set) \to Seq\,a \to Set)} \\
\mathsf{\to \forall (a : Set) (b : Set) (c : Set)
	(Q_a : a \to Set) (Q_b : b \to Set) (Q_c : c \to Set)} \\
	\mathsf{(s_b : Seq\,b) (s_c : Seq\,c) (e : Equal\,a\,(b \times c))
	\to Equal^{\wedge} a\, (b \times c)\, Q_a\, (Pair^{\wedge}\,b\,c\,Q_b\,Q_c)\, e} \\
	\mathsf{\to P\,b\,Q_b\,s_b \to P\,c\,Q_c\,s_c
	\to P a Q_a ( SPair\,b\,c\,e\,s_b\,s_c )}
\end{multline*}
associated to the $\mathsf{SPair}$ constructor,

With these tools, we have an induction rule for $\mathsf{Seq}$,
\begin{multline*}
\mathsf{\forall (P : \forall (a : Set) \to (a \to Set) \to Seq\,a \to Set)}
\mathsf{\to CConst\,P \to CSPair\,P} \\
%\mathsf{\to \big( \forall (a : Set) (Q_a : a \to Set) (x : a) \to Q_a\,x \to P\,a\,Q_a\,(Const\,x) \big)} \\
%\mathsf{\to \big( \forall (a : Set) (b : Set) (c : Set)
%	(Q_a : a \to Set) (Q_b : b \to Set) (Q_c : c \to Set)} \\
%	\mathsf{(s_b : Seq\,b) (s_c : Seq\,c) (e : Equal\,a\,(b \times c))
%	\to Equal^{\wedge} a\, (b \times c)\, Q_a\, (Pair^{\wedge}\,b\,c\,Q_b\,Q_c)\, e} \\
%	\mathsf{\to P\,b\,Q_b\,s_b \to P\,c\,Q_c\,s_c
%	\to P a Q_a ( SPair\,b\,c\,e\,s_b\,s_c ) \big)} \\
\mathsf{\to \forall (a : Set)(Q_a : a \to Set)(s_a : Seq\,a) \to Seq^{\wedge}\,a\,Q_a\,s_a \to P\,a\,Q_a\,s_a}
\end{multline*}
To validate the induction rule, we define a term $\mathsf{DISeq}$ for it.
We have to define
\[
\mathsf{DISeq\,P\,cconst\,cspair\,a\,Q_a\,s_a\,L_a : P\,a\,Q_a\,s_a}
\]
where
$\mathsf{P : \forall (a : Set) \to (a \to Set) \to Seq\,a \to Set}$,
$\mathsf{cconst : CConst\,P}$,
$\mathsf{cspair : CSPair\,P}$,
% are terms for the clauses
%associated to the constructors $\mathsf{Const}$ and $\mathsf{SPair}$,
%respectively, in the induction rule,
$\mathsf{Q_a : a \to Set}$, $\mathsf{s_a : Seq\,a}$
and $\mathsf{L_a : Seq^{\wedge}\,a\,Q\,s_a}$,
and we proceed by pattern-matching on $\mathsf{s_a}$.
Let $\mathsf{s_a = Const\,x}$ for $\mathsf{x : a}$, and define
\[
\mathsf{DISeq\,P\,cconst\,cspair\,a\,Q_a\,(Const\,x)\,L_a = cconst\,a\,Q_a\,x\,L_a}
\]
Notice that $\mathsf{Seq^{\wedge}\,a\,Q_a\,(Const\,x) = Q_a\,x}$, and thus $\mathsf{L_a : Q_a\,x}$,
making the right-hand-side in the above expression type-check.
Now, let $\mathsf{s_a = SPair\,b\,c\,e\,s_b\,s_c}$
for $\mathsf{e : Equal\,a\,(b \times c)}$, $\mathsf{s_b : Seq\,b}$ and $\mathsf{s_c : Seq\,c}$,
and define
\[
\mathsf{DISeq\,P\,cconst\,cspair\,a\,Q_a\,(SPair\,b\,c\,e\,s_b\,s_c)\,(Q_b, Q_c, L_e, L_b, L_c)
	= cspair\,a\,b\,c\,Q_a\,Q_b\,Q_c\,s_b\,s_c\,e\,L_e\,p_b\,p_c}
\]
where $\mathsf{(Q_b, Q_c, L_e, L_b, L_c) : Seq^{\wedge}\,a\,Q\,(SPair\,b\,c\,e\,x\,y)}$, i.e.,
\begin{itemize}
\item $\mathsf{Q_b : b \to Set}$ and $\mathsf{Q_c : c \to Set}$;
%\item $\mathsf{p_b : P\,b\,Q_b\,s_b}$ and $\mathsf{p_c : P\,c\,Q_c\,s_c}$;
\item $\mathsf{L_e : Equal^{\wedge}\,a\, (b \times c)\, Q_a\, (Q_b \times Q_c) \, e}$;
\item $\mathsf{L_b : Seq^{\wedge}\,b\,Q_b\,s_b}$ and $\mathsf{L_c : Seq^{\wedge}\,c\,Q_c\,s_c}$;
%(notice that $\mathsf{(Q_b, Q_c, L_e, L_b, L_c) : Seq^{\wedge}\,a\,Q\,(SPair\,b\,c\,e\,x\,y)}$,
%making the right-hand-side in the above expression type-check)
\end{itemize}
and $\mathsf{p_b}$ and $\mathsf{p_c}$ are defined as follows:
\begin{align*}
\mathsf{p_b} &=\mathsf{DISeq\,P\,cconst\,cspair\,b\,Q_b\,s_b\,L_b : P\,b\,Q_b\,s_b} \\
\mathsf{p_c} &=\mathsf{DISeq\,P\,cconst\,cspair\,c\,Q_c\,s_c\,L_c : P\,c\,Q_c\,s_c}
\end{align*}





%\subsection{(Deep) induction for $\mathsf{Seq}$ (general style)}
%
%We need the lifting of the type $\mathsf{Pair = \forall (b : Set)(c : Set) \to b \times c}$, which is 
%\[
%\mathsf{Pair^{\wedge} : \forall (b : Set)(c : Set) \to (b \to Set) \to (c \to Set) \to b \times c \to Set}
%\]
%defined as
%\[
%\mathsf{Pair^{\wedge}\,b\,c\,Q_b\,Q_c\,(y, z) = Q_b\,y \times Q_c\,z}
%\]
%
%%Let 
%%$\mathsf{F, F_1, F_2 : (Set \to Set) \to Set \to Set \to Set}$
%%be defined as
%%$\mathsf{F_1\,G\,b\,c = G\,b}$,
%%$\mathsf{F_2\,G\,b\,c = G\,c}$,
%%$\mathsf{F\,G\,b\,c = F_1\,G\,b\,c \times F_2\,G\,b\,c}$,
%%and $\mathsf{K = Pair}$.
%
%
%Let 
%$\mathsf{F : (Set \to Set) \to Set \to Set \to Set}$
%be defined as
%$\mathsf{F\,G\,b\,c = G\,b \times G\,c}$
%and $\mathsf{K = Pair}$.
%
%%The type of $\mathsf{F_i^{\wedge}}$ is
%%\begin{multline*}
%%\mathsf{\forall (G : Set \to Set) (b : Set) (c : Set)
%%\to (\forall (a : Set) \to (a \to Set) \to G\,a \to Set)} \\
%%\mathsf{\to (b \to Set) \to (c \to Set) \to (F_i\,G\,b\,c) \to Set}
%%\end{multline*}
%The type of $\mathsf{F^{\wedge}}$ is
%\begin{multline*}
%\mathsf{\forall (G : Set \to Set) (b : Set) (c : Set)
%\to (\forall (a : Set) \to (a \to Set) \to G\,a \to Set)} \\
%\mathsf{\to (b \to Set) \to (c \to Set) \to (F_1\,G\,b\,c \times F_2\,G\,b\,c) \to Set}
%\end{multline*}
%%and $\mathsf{F^{\wedge}\,G\,b\,c\,P\,Q_b\,Q_c\,(s_b, s_c)
%%= F_1^{\wedge}\,G\,b\,c\,P\,Q_b\,Q_c\,s_b \times F_2^{\wedge}\,G\,b\,c\,P\,Q_b\,Q_c\,s_c}$
%
%Next we shall consider the $\mathsf{Seq}$ type defined in Equation~\ref{eq:eq_seq}.
%Again, the first step in deriving its induction rule consists in defining the lifting
%\[
%\mathsf{Seq^{\wedge} : \forall (a : Set) \to (a \to Set) \to Seq\,a \to Set}
%\]
%which is given by
%\[
%\mathsf{Seq^{\wedge}\,a\,Q\,(Const\,x) = Q\,x}
%\]
%and
%\begin{multline*}
%\mathsf{Seq^{\wedge}\,a\,Q_a\,(SPair\,b\,c\,e\,(s_b,s_c))
%=
%\exists (Q_b : b \to Set) (Q_c : c \to Set)} \\
%\mathsf{
%\to Equal^{\wedge}\,a\, (Pair\,b\,c)\, Q_a\, (Pair^{\wedge}\,b\,c\,Q_b\,Q_c) \, e
%\times F^{\wedge}\,Seq\,b\,c\,Seq^{\wedge}\,Q_b\,Q_c\,(s_b, s_c)
%}
%\end{multline*}
%%\begin{multline*}
%%\mathsf{Seq^{\wedge}\,a\,Q_a\,(SPair\,b\,c\,e\,(s_b,s_c))
%%=
%%\exists (Q_b : b \to Set) (Q_c : c \to Set)} \\
%%\mathsf{
%%\to Equal^{\wedge}\,a\, (Pair\,b\,c)\, Q_a\, (Pair^{\wedge}\,b\,c\,Q_b\,Q_c) \, e
%%\times F_1^{\wedge}\,Seq\,b\,c\,Seq^{\wedge}\,Q_b\,Q_c\,s_b
%%\times F_2^{\wedge}\,Seq\,b\,c\,Seq^{\wedge}\,Q_b\,Q_c\,s_c
%%}
%%\end{multline*}
%
%Define
%\[
%\mathsf{PredMap : \forall (a : Set) \to (a \to Set) \to (a \to Set) \to Set}
%\]
%as $\mathsf{PredMap\,a\,Q_1\,Q_2 = \forall (x : a) \to Q_1\,x \to Q_2\,x}$
%
%%  -- Lifting also acts on morphisms between predicates with the same carrier
%%  {-# TERMINATING #-}
%%  Bush^-map : âˆ€ {l} {X : Set} {Q1 Q2 : X â†’ Set l}
%%              â†’ Pred-map {l} Q1 Q2 â†’ Pred-map (Bush^ Q1) (Bush^ Q2)
%%  Bush^-map Q12 Bnil q = bigtt
%%  Bush^-map Q12 (Bcons x b) (y , bby) =
%%                Q12 x y , Bush^-map (Bush^-map Q12) b bby
%Define
%\[
%\mathsf{SeqLMap : \forall (a : Set) (Q_1\,Q_2 : a \to Set) \to PredMap\,a\,Q_1\,Q_2 \to PredMap\,(G\,a)\,(Seq^{\wedge}\,a\,Q_1)\,(Seq^{\wedge}\,a\,Q_2)}
%\]
%as
%\begin{gather*}
%\mathsf{
%SeqLMap\,a\,Q_1\,Q_2\,M\,(Const\,x)\,z = M\,x\,z
%} \\
%\mathsf{
%SeqLMap\,a\,Q_1\,Q_2\,M\,(SPair\,b\,c\,e\,s_b\,s_c)\,(Q_b, Q_c, l_E, l_F) =
%}
%\end{gather*}
%
%
%We have an induction rule for $\mathsf{Seq}$
%\begin{multline}
%\mathsf{DISeq : \forall (P : \forall (a : Set) \to (a \to Set) \to Seq\,a \to Set)} \\
%\mathsf{\to \big( \forall (a : Set) (Q_a : a \to Set) (x : a) \to Q_a\,x \to P\,a\,Q_a\,(Const\,x) \big)} \\
%\mathsf{\to \big( \forall (a : Set) (b : Set) (c : Set)
%	(Q_a : a \to Set) (Q_b : b \to Set) (Q_c : c \to Set)} \\
%	\mathsf{( (s_b, s_c) : F\,Seq\,b\,c) (e : Equal\,a\,(Pair\,b\,c))
%	\to Equal^{\wedge} a\, (Pair\,b\,c)\, Q_a\, (Pair^{\wedge}\,b\,c\,Q_b\,Q_c)\, e} \\
%	\mathsf{\to F^{\wedge}\,G\,b\,c\,P\,Q_b\,Q_c\,(s_b,s_c)
%	\to P a Q_a ( SPair\,b\,c\,e\,(s_b,s_c) ) \big)} \\
%\mathsf{\to \forall (a : Set)(Q_a : a \to Set)(s_a : Seq\,a) \to Seq^{\wedge}\,a\,Q_a\,s_a \to P\,a\,Q_a\,s_a}
%\end{multline}
%We define $\mathsf{DISeq\,P\,PConst\,PSPair\,a\,Q_a\,s_a\,l_a}$,
%where
%$\mathsf{P : \forall (a : Set) \to (a \to Set) \to Seq\,a \to Set}$,
%$\mathsf{Q_a : a \to Set}$, $\mathsf{s_a : Seq\,a}$
%and $\mathsf{l_a : Seq^{\wedge}\,a\,Q\,s_a}$,
%by pattern-matching on $\mathsf{s_a}$.
%Let $\mathsf{s_a = Const\,x}$ for $\mathsf{x : a}$, and define
%\[
%\mathsf{DISeq\,P\,PConst\,PSPair\,a\,Q_a\,(Const\,x)\,l_a = PConst\,a\,Q_a\,x\,l_a}
%\]
%Notice that $\mathsf{Seq^{\wedge}\,a\,Q_a\,(Const\,x) = Q_a\,x}$, and thus $\mathsf{l_a : Q_a\,x}$,
%making the right-hand-side in the above expression type-check.
%Now, let $\mathsf{s_a = SPair\,b\,c\,e\,(s_b,s_c)}$
%for $\mathsf{e : Equal\,a\,(Pair\,b\,c)}$ and $\mathsf{(s_b, s_c) : F\,Seq\,b\,c}$,
%and define
%\[
%\mathsf{DISeq\,P\,PConst\,PSPair\,a\,Q_a\,(SPair\,b\,c\,e\,(s_b,s_c))\,(Q_b, Q_c, l_e, l_{F_1}, l_{F_2})
%	= PSPair\,a\,b\,c\,Q_a\,Q_b\,Q_c\,(s_b,s_c)\,e\,l_e\,p}
%\]
%where
%$\mathsf{p : F^{\wedge}\,G\,b\,c\,P\,Q_b\,Q_c\,(s_b,s_c)}$,
%$\mathsf{l_e : Equal^{\wedge}\,a\, (Pair\,b\,c)\, Q_a\, (Pair^{\wedge}\,Q_b\,Q_c) \, e}$,
%$\mathsf{l_{F_1} : F_1^{\wedge}\,Seq\,b\,c\,Seq^{\wedge}\,Q_b\,Q_c\,s_b}$,
%$\mathsf{l_{F_2} : F_2^{\wedge}\,Seq\,b\,c\,Seq^{\wedge}\,Q_b\,Q_c\,s_c}$
%(notice that $\mathsf{(Q_b, Q_c, l_e, l_{F_1}, l_{F_2}) : Seq^{\wedge}\,a\,Q\,(SPair\,b\,c\,e\,x\,y)}$,
%making the right-hand-side in the above expression type-check)
%and $\mathsf{p}$ is defined as follows:
%\[
%\mathsf{p = (???, ???) 
%: F_1^{\wedge}\,G\,b\,c\,P\,Q_b\,Q_c\,s_b \times F_2^{\wedge}\,G\,b\,c\,P\,Q_b\,Q_c\,s_c} \\
%\]



%\begin{align*}
%\mathsf{DISeq\,P\,PConst\,PSPair\,a\,Q\,(Const\,x)\,l}
%	&=\mathsf{PConst\,a\,Q\,x\,l} \\
%\mathsf{DISeq\,P\,PConst\,PSPair\,a\,Q_a\,(SPair\,b\,c\,e\,x\,y)\,(Q_b\,Q_c\,e', l_b, l_c)}
%	&=\mathsf{PSpair\,a\,b\,c\,Q_a\,Q_b\,Q_c\,x\,y\,e\,p_b\,p_c\,e'}
%\end{align*}
%where
%$\mathsf{Q_a : a \to Set}$, $\mathsf{Q_b : b \to Set}$, $\mathsf{Q_c : c \to Set}$,
%$\mathsf{x : Seq\,b}$, $\mathsf{y : Seq\,c}$,
%$\mathsf{e : Equal\,a\,(b \times c)}$,
%$\mathsf{p_b : P\,b\,Q_b\,x}$, $\mathsf{p_c : P\,c\,Q_c\,y}$,
%$\mathsf{e' : Equal^{\wedge}\,a\, (b \times c)\, Q\, (Q_b \times Q_c) \, e}$,
%$\mathsf{l_b : Seq^{\wedge}\,b\,Q_b\,x}$,
%$\mathsf{l_c : Seq^{\wedge}\,c\,Q_c\,y}$
%and
%\begin{align*}
%\mathsf{p_b} &=\mathsf{DISeq\,P\,PConst\,PSPair\,b\,Q_b\,x\,l_b : P\,b\,Q_b\,x} \\
%\mathsf{p_c} &=\mathsf{DISeq\,P\,PConst\,PSPair\,c\,Q_c\,y\,l_c : P\,c\,Q_c\,y}
%\end{align*}
%
%\begin{align*}
%\mathsf{Q_a} &: \mathsf{a \to Set} \\
%\mathsf{Q_b} &: \mathsf{b \to Set} \\
%\mathsf{Q_c} &: \mathsf{c \to Set} \\
%\mathsf{x} &: \mathsf{Seq\,b} \\
%\mathsf{y} &: \mathsf{Seq\,c} \\
%\mathsf{e} &: \mathsf{Equal\,a\,(b \times c)} \\
%\mathsf{p_b} &: \mathsf{P\,b\,Q_b\,x} \\
%\mathsf{p_c} &: \mathsf{P\,c\,Q_c\,y} \\
%\mathsf{e'} &: \mathsf{Equal^{\wedge}\,a\, (b \times c)\, Q\, (Q_b \times Q_c) \, e} \\
%\mathsf{l_b} &: \mathsf{Seq^{\wedge}\,b\,Q_b\,x} \\
%\mathsf{l_c} &: \mathsf{Seq^{\wedge}\,c\,Q_c\,y} \\
%\mathsf{p_b = DISeq\,P\,PConst\,PSPair\,b\,Q_b\,x\,l_b} &: \mathsf{P\,b\,Q_b\,x} \\
%\mathsf{p_c = DISeq\,P\,PConst\,PSPair\,c\,Q_c\,y\,l_c} &: \mathsf{P\,c\,Q_c\,y}
%\end{align*}



\subsection{Third example introduced above}

%Same structure as previous two.
%Runs through the paper.
%Still to decide?



\subsection{Induction for GADTs with nesting}\label{sec:GADT-nested}

In the previous sections,
we derive induction rules for examples of GADTs that do not feature nesting,
in the sense that their constructors contain no nested calls of the recursive variable,
as truly nested types do.
Since both nested types~\cite{jp20}
and GADTs without nesting admit induction rules,
it is just natural to expect that GADTs with nesting would as well.
Surprisingly, that is not the case:
indeed, induction rules for nested types rely on functorial semantics,
but GADTs cannot admit both functorial and parametric semantics at the same time~\cite{HaskellPaper}.
In this section we show how induction for GADTs featuring nesting goes wrong
by analyzing the following concrete example of such a type.
\begin{equation}
\begin{array}{l}
\mathsf{data\, G\,(a : Set) : Set\,where}\\
\mathsf{\;\;\;\;\;\;C :\, G(G\,a) \to G(a \times a)}
\end{array}
\end{equation}
The constructor $\mathsf{C}$ can be rewritten as
\[
\mathsf{C : \exists (b : Set) \to Equal\,a\,(b \times b) \to G(G\,b) \to G\,a}
\]
which is the form we shall use from now on.
The predicate-lifting function of $\mathsf{G}$,
\[
\mathsf{G^{\wedge} : \forall (\ol{a : Set}) \to (\ol{a \to Set}) \to G\,\ol{a} \to Set}
\]
is defined as
\[
\mathsf{G^{\wedge}\,a\,Q_a\,(C\,b\,e\,x)
= \exists (Q_b : b \to Set)
\to Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e
\times G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x}
\]
where $\mathsf{Q_a : a \to Set}$, $\mathsf{e : Equal\,a\,(b \times b)}$ and $\mathsf{x : G(G\,b)}$.

Finally, let $\mathsf{CC}$ be the type
\begin{multline*}
\mathsf{\forall (P : \forall (a : Set) \to (a \to Set) \to G\,a \to Set)} \\
\mathsf{\to \forall (a\;b : Set) (Q_a : a \to Set) (Q_b : b \to Set) (e : Equal\,a\,(b \times b)) (x : G\,(G\,b))} \\
\mathsf{\to Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e
	\to P\,(G\,b)\,(P\,b\,Q_b)\,x
	\to P\,a\,Q_a\,(C\,b\,e\,x)}
\end{multline*}
associated to the $\mathsf{C}$ constructor.

The induction rule for $\mathsf{G}$ is
\begin{multline*}
\mathsf{\forall (P : \forall (a : Set) \to (a \to Set) \to G\,a \to Set) \to CC\,P} \\
%\mathsf{\to \Big( \forall (a\;b : Set) (Q_a : a \to Set) (Q_b : b \to Set) (e : Equal\,a\,(b \times b)) (x : G\,(G\,b))} \\
%\mathsf{\to Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e
%	\to P\,(G\,b)\,(P\,b\,Q_b)\,x
%	\to P\,a\,Q_a\,(C\,b\,e\,x) \Big)}\\
\mathsf{\to \forall (a : Set)(Q_a : a \to Set)(y : G\,a) \to G^{\wedge}\,a\,Q_a\,y \to P\,a\,Q_a\,y}
\end{multline*}
Consistently with the previous examples,
we define a term validating the induction rule, $\mathsf{DIG}$, as
\[
\mathsf{DIG\,P\,cc\,a\,Q_a\,(C\,b\,e\,x)\,(Q_b, L_E, L_G)
= cc\,a\,b\,Q_a\,Q_b\,e\,x\,L_E\,p}
\]
where $\mathsf{cc : CC\,P}$,
$\mathsf{C\,b\,e\,x : G\,a}$,
%, the second to last term applied to $\mathsf{DIG}$,
%has type $\mathsf{G\,a}$,
i.e., $\mathsf{e : Equal\,a\,(b \times b)}$ and $\mathsf{x : G(G\,b)}$,
and $\mathsf{(Q_b, L_E, L_G) : G^{\wedge}\,a\,Q_a\,(C\,b\,e\,x)}$,
%, the last term applied to $\mathsf{DIG}$,
%has type $\mathsf{G^{\wedge}\,a\,Q_a\,(C\,b\,e\,x)}$,
i.e., $\mathsf{Q_b : b \to Set}$, $\mathsf{L_E : Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e}$,
and $\mathsf{L_G : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x}$.
%\begin{gather*}
%\mathsf{Q_b : b \to Set} \\
%\mathsf{L_E : Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e} \\
%\mathsf{L_G : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x}
%%\mathsf{p = DIG\,P\,pc\,(G\,b)\,(P\,b\,Q_b)\,x\,q : P\,(G\,b)\,(P\,b\,Q_b)\,x}
%\end{gather*}
We still need to define $\mathsf{p : P\,(G\,b)\,(P\,b\,Q_b)\,x}$.
We do so by using the induction rule and letting
\[
\mathsf{p = DIG\,P\,cc\,(G\,b)\,(P\,b\,Q_b)\,x\,q}
\]
where we still need to provide $\mathsf{q : G^{\wedge}\,(G\,b)\,(P\,b\,Q_b)\,x}$.
To produce such $\mathsf{q}$, we need the map function of $\mathsf{G^{\wedge}}$,
\[
\mathsf{GLMap : \forall (a : Set) (Q_a\;Q_a' : a \to Set) \to PredMap\,a\,Q_a\,Q_a' \to PredMap\,(G\,a)\,(G^{\wedge}\,a\,Q_a)\,(G^{\wedge}\,a\,Q_a')}
\]
where $\mathsf{PredMap : \forall (a : Set) \to (a \to Set) \to (a \to Set) \to Set}$
is defined as
\[
\mathsf{PredMap\,a\,Q_a\,Q_a' = \forall (x : a) \to Q_a\,x \to Q_a'\,x}
\]
and represents the type of morphisms between predicates.
If we had $\mathsf{GLMap}$, then we would be able to define
\[
\mathsf{q = GLMap\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,(P\,b\,Q_b)\,(DIG\,P\,cc\,b\,Q_b)\,x\,L_G}
\]
Unfortunately, we cannot define such a $\mathsf{GLMap}$.
Indeed, its definition would have to be
\[
\mathsf{GLMap\,a\,Q_a\,Q_a'\,M\,(C\,b\,e\,x)\,(Q_b, L_E, L_G) = (Q_b', L_E', L_G')}
\]
where $\mathsf{Q_a : a \to Set}$, $\mathsf{Q_a' : a \to Set}$,
$\mathsf{M : PredMap\,a\,Q_a\,Q_a'}$,
$\mathsf{C\,b\,e\,x : G\,a}$, i.e.,
\begin{itemize}
\item $\mathsf{e : Equal\,a\,(b \times b)}$;
\item $\mathsf{x : G\,(G\,b)}$;
\end{itemize}
$\mathsf{(Q_b, L_E, L_G)}$ has type $\mathsf{G^{\wedge}\,a\,Q_a\,(C\,b\,e\,x)}$, i.e.,
\begin{itemize}
\item $\mathsf{Q_b : b \to Set}$;
\item $\mathsf{L_E : Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e}$;
\item $\mathsf{L_G : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x}$;
\end{itemize}
and $\mathsf{(Q_b', L_E', L_G')}$ has type $\mathsf{G^{\wedge}\,a\,Q_a'\,(C\,b\,e\,x)}$, i.e.,
\begin{itemize}
\item $\mathsf{Q_b' : b \to Set}$;
\item $\mathsf{L_E' : Equal^{\wedge}\,a\,(b \times b)\,Q_a'\,(Pair^{\wedge}\,b\,b\,Q'_b\,Q'_b)\,e}$;
\item $\mathsf{L_G' : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b')\,x}$;
\end{itemize}
%\begin{gather*}
%\mathsf{Q_a\;Q_a' : a \to Set} \\
%\mathsf{Q_b\;Q_b' : b \to Set} \\
%%\mathsf{M : PredMap\,b\,Q_a\,Q_a'} \\
%\mathsf{L_E : Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e} \\
%\mathsf{L_G\ : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x} \\
%\mathsf{L_E' : Equal^{\wedge}\,a\,(b \times b)\,Q_a'\,(Pair^{\wedge}\,b\,b\,Q'_b\,Q'_b)\,e} \\
%\mathsf{L_G' : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b')\,x}
%\end{gather*}
In other words, we have a proof $\mathsf{L_E}$ of the (extensional) equality
of the predicates $\mathsf{Q_a}$ and $\mathsf{Pair^{\wedge}\,b\,b\,Q_b\,Q_b}$
and a morphism of predicates $\mathsf{M}$ from $\mathsf{Q_a}$ to $\mathsf{Q_a'}$,
and we need to use those to deduce a proof of the (extensional) equality
of the predicates $\mathsf{Q_a'}$ and $\mathsf{Pair^{\wedge}\,b\,b\,Q_b'\,Q_b'}$,
for some  for some predicate $\mathsf{Q_b'}$ on $\mathsf{b}$.
But that is not generally possible:
the facts that $\mathsf{Q_a}$ is equal to $\mathsf{Pair^{\wedge}\,b\,b\,Q_b\,Q_b}$
and that there is a morphism of predicates $\mathsf{M}$ from $\mathsf{Q_a}$ to $\mathsf{Q_a'}$
do not guarantee that $\mathsf{Q_a'}$ is equal to $\mathsf{Pair^{\wedge}\,bb\,Q_b'\,Q_b'}$ for some $\mathsf{Q_b'}$.

At a deeper level, the fundamental issue is that
the $\mathsf{Equal}$ type does not have functorial semantics,
so that having morphisms $\mathsf{A \to A'}$ and $\mathsf{B \to B'}$
and a proof that $\mathsf{A}$ is equal to $\mathsf{A'}$
does not provide a proof that $\mathsf{B}$ is equal to $\mathsf{B'}$.
This is because GADTs can either have a syntax-only semantics or a functorial-completion semantics.
Since we are interested in induction rules, we considered GADTs with their syntax-only semantics,
which is parametric but it is not functorial.
Had we considered the functorial-completion semantics, instead,
we would have forfeited parametricity~\cite{HaskellPaper}.
In both cases, thus, we cannot derive an induction rule for generic GADTs when they feature nesting.



\subsection{General case}

%We restrict our scope to GADTs not featuring nesting,
%in the sense that their constructors contain no nested calls of the recursive variable,
%as truly nested types do.
%This way we can avoid the issue described in Section~\ref{sec:GADT-nested}.
%The reason for this restriction will be discussed in Section~\ref{sec:GADT-nested}.

Finally, we generalize the approach taken in the previous examples
and provide a general framework to derive induction rules for GADTs.
Since, as seen in Section~\ref{sec:GADT-nested},
GADTs featuring nesting do not admit an induction rule,
we restrict our scope to GADTs not featuring nesting.
Consider such a generic GADT
\begin{equation}\label{eq:gadt}
\begin{array}{l}
\mathsf{data\, G\,(\ol{a : Set}) : Set\,where}\\
\mathsf{\;\;\;\;\;\;\;\;C\, :\, F\,G\,\ol{b} \to G (\ol{K\,\ol{b}})}
\end{array}
\end{equation}
which, for ease of notation,
we assume to have only one constructor $\mathsf{C}$.
Extending the argument to GADTs with multiple constructors presents no difficulty.
In the definition above, $\mathsf{F}$ has type $\mathsf{(Set^{\alpha} \to Set) \to Set^{\beta} \to Set}$
and each $\mathsf{K}$ has type $\mathsf{Set^{\beta} \to Set}$.
The overline notation denotes a finite list:
%and the vertical bars notation denotes the length of a list:
$\mathsf{G}$ depends on a finite list of types $\mathsf{\ol{a}}$ of length $\mathsf{\alpha}$,
each of the $\mathsf{\alpha}$-many $\mathsf{K}$ depends on a finite list of types $\mathsf{\ol{b}}$ of length $\mathsf{\beta}$,
and notice that the length of the list of types $\mathsf{\ol{a}}$ matches that of the list of type constructors $\mathsf{\ol{K}}$.
With that in mind, the constructor $\mathsf{C}$ can be rewritten as
\[
\mathsf{C : \exists (\ol{b : Set}) \to \ol{Equal\,a\,(K\,\ol{b})} \to F\,G\,\ol{b} \to G\,\ol{a}}
\]
which is the form we shall use from now on.
Notice that, in the above constructor, we have a type
$\mathsf{Equal\,a\,(K\,\ol{b})}$ for each $\mathsf{a}$ and its corresponding type constructor $\mathsf{K}$.

In order to state the induction rule for $\mathsf{G}$,
we first need to define $\mathsf{G}$'s associated predicate-lifting function 
\[
\mathsf{G^{\wedge} : \forall (\ol{a : Set}) \to (\ol{a \to Set}) \to G\,\ol{a} \to Set}
\]
as
\[
\mathsf{G^{\wedge}\,\ol{a}\,\ol{Q_a}\,(C\,\ol{b}\,\ol{e_a}\,x)
= \exists (\ol{Q_b : b \to Set})
\to \ol{Equal^{\wedge}\,a\,(K\,\ol{b})\,Q_a\,(K^{\wedge}\,\ol{b}\,\ol{Q_b})\,e_a}
\times F^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,{\ol{Q_b}}\,x}
\]
where $\mathsf{Q_a : a \to Set}$
and $\mathsf{C\,\ol{b}\,\ol{e_a}\,x : G\,\ol{a}}$,
i.e., $\mathsf{e_a : Equal\,a\,(K\,\ol{b})}$ and $\mathsf{x : F\,G\,\ol{b}}$.
Notice that we need a type $\mathsf{Equal^{\wedge}\,a\,(K\,\ol{b})\,Q_a\,(K^{\wedge}\,\ol{b}\,\ol{Q_b})\,e_a}$
for each type $\mathsf{a}$ and its corresponding type constructor $\mathsf{K}$.
We also assume to have liftings for $\mathsf{F}$,
\begin{multline*}
\mathsf{F^{\wedge} : \forall (G : Set^{\alpha} \to Set) (\ol{b : Set})
\to (\forall (\ol{a : Set}) \to (\ol{a \to Set}) \to G\,\ol{a} \to Set)} \\
\mathsf{\to (\ol{b \to Set})
\to F\,G\,\ol{b} \to Set}
\end{multline*}
and for each  $\mathsf{K}$,
\[
\mathsf{K^{\wedge} : \forall (\ol{b : Set}) \to (\ol{b \to Set}) \to K\,\ol{b} \to Set}
\]
as we could not possibly define an induction rule otherwise.
A way to concretely define the predicate-lifting function for a type is to proceed by induction on the structure of the type,
and we have seen in the previous sections examples of how to do so for products and type application.
We do not give here the general definition of lifting,
as that would require to first present a full type calculus,
and that is beyond the scope of the paper.

Finally, associate the type
\begin{multline*}
\mathsf{CC = \forall (P : \forall (\ol{a : Set}) \to (\ol{a \to Set}) \to G\,\ol{a} \to Set)} \\
\mathsf{\to \forall (\ol{a : Set}) (\ol{b : Set}) (\ol{Q_a : a \to Set}) (\ol{Q_b : b \to Set}) (\ol{e_a : Equal\,a\,(K\,\ol{b})}) (x : F\,G\,\ol{b})} \\
\mathsf{\to \ol{Equal^{\wedge}\,a\,(K\,\ol{b})\,Q_a\,(K^{\wedge}\,\ol{b}\,\ol{Q_b})\,e_a}
	\to F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,x
	\to P\,\ol{a}\,\ol{Q_a}\,(C\,\ol{b}\,\ol{e_a}\,x)}
\end{multline*}
to the constructor $\mathsf{C}$.

%We can now define the induction rule for $\mathsf{G}$
The induction rule for $\mathsf{G}$ is
\begin{multline*}
\mathsf{\forall (P : \forall (\ol{a : Set}) \to (\ol{a \to Set}) \to G\,\ol{a} \to Set) \to CC\,P} \\
%\mathsf{\to \Big(
%\forall (\ol{a : Set}) (\ol{b : Set}) (\ol{Q_a : a \to Set}) (\ol{Q_b : b \to Set}) (\ol{e_a : Equal\,a\,(K\,\ol{b})}) (x : F\,G\,\ol{b})} \\
%\mathsf{\to \ol{Equal^{\wedge}\,a\,(K\,\ol{b})\,Q_a\,(K^{\wedge}\,\ol{b}\,\ol{Q_b})\,e_a}
%	\to F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,x
%	\to P\,\ol{a}\,\ol{Q_a}\,(C\,\ol{b}\,\ol{e_a}\,x)
%\Big)} \\
\mathsf{\to \forall (\ol{a : Set})(\ol{Q_a : a \to Set})(y : G\,\ol{a}) \to G^{\wedge}\,\ol{a}\,\ol{Q_a}\,y \to P\,\ol{a}\,\ol{Q_a}\,y}
\end{multline*}
As always, we now define a term $\mathsf{DIG}$ for the induction rule.
Define
\[
\mathsf{DIG\,P\,cc\,\ol{a}\,\ol{Q_a}\,(C\,\ol{b}\,\ol{e_a}\,x)\,(\ol{Q_b}, \ol{E_a}, L_F)
= cc\,\ol{a}\,\ol{b}\,\ol{Q_a}\,\ol{Q_b}\,\ol{e_a}\,x\,\ol{E_a}\,(p\,x\,L_F)}
\]
where
\begin{itemize}
\item $\mathsf{cc : CC\,P}$;
\item $\mathsf{C\,\ol{b}\,\ol{e_a}\,x : G\,\ol{a}}$,
i.e., $\mathsf{e_a : Equal\,a\,(K\,\ol{b})}$ for each $\mathsf{a}$,
and $\mathsf{x : F\,G\,\ol{b}}$;
\item $\mathsf{(\ol{Q_b}, \ol{E_a}, L_F) : G^{\wedge}\,\ol{a}\,\ol{Q_a} (C\,\ol{b}\,\ol{e_a}\,x)}$,
i.e.,
$\mathsf{Q_b : b \to Set}$ for each $\mathsf{b}$,
$\mathsf{E_a : Equal^{\wedge}\,a\,(K\,\ol{b})\,Q_a\,(K^{\wedge}\,\ol{b}\,\ol{Q_b})\,e_a}$ for each $\mathsf{a}$,
and $\mathsf{L_F : F^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,{\ol{Q_b}}\,x}$.
\end{itemize}
Finally, the morphism of predicates
\[
\mathsf{p : PredMap\,(F\,G\,\ol{b})\,(F^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}) (F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b})}
\]
is defined by structural induction on $\mathsf{F}$ as follows:
\begin{itemize}
\item Case $\mathsf{F = F_1 \times F_2}$ where $\mathsf{F_1}$ and $\mathsf{F_2}$ have the same type as $\mathsf{F}$.
We have that
\[
\mathsf{F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}
= Pair^{\wedge}(F_1\,G\,\ol{b})(F_2\,G\,\ol{b})(F_1^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}) (F_2^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b})}
\]
By inductive hypothesis, there exist morphisms of predicates
\begin{gather*}
\mathsf{p_1 : PredMap\,(F_1\,G\,\ol{b})\,((F_1)^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}) ((F_1)^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b})} \\
\mathsf{p_2 : PredMap\,(F_2\,G\,\ol{b})\,((F_2)^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}) ((F_2)^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b})}
\end{gather*}
Thus, we define $\mathsf{p (x_1, x_2) (L_1, L_2) = (p_1\,x_1\,L_1, p_2\,x_2\,L_2)}$ 
for 
$\mathsf{x_1 : F_1\,G\,\ol{b}}$,
$\mathsf{x_2 : F_2\,G\,\ol{b}}$,
$\mathsf{L_1 : F_1^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}\,x_1}$
and $\mathsf{L_2 : F_2^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}\,x_2}$.
%%%
\item Case $\mathsf{F = F_1 + F_2}$ where $\mathsf{F_1}$ and $\mathsf{F_2}$ have the same type as $\mathsf{F}$.
Analogous to case $\mathsf{F = F_1 \times F_2}$.
%%%
\item Case $\mathsf{F = F_1 \to F_2}$
where $\mathsf{F_1}$ and $\mathsf{F_2}$ have the same type as $\mathsf{F}$.
%where $\mathsf{F_1}$ does not contain the recursive variable,
%i.e., $\mathsf{F_a : Set^\beta \to Set}$,
%and $\mathsf{F_2}$ has the same type as $\mathsf{F}$.
We have that
\begin{gather*}
\mathsf{F^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}\,x = \forall (z : F_1\,G\,\ol{b}) \to F_2^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}\,(x\,y)} \\
%F_1^{\wedge}\,\ol{b}\,\ol{Q_b}\,x \to F_2^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}\,x} \\
\mathsf{F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,x = \forall (z : F_1\,G\,\ol{b}) \to F_2^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,(x\,y)}
%\mathsf{F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,x = F_1^{\wedge}\,\ol{b}\,\ol{Q_b}\,x \to F_2^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,x}
\end{gather*}
where $\mathsf{x : F\,G\,\ol{b} = F_1\,G\,\ol{b} \to F_2\,G\,\ol{b}}$.
By inductive hypothesis, there exist a morphism of predicates
\[
\mathsf{p_2 : PredMap\,(F_2\,G\,\ol{b}) (F_2^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}) (F_2^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b})}
\]
Thus, we define $\mathsf{p\,x\,L_F\,z = p_2 (x\,z) (L_F\,z)}$.
%{\color{blue} Revise this case!}
%Thus, we define $\mathsf{p\,x\,L_F\,L_1 = p_2\,(L_F\,L_1)}$
%for $\mathsf{L_1 : F_1^{\wedge}\,\ol{b}\,\ol{Q_b}\,x}$.
%Notice that $\mathsf{F_1}$ does not contain the recursive variable.
%That is a necessary restriction, as the proof relies on
%$\mathsf{F^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}\,x}$
%and $\mathsf{F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,x}$
%having the same domain.
%%%
\item Case $\mathsf{F\,G\,\ol{b} = G(\ol{F_a\,\ol{b}})}$
where none of the $\mathsf{F_a}$ contains the recursive variable,
i.e., $\mathsf{F_a : Set^\beta \to Set}$
for each $\mathsf{a}$.
Thus, $\mathsf{F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b} = P (\ol{F_a\,\ol{b}}) (\ol{F_a^{\wedge}\,\ol{b}\,\ol{Q_b}})}$.
So, $\mathsf{p}$ is defined as
\[
\mathsf{p = DIG\,P\,cc\,(\ol{F_a\,\ol{b}})\,(\ol{F_a^{\wedge}\,\ol{b}\,\ol{Q_b}})}
\]
%for $\mathsf{L_F : F^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}\,x}$.
Note that the fact that the type constructors $\mathsf{F_a}$ do not contain the recursive variable
means that $\mathsf{G}$ does not feature nesting.
As explained and exemplified in Section~\ref{sec:GADT-nested},
that assumption is required to make induction work.
%%%
\item Case $\mathsf{F\,G\,\ol{b} = H\,\ol{b}}$
where $\mathsf{H}$ is a type constructor not containing the recursive variable,
i.e., $\mathsf{H : Set^\beta \to Set}$.
In such case, $\mathsf{p : PredMap (H\,\ol{b}) (H^{\wedge}\,\ol{b}\,\ol{Q_b}) (H^{\wedge}\,\ol{b}\,\ol{Q_b})}$
is just the identity morphism of predicates.
%%%
\item Case $\mathsf{F\,G\,\ol{b} = H (\ol{F_c\,G\,\ol{b}})}$
where $\mathsf{H}$ is a type constructor not containing the recursive variable,
i.e., $\mathsf{H : Set^\gamma \to Set}$,
and $\mathsf{F_c}$ has the same type as $\mathsf{F}$, for every $\mathsf{c = 1 \dots \gamma}$.
Moreover, we assume that $\mathsf{H}$ has an associated predicate-lifting function,
\[
\mathsf{H^{\wedge} : \forall (\ol{c : Set}) \to (\ol{c \to Set}) \to H\,\ol{c} \to Set}
\]
and that this predicate-lifting function has a map function $\mathsf{HLMap}$ of type
\[
\mathsf{\forall (\ol{c : Set}) (\ol{Q_c\;Q_c' : c \to Set}) \to PredMap\,\ol{c}\,\ol{Q_c}\,\ol{Q_c'}
\to PredMap\,(H\,\ol{c})\,(H^{\wedge}\,\ol{c}\,\ol{Q_c})\,(H^{\wedge}\,\ol{c}\,\ol{Q_c'})}
\]
That means that $\mathsf{H}$ cannot be a GADT,
as GADTs do not have functorial semantics~\cite{HaskellPaper}
and we would incur again in the same issue encountered in Section~\ref{sec:GADT-nested},
but it can be an ADT or even a nested type~\cite{jp19,jgj21}.
Thus,
\[
\mathsf{F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b} = H^{\wedge} (\ol{F_c\,G\,\ol{b}}) (\ol{F_c^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}})}
\]
By induction hypothesis, there is a morphism of predicates
\[
\mathsf{p_c : PredMap\,(F_c\,G\,\ol{b}) (F_c^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}) (F_c^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b})}
\]
for every $\mathsf{c = 1 \dots \gamma}$.
So, $\mathsf{p}$ is defined as
\[
\mathsf{p
= HLMap\,(\ol{F_c\,G\,\ol{b}}) (\ol{F_c^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}}) (\ol{F_c^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}})\,\ol{p_c}}
\]

\end{itemize}
Notice that, by proceeding by structural induction as above,
we have implicitly defined a grammar for GADTs admitting an induction rule.
In particular, we allow $\mathsf{F}$ to feature sums, products, arrow types and (limited) type application.



\section{Applications}

Lambda normal form example.

%Still don't know which applications we might have


\section{Primitive representation for GADTs}

No induction with primitive representation (reference Haskell Symposium paper and~\cite{jp19} and paper Patricia Neil Clement 2010)



\section{Conclusion}

Mention Patricia/Neil2008 paper



\section{TODO}

\begin{itemize}
\item reference (correctly) Haskell Symposium paper
\end{itemize}

%%% Added to bibliography:

%@inproceedings{jp20,
%  author = {P. Johann and A. Polonsky},
%  title = {Deep Induction: Induction Rules for (Truly) Nested Types},
%  year = {2020},
%  booktitle = {Foundations of Software Science and Computation Structures},
%  pages = {339-358}
%}
%
%@inproceedings{jgj21,
%  author = {P. Johann and E. Ghiorzi and D. Jeffries},
%  title = {Parametricity for Primitive Nested Types},
%  year = {2021},
%  booktitle = {Foundations of Software Science and Computation Structures},
%  pages = {324-343}
%}
%
%@inproceedings{bm98,
% title={Nested datatypes},
% author={R. Bird, and L. Meertens},
% booktitle={Mathematics of Program Construction},
% year={1998}
% pages = {52â€“67}
%}


\bibliography{gadt-story-references}

\end{document}
