\documentclass[9pt]{entcs}
\usepackage{entcsmacro}
\usepackage{graphicx}
\sloppy
% The following is enclosed to allow easy detection of differences in
% ascii coding.
% Upper-case    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
% Lower-case    a b c d e f g h i j k l m n o p q r s t u v w x y z
% Digits        0 1 2 3 4 5 6 7 8 9
% Exclamation   !           Double quote "          Hash (number) #
% Dollar        $           Percent      %          Ampersand     &
% Acute accent  '           Left paren   (          Right paren   )
% Asterisk      *           Plus         +          Comma         ,
% Minus         -           Point        .          Solidus       /
% Colon         :           Semicolon    ;          Less than     <
% Equals        =3D           Greater than >          Question mark ?
% At            @           Left bracket [          Backslash     \
% Right bracket ]           Circumflex   ^          Underscore    _
% Grave accent  `           Left brace   {          Vertical bar  |
% Right brace   }           Tilde        ~

\bibliographystyle{entcs}

\def\lastname{Johann, Ghiorzi, and Jeffries}

\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage{ccicons}
\usepackage{verbatim}


\usepackage{amscd}
\usepackage{MnSymbol}
\usepackage{xcolor}

\usepackage{bbold}
\usepackage{url}
\usepackage{upgreek}
\usepackage{stmaryrd}

\usepackage{lipsum}
\usepackage{tikz-cd}
\usetikzlibrary{cd}
\usetikzlibrary{calc}
\usetikzlibrary{arrows}

\usepackage{bussproofs}
\EnableBpAbbreviations

\newcommand{\new}[1]{{\color{blue} {#1}}}

\newcommand{\set}{\mathtt{Set}}


\input{macros}




\begin{document}
\begin{frontmatter}
  \title{(Deep) Induction for GADTs}

  \author{Patricia Johann~~~~}%\thanksref{JohannEmail}}
  \author{Enrico Ghiorzi~~~~}%\thanksref{GhiorziEmail}}
  \author{Daniel Jeffries}%\thanksref{JeffriesEmail}}
%  \thanks[JohannEmail]{Email: \href{mailto:johannp@appstate.edu} {\texttt{\normalshape johannp@appstate.edu}}}
%  \thanks[GhiorziEmail]{Email: \href{mailto:ghiorzie@appstate.edu} {\texttt{\normalshape ghiorzie@appstate.edu}}}
%  \thanks[JeffriesEmail]{Email: \href{mailto:jeffriesd@appstate.edu} {\texttt{\normalshape jeffriesd@appstate.edu}}}
  \address{$\mathtt{\{johannp,ghiorzie,jeffriesd\}@appstate.edu}$\\Department of Computer Science, Appalachian State University}

\begin{abstract} 
  Abstract goes here.
\end{abstract}

\begin{keyword}
  Please list keywords from your paper here, separated by commas.
\end{keyword}

\end{frontmatter}

\begin{itemize}
\item Weird to code in Agda if we're talking about induction rules for
  Coq? 
\item Agda style conventions
\end{itemize}
  
\section{Introduction}\label{sec:intro}

Induction is one of the most important techniques available for
working with advanced data types, so it is both inevitable and
unsurprising that it plays an essential role in modern proof
assistants. In the proof assistant Coq~\cite{coq20}, for example,
functions and predicates over advanced types are defined inductively,
and almost all non-trivial proofs of their properties are either
proved by induction outright or rely on lemmas that are. Every time a
new inductive data type is declared in Coq, an induction rule is
automatically generated for it.

The data types handled by Coq are (possibly mutually inductive)
polynomial ADTs, and the induction rules automatically generated for
them are the expected ones for standard structural induction. It has
long been understood, however, that these rules are too weak to be
genuinely useful for so-called {\em deep ADTs}~\cite{jp20}, i.e., ADTs
that are (possibly mutually inductively) defined in terms of (other)
such ADTs.\footnote{Such data types are called nested inductive types
  by Chlipala~\cite{chl}, reflecting the fact that ``inductive type''
  means ``ADT''~in~Coq.} Consider, for example, the following type of
rose trees, here coded in Agda and defined in terms of the standard
type of lists:
\[\begin{array}{l}
\mathsf{data\, Rose\, : Set \to Set\,where}\\
\mathsf{\;\;\;\;\;\;\;\;rEmpty\, :\, Rose\,A}\\
\mathsf{\;\;\;\;\;\;\;\;rNode\,\,\,\, :\, A \to List\,(Rose\,A) \to Rose\,A} 
\end{array}\]
\noindent
The induction rule Coq automatically generates for rose trees is
\[\begin{array}{l}
\mathsf{\forall\, (a : \set)\,(P : Rose\,a \to \set) \to P\,REmpty \to}\\
\mathsf{\hspace*{0.15in}
 (\forall\, (x : a)\,(ts :
  List\,(Rose\,a)) \to P\,(RNode\,x\,ts)) \to 
  \forall \,(x : Rose\,a) \to P\,x}
\end{array}\]
\noindent
Unfortunately, this is neither the induction rule we intuitively
expect, nor is it expressive enough to prove even basic properties of
rose trees that ought to be amenable to inductive proof. What is
needed here is an enhanced notion of induction that, when specialized
to rose trees, will propagate the predicate $\mathsf{P}$ through the
outer list structure and to the rose trees sitting inside
$\mathsf{RNode}$'s list argument. More generally, this enhanced notion
of induction should traverse {\em all} of the structure present in a
data type, propagating suitable predicates to {\em all} of the data
contained in the structure. With data types becoming ever more
advanced, and with deeply structured such types becoming ever more
%increasingly
ubiquitous in formalizations, it is critically important that proof
assistants
%like Coq, Agda, and Lean 
be able to automatically generate genuinely useful induction
principles for data types that go well beyond traditional ADTs. Such
data types include (truly) nested types~\cite{bm98}\footnote{A truly
  nested type is a nested type that is defined over itself.},
generalized algebraic data types
(GADTs)~\cite{ch03,pvww06,sp04,xcc03}, more richly indexed
families~\cite{ch88}, and deep variants of all of these.

{\em Deep induction}~\cite{jp20} is a generalization of structural
induction that fits this bill exactly. Whereas structural induction
rules induct over only the top-level structure of data, leaving any
data internal to the top-level structure untouched, deep induction
rules induct over {\em all} of the structured data present. The key
idea is to parameterize induction rules not just over a predicate over
the top-level data type being considered, but also over additional
custom predicates on the types of primitive data they contain. These
custom predicates are then lifted to predicates on any internal
structures containing these data, and the resulting predicates on
these internal structures are lifted to predicates on any internal
structures containing structures at the previous level, and so on,
until the internal structures at all levels of the data type
definition, including the top level, have been so
processed. Satisfaction of a predicate by the data at one level of a
structure is then conditioned upon satisfaction of the appropriate
predicates by {\em all} of the data at the preceding level.

Deep induction was shown in~\cite{jp20} to be the form of induction
most appropriate to nested types (including ADTs) that are defined
over, or mutually recursively with, other such types (including,
possibly, themselves). Deep induction delivers the following genuinely
useful induction rule for rose trees:

\[\begin{array}{l}
\mathsf{\forall \,(a : \set)\,(P : Rose\,a \to \set)\,(Q : a \to \set)
  \to P\,REmpty \to}\\ 
\mathsf{\hspace*{0.15in}(\forall \,(x : a)\, (ts :
  List\,(Rose\,a))\to Q\,x \to List^\land\,P\,ts \to P\,(RNode\,x\,ts)) \to}\\
\mathsf{\hspace*{0.15in}\forall \,(x :
  Rose\,a) \to Rose^\land\,Q\, x \to P\,x} 
\end{array}\]

\noindent
%Here, $\mathsf{List^\land}$ lifts its predicate argument $\mathsf{P}$
%on data of type $\mathsf{Rose\,a}$ to a predicate on data of type
%$\mathsf{List\,(Rose\,a)}$ asserting that $\mathsf{P}$ holds for every
%element of its argument list, and similarly for the lifting
%$\mathsf{Rose^\land}$ and the predicate $\mathsf{Q}$.
Here, $\mathsf{List^\land}$ (resp., $\mathsf{Rose^\land}$) lifts its
predicate argument $\mathsf{P}$ (resp., $\mathsf{Q}$) on data of type
$\mathsf{Rose\,a}$ (resp., $\mathsf{a}$) to a predicate on data of
type $\mathsf{List\,(Rose\,a)}$ (resp., $\mathsf{Rose\,a}$) asserting
that $\mathsf{P}$ (resp., $\mathsf{Q}$) holds for every element of its
list (resp., rose tree) argument.\footnote{Predicate liftings such as
  $\mathsf{List^\land}$ and $\mathsf{Rose^\land}$ can either be
  supplied as primitives or generated automatically from their
  associated data type definitions as described in
  Section~\ref{sec:ADTs-and-nesteds} below. The predicate lifting for
  a container type like $\mathsf{List\,t}$ or $\mathsf{Rose\,t}$
  simply traverses containers of that type and applies its predicate
  argument pointwise to the constituent data of type $\mathsf{t}$.}
Deep induction was also shown in~\cite{jp20} to
% be the missing piece making it possible to
%be the theretofore missing component needed to
% be the essential ingredient making it possible to
deliver the first-ever induction rules --- structural or otherwise ---
for the $\mathsf{Bush}$ data type~\cite{bm98} and other truly nested
types. Deep induction for ADTs and nested types is reviewed in
Section~\ref{sec:ADTs-and-nesteds} below.

This paper shows how to extend deep induction to proper GADTs, i.e.,
to GADTs that are not simply nested types (and thus are not ADTs).  A
constructor for such a GADT $\mathsf{G}$ may, like a constructor for a
nested type, take as arguments data whose types involve instances of
$\mathsf{G}$ other than the one being defined --- including instances
that involve $\mathsf{G}$ itself. But if $\mathsf{G}$ is a proper GADT
then at least one of its constructors will also have such a structured
instance of $\mathsf{G}$ --- albeit one not involving $\mathsf{G}$
itself --- as its codomain.
%But while the types of the arguments to a GADT's constructor can
%include instances of $\mathsf{G}$ that themselves involve
%$\mathsf{G}$, its return type cannot.
For example, the constructor $\mathsf{SPair}$ for the GADT
{\color{red} Perhaps Lam data type illustrates better? Perhaps also
  shows non-inbabitation?}
\begin{equation}\label{eq:eq-seq}
\begin{array}{l}
\mathsf{data\, Seq\,(a : Set) : Set\,where}\\
\mathsf{\;\;\;\;\;\;\;\;SConst :\, a \to Seq\,a}\\
\mathsf{\;\;\;\;\;\;\;\;SPair\,\, :\, Seq \,a \to Seq\,b \to
  Seq\,(a \times b)}
\end{array}
\end{equation}
\noindent
of sequences only constructs sequences of pairs, rather than sequences
of arbitrary type, as does $\mathsf{SConst}$. If all of the
constructors for a GADT $\mathsf{G}$ return structured instances of
$\mathsf{G}$, then some of $\mathsf{G}$'s instances might not be
inhabited. GADTs therefore have two distinct, but equally natural,
semantics: a functorial semantics interpreting them as left Kan
extensions~\cite{mac71}, and a parametric semantics interpreting them
as their Church encodings~\cite{}. As explained in~\cite{jgj21}, a key
difference in the two semantics is that the former views GADTs as
their {\em functorial completions}~\cite{jp19}, and thus as containing
more data than just those expressible in syntax. By contrast, the
latter views them as what might be called {\em syntax-only}
GADTs. Happily, these two views of GADTs coincide for those that are
ADTs or other nested types. However, both they and their attendant
properties differ greatly for proper GADTs. In fact, the views
deriving from the functorial semantics and that parametric semantics
for proper GADTs are sufficiently distinct that, by contrast with the
situation for ADTs and other nested
types~\cite{bfss90,gjfor15,jgj21f}, it is not actually possible
to define a functorial parametric semantics for them~\cite{jgj21}.

This observation seems, at first, to be a death knell for the prospect
of extending deep induction to GADTs. Indeed, since induction can be
seen as unary parametricity, we quickly realize that GADTs viewed as
their functorial completions cannot possibly support induction rules.
This makes sense intuitively: induction is a syntactic proof
technique, so of course it cannot be used to prove properties of those
elements of a GADT's functorial completion that are not expressible in
syntax. All is not lost, however. As we show below, the Church
encoding interpretation's syntax-only view does support induction
rules --- including deep induction rules --- for GADTs. Perhaps
surprisingly, ours are the first-ever induction rules --- deep or
otherwise --- for a general class of proper GADTs. But this paper
actually delivers more: it gives a general framework for deriving deep
induction rules for a general class of GADTs directly from their
syntax. This framework can serve as a basis for extending modern proof
assistants' automatic generation of structural induction rules for
ADTs to automatic generation of deep induction rules for GADTs. As
for ADTs and other nested types, the structural induction rule for any
GADT can be recovered from its deep induction rule simply by taking
the custom predicates in its deep induction rule to be constantly
$\mathsf{True}$-valued predicates.

Deep induction rules for GADTs cannot, however, be derived by somehow
extending the techniques of~\cite{jp20} to syntax-only GADTs. Indeed,
the derivation of induction rules given there makes crucial use of the
functoriality of data types' interpretations from~\cite{jp19}, and
that is precisely what the interpretation of GADTs as their Church
encodings fails to deliver. Instead, we first give the (deep)
induction rule and a predicate lifting styled after those
of~\cite{jp20} for the simplest and most important GADT, namely the
$\mathsf{Equality}$ GADT. We then treat any other GADT by writing it
as its so-called {\em Henry Ford
  encoding}~~\cite{ch03,hin03,mcb99,sjsv09,sp04} and using the
predicate liftings for $\mathsf{Equality}$ and any other constituent
data types to appropriately thread the custom predicates through the
structures of the GADT. {\color{red} Significantly, since we are
  treating GADTs as syntax-only, rather than functorial, we cannot
  handle truly nested GADTs like we handled truly nested types, but
  this is not much of a restriction, since I've never seen GADTs
  defined over themselves in applications.} This process yields, in
particular, the following deep induction rule for $\mathsf{Seq}$:
{\color{red} Order of arguments?}
\begin{multline*}
\mathsf{\forall (P : \forall (a : Set) \to (a \to Set) \to Seq\,a \to
  Set)} \mathsf{\to CConst\,P \to CSPair\,P} \\ \mathsf{\to \forall (a
  : Set)(Q_a : a \to Set)(s_a : Seq\,a) \to Seq^{\wedge}\,a\,Q_a\,s_a
  \to P\,a\,Q_a\,s_a}
\end{multline*}
where $\mathsf{CConst}$ is the function {\color{red} Why $\lambda$?}
\[\mathsf{\lambda (P : \forall (a : Set) \to (a \to Set) \to Seq\,a \to Set)} 
\mathsf{\to \forall (a : Set) (Q_a : a \to Set) (x : a) \to Q_a\,x \to
  P\,a\,Q_a\,(Const\,x)}
\]
associated with the $\mathsf{Const}$ constructor and $\mathsf{CSPair}$
is the function
\begin{multline*}
\mathsf{\lambda (P : \forall (a : Set) \to (a \to Set) \to Seq\,a \to Set)}
\mathsf{\to \forall (a\,b\,c : Set)
	(Q_a : a \to Set) (Q_b : b \to Set) (Q_c : c \to Set)} \\
	\mathsf{(s_b : Seq\,b) (s_c : Seq\,c) (e : Equal\,a\,(b \times c))
	\to Equal^{\wedge} a\, (b \times c)\, Q_a\, (Pair^{\wedge}\,b\,c\,Q_b\,Q_c)\, e} \\
	\mathsf{\to P\,b\,Q_b\,s_b \to P\,c\,Q_c\,s_c
	\to P a Q_a ( SPair\,b\,c\,e\,s_b\,s_c )}
\end{multline*}
associated with the $\mathsf{SPair}$ constructor,

All of the deep induction rules appearing in this paper have been
derived using our general framework. Our Agda code implementing them
is available at~\cite{web-page}.

\subsection{Related Work}

Ullrich's plugin?

Tassi's Elpi

Peter Selinger and  Fu Peng

\section{Deep induction for ADTs and nested types}\label{sec:ADTs-and-nesteds}

\begin{comment}
\subsection{Syntax of ADTs and nested types}\label{ssec:syntax-adts}

\emph{(Polynomial) algebraic data types} (ADTs), both built-in and user-defined,
have long been at the core of functional languages such as Haskell, ML, Agda, Epigram, and Idris.
ADTs are used extensively in functional programming to structure computations,
to express invariants of the data over which computations are defined,
and to ensure the type safety of programs specifying those computations.
ADTs include unindexed types, such as the type of natural numbers,
and types indexed over other types, such as the quintessential example of an ADT,
the type of lists (here coded in Agda)
\begin{equation}\label{eq:list}
\begin{array}{l}
\mathsf{data\ List : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;nil\,\,\,\,\,\, :\, List\,A}\\
\mathsf{\;\;\;\;\;\;\;cons\, :\, A \to List\,A \to List\,A} 
\end{array}
\end{equation}
Notice that all occurrences of $\mathsf{List}$ in the above encoding
are instantiated at the same index $\mathsf{A}$.  Thus, the instances
of $\mathsf{List}$ at various indices are defined independently from
one another.  That is a defining feature of ADTs: an ADT defines a
\emph{family of inductive types}, one for each index type.

Over time, there has been a notable trend toward data types whose
non-regular indexing can capture invariants and other sophisticated
properties that can be used for program verification and other
applications.  A simple example of such a type is given by Bird and
Meertens’~\cite{bm98} prototypical \emph{nested type}
\begin{equation}\label{eq:ptree}
\begin{array}{l}
\mathsf{data\ PTree : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;pLeaf\,\,\, :\, A \to PTree\,A}\\
\mathsf{\;\;\;\;\;\;\;pNode\, :\, PTree\,(A \times A) \to PTree\,A} 
\end{array}
\end{equation}
of perfect trees, which can be thought of as constraining lists to
have lengths that are powers of 2.  In the above code, the constructor
$\mathsf{PNode}$ uses data of type $\mathsf{PNode\,(A \times A)}$ to
construct data of type $\mathsf{PNode\,A}$.  Thus, it is clear that
the instantiations of $\mathsf{PNode}$ at various indices cannot be
defined independently, so that the entire family of types must
actually be defined at once.  A nested type thus defines not a family
of inductive types, but rather an \emph{inductive family of types}.

Nested types include simple nested types, like perfect trees,
none of whose recursive occurrences occur below another type constructor,
and \emph{truly} nested types, such as the nested type
\begin{equation}\label{eq:bush}
\begin{array}{l}
\mathsf{data\ Bush : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;bNil\,\,\,\,\,\, :\, Bush\,A}\\
\mathsf{\;\;\;\;\;\;bCons\, :\, A \to Bush\,(Bush\,A) \to Bush\,A} 
\end{array}
\end{equation}
of bushes, whose recursive occurrences appear below their own type constructors.
Note that, while the constructors of a nested type can contain occurrences of the type instantiated at any index,
the return types of its constructors still have to be the same type instance of the type being defined.
In other words, all constructors of $\mathsf{PTree\,A}$ have to return an element of type $\mathsf{PTree\,A}$,
and all constructors of $\mathsf{Bush\,A}$ have to return an element of type $\mathsf{Bush\,A}$.
%the return types of the constructors are still required to be instantiated at the same variable $\mathsf{a}$.}
%As previously noted, the return types of the constructors of a nested
%type have to be the same type instance of the type being defined.
\end{comment}

\subsection{Induction principles for ADTs and nested
  types}\label{ssec:induction-nested} 

A structural induction principle for a data type allows us to prove
that if a predicate holds for every element inductively produced by
the data type's constructors then it holds for every element of the
data type.  In this paper, we are interested in induction principles
for proof-relevant predicates.  A proof-relevant predicate on a type
$\mathsf{A : Set}$ is a function $\mathsf{P\,:\,A \to Set}$ mapping
each $\mathsf{x : A}$ to the set of proofs that $\mathsf{P\,x}$ holds.
For example, the induction principle for the standard data type
\begin{equation*}\label{eq:list}
\begin{array}{l}
\mathsf{data\ List : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;nil\,\,\,\,\,\, :\, List\,A}\\
\mathsf{\;\;\;\;\;\;\;cons\, :\, A \to List\,A \to List\,A} 
\end{array}
\end{equation*}
of lists is
\begin{equation*}
\mathsf{
\forall (A : Set) (P : List\,A \to Set)
\to P\,nil
\to \big( \forall (a : A) (as: List\,A)
\to P\,as
\to P\,(cons\,a\,as)\big)
\to \forall (as : List\,A)
\to P\, as
}
\end{equation*}
As mentioned above, the data inside a structure of type
$\mathsf{List}$ is treated monolithically (i.e., ignored) by this
structural induction rule.
%Indeed, the structural induction rule for a data type inducts
%over only the top-level structures of data types, leaving any data
%internal to the top-level structure untouched.  Since this kind of
%induction principle is only concerned with the structure of the type,
%and unconcerned with the contained data, we will then refer to it as
%\emph{structural induction}.
By contrast, the deep induction rule for lists is parameterized over a
custom predicate $\mathsf{Q}$ on $\mathsf{A}$ as described in the
introduction. For $\mathsf{List^\wedge}$ as described in the
introduction, it is
\[
\begin{array}{l}
\mathsf{\forall (A : Set) (P : List\, A \to Set) (Q : A \to Set)
\to P\,Nil \to \big( \forall (a : A) (as: List\,A) \to Q\,a \to P\,as
\to P\,(Cons\,a\,as)\big)} \\ 
\quad\mathsf{\to \forall (as : List\,A) \to List^{\wedge}\,A\,Q\,as
  \to P\,as } 
\end{array}
\]

Structural induction can also be extended to nested types, such as the
following type of perfect trees~\cite{bm98}:
\begin{equation*}\label{eq:ptree}
\begin{array}{l}
\mathsf{data\ PTree : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;pLeaf\,\,\, :\, A \to PTree\,A}\\
\mathsf{\;\;\;\;\;\;\;pNode\, :\, PTree\,(A \times A) \to PTree\,A} 
\end{array}
\end{equation*}
Perfect trees can be thought of as lists constrained to have lengths
that are powers of 2. In the above code, the constructor
$\mathsf{pNode}$ uses data of type $\mathsf{PTree\,(A \times A)}$ to
construct data of type $\mathsf{PTree\,A}$. Thus, it is clear that the
instances of $\mathsf{PTree}$ at various indices cannot be defined
independently, and that the entire inductive family of types must
therefore be defined at once. This intertwinedness of the instances
of nested types is reflected in their structural induction rules,
which must necessarily involve polymorphic predicates, rather than the
monomorphic predicates appearing in structural induction rules for
ADTs. The structural induction rule for perfect trees, for example, is
\[\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to PTree\, A \to Set)
\to \big( \forall (A : Set) (a : A) \to P\,A\,(pLeaf\, a) \big)} \\
\quad\mathsf{\to \big( \forall (A : Set) (tt : PTree\,(A \times A))
  \to P\,(A \times A)\,t \to P\,a\,(pNode\,tt)\big) \to \forall (A :
  Set) (t : PTree\,A) \to P\,A\,t } 
\end{array}\]
The deep induction rule for perfect trees similarly uses polymorphic
predicates but otherwise follows the now-familiar pattern:
\[\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to (A \to Set) \to PTree\,A
  \to Set) \to \big( \forall (A : Set) (Q : A \to Set) (a : A) \to
  Q\,a \to P\,A\,Q\,(PLeaf\, a) \big)} \\ \quad \mathsf{\to \big(
  \forall (A : Set) (Q : A \to Set) (tt : PTree\,(A \times A)) \to
  P\,(A \times A)\,(Pair^{\wedge}\,A\,A\,Q\,Q)\,tt \to
  P\,A\,Q\,(PNode\,tt)\big)} \\ \quad \mathsf{\to \forall (A : Set) (Q
  : A \to Set) (t : PTree\,A) \to PTree^{\wedge}\,A\,Q\,t \to
  P\,A\,Q\,t }
\end{array}\]
Here, $\mathsf{Pair^{\wedge} : \forall (A\; B: Set) \to (A \to Set)
  \to (B \to Set) \to A \times B \to Set}$ lifts predicates
$\mathsf{Q_A}$ on data of type $\mathsf{A}$ and $\mathsf{Q_B}$ on data
of type $\mathsf{B}$ to a predicate on pairs of type $\mathsf{A \times
  B}$ in such a way that $\mathsf{Pair^{\wedge}\,A\,B\,Q_A\,Q_B\,(a,b)
  = Q_A\,a \times Q_B\,b}$. Similarly, $\mathsf{PTree^{\wedge} :
  \forall (A : Set) \to (A \to Set) \to PTree\,A \to Set}$ lifts a
predicate $\mathsf{Q}$ on data of type $\mathsf{A}$ to a predicate on
data of type $\mathsf{PTree\,A}$ asserting that $\mathsf{Q}$ holds for
every element of type $\mathsf{A}$ contained in its perfect tree
argument.

It is not possible to extend structural induction to {\em truly}
nested types, i.e., to nested types whose recursive occurrences appear
below their own type constructors. Indeed, defining any induction rule
for such a type requires that we can lift the predicate argument to
that rule over the type itself. The observation that any induction
rule for a truly nested type would thus necessarily have to be a deep
induction rule was, in fact, the original motivation for the
introduction of deep induction in~\cite{jp20}.

The quintessential example of a truly nested type is that of
bushes~\cite{bm98}:
\begin{equation*}\label{eq:bush}
\begin{array}{l}
\mathsf{data\ Bush : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;bNil\,\,\,\,\,\, :\, Bush\,A}\\
\mathsf{\;\;\;\;\;\;bCons\, :\, A \to Bush\,(Bush\,A) \to Bush\,A} 
\end{array}
\end{equation*}
Its (deep) induction rule is
\[\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to (A \to Set) \to Bush\, A \to Set)
\to \big( \forall (A : Set) \to P\,A\,bNil \big)} \\
\quad\mathsf{\to \big( \forall (A : Set) (Q : A \to Set) (a : A) (bb :
  Bush\,(Bush\,A)) \to Q\,a \to
  P\,(Bush\,A)\,(Bush^{\wedge}\,A\,Q)\,bb \to P\,A\,Q\,(bCons\,a\,bb)
  \big)} \\ 
\quad\mathsf{\to \forall (A : Set) (Q : A \to Set) (b : Bush\,A) \to
  Bush^{\wedge}\,A\,Q\,b \to P\,A\,Q\,b } 
\end{array}\]
where $\mathsf{Bush^{\wedge} : \forall (A : Set) \to (A \to Set) \to
  Bush\,A \to Set}$ is the folllowing lifting of a predicate
$\mathsf{Q}$ on data of type $\mathsf{A}$ to a predicate on data of
type $\mathsf{Bush\,A}$ asserting that $\mathsf{Q}$ holds for every
element of type $\mathsf{A}$ contained in its argument bush:
\begin{align*}
\mathsf{Bush^{\wedge}\,A\,Q\,Bnil} &= \mathsf{\top} \\
\mathsf{Bush^{\wedge}\,A\,Q\,(Bcons\,a\,bb)} &= \mathsf{Q\,a \times
  Bush^{\wedge}\,(Bush\,A)\,(Bush^{\wedge}\,A\,Q)\,bb}
\end{align*}





It is worth noting that for those nested types admitting both deep
induction and structural induction, the former generalizes the latter.
Indeed, the structural induction rule for a nested type is recoverable
from its deep induction rule by taking the custom predicates on their
data of primitive types to be constantly $\mathsf{True}$-valued
predicates. Such an instantiation ensures that a deep induction rule
only inspects the top-level structure of its argument data, rather
than the contents of that structur. {\color{red} A concrete example of
  such a derivation is given in Section~\ref{sec:ind-equal}.}

\section{GADTs and Their Encodings}

While a constructor of a nested type can take {\em as arguments} data
whose types involve occurrences of the type instantiated at indices
other than the one being defined, its {\em return type} still has to
be at the same instance as the one being defined. For example, all
constructors of $\mathsf{PTree\,A}$ have to return an element of type
$\mathsf{PTree\,A}$. By contrast, \emph{generalized algebraic data
  types} (GADTs)~\cite{ch03,sp04,xcc03} relax this restriction by
allowing their constructors both to take as arguments \emph{and return
  as results} data whose types involve type instances of the GADT
other than the one being defined.
%Applications of GADTs include generic programming, modeling
%programming languages via higher-order abstract syntax, maintaining
%invariants in data structures, and expressing constraints in embedded
%domain-specific languages. GADTs have also been used, e.g., to
%implement tagless interpreters~\cite{pl04,pr06,pvww06}, to improve
%memory performance~\cite{min15}, and to design APIs~\cite{pen20}.

GADTs are used in precisely those situations in which different
behaviors at different instances of a data type are desired. This is
achieved by allowing the programmer to give the type signatures of the
GADT's data constructors independently, and then using pattern
matching to force the desired type refinement. For example, the
equality GADT
\begin{equation}\label{eq:equal}
\begin{array}{l}
\mathsf{data\ Equal : Set \to Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;\;\;\;\,eRefl :\, Equal\,A\,A}
\end{array}
\end{equation}
is parametrized by two type indices, but it is only possible to
construct data elements of type $\mathsf{Equal\,a\,b}$ if $\mathsf{a}$
and $\mathsf{b}$ are instantiated at the same type. In this case
$\mathsf{Equal\,a\,b}$ contains a single data element; it contains no
data elements otherwise.

The importance of the equality GADT lies in the fact that we can
understand other GADTs in terms of it. For example, the GADT of
sequences from the introduction
%following GADT of sequences
%\begin{equation}\label{eq:eq-seq}
%\begin{array}{l}
%\mathsf{data\ Seq : Set \to Set\ where}\\
%\mathsf{\;\;\;\;\;\;\;\;sConst :\, A \to Seq\,A}\\
%\mathsf{\;\;\;\;\;\;\;\;sPair\,\, :\, Seq\,A \to Seq\,B \to Seq\,(A \times B)}
%\end{array}
%\end{equation}
comprises constant sequences of data of any type $\mathsf{A}$ and
sequences obtained by pairing the data in two already existing
sequences. This GADT can be understood in terms of the equality GADT
by rewriting it as its Henry Ford
encoding~\cite{ch03,hin03,mcb99,sjsv09,sp04} as follows:
\begin{equation}\label{eq:eq_seq}
\begin{array}{l}
\mathsf{data\ Seq : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;sConst :\, A \to Seq\,A}\\ 
\mathsf{\;\;\;\;\;\;\;\;sPair\,\, :\, \forall (B\,C : Set) \to
  Equal\,A\,(B \times C) \to Seq\,B \to Seq\,C \to Seq\,A}\\ 
\end{array}
\end{equation}
Here, the requirement that the $\mathsf{sPair}$ constructor produces
an instance of $\mathsf{Seq}$ at a product type has been replaced with
the requirement that the instance of $\mathsf{Seq}$ returned by
$\mathsf{sPair}$ is \emph{equal} to some product type. This encoding
is particularly convenient when viewing GADTs as their Church
encodings~\cite{atk12,vw10}.

\vspace*{0.1in}

An example of a {\color{red} deep GADT} is given by an encoding of
simply typed lambda terms. More robust variations on the simply typed
lambda calculus are, of course, possible. But since the particular
calculus we have chosen is rich enough to illustrate all of the
essential aspects of deep induction for GADTs, we keep the types and
terms to a minimum here for the purposes of exposition.

Types are either booleans, arrow types, or list types. We represent
types via the following GADT: {\color{red} Wrong naming conventions
  throughout this example!}
\begin{equation}\label{eq:eq_ltype}
\begin{array}{l}
\mathsf{data\ LType : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;tBool :\, \forall (B : Set) \to LType\,Bool}\\
\mathsf{\;\;\;\;\;\;\;\;tArr\,\,\, :\, \forall (B\,C : Set) \to
  LType\,B \to LType\,C \to LType\,(B \to C)}\\
\mathsf{\;\;\;\;\;\;\;\;tList\,\, :\, \forall (B : Set)
  \to LType\,B \to LType\,(List\,B)}
\end{array}
\end{equation}
Terms are either variables, abstractions, applications, or lists of
such terms. We represent terms via 
\begin{equation}\label{eq:eq_lterm}
\begin{array}{l}
\mathsf{data\ LTerm : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;var\,\,\,\,\,\,\,:\, String \to LType\,A \to
  LTerm\,A} \\  
\mathsf{\;\;\;\;\;\;\;\;abs\,\,\,\,\,\, :\, \forall (B\,C : Set) \to
  String \to LType\,B \to LTerm\,C \to
  LTerm\,(B \to C)}\\ 
  \mathsf{\;\;\;\;\;\;\;\;app\,\,\,\,\, :\, \forall (B : Set) \to
    LTerm (B \to A) \to LTerm\,B \to LTerm\,A} \\ 
  \mathsf{\;\;\;\;\;\;\;\;listC\,\,\, :\, \forall (B : Set) \to
    List\,(LTerm\,B) \to LTerm\,(List \,B)} 
\end{array}
\end{equation}
The type parameter for $\mathsf{LTerm}$ tracks the types of simply
typed lambda calculus terms.  For example, the type
$\mathsf{LTerm\,A}$ contains lambda terms of type $\mathsf{A}$.
Variables are tagged with their types by the constructors
$\mathsf{var}$ and $\mathsf{abs}$. There, $\mathsf{LType}$ ensures
that variables can only be tagged with legal types, e.g.,
$\mathsf{Bool}$, $\mathsf{Bool \to Bool}$, $\mathsf{List\, (Bool \to
  Bool)}$, etc. The presence of $\mathsf{LType}$ in these constructors
thus guarantees that all lambda terms produced by $\mathsf{var}$,
$\mathsf{abs}$, $\mathsf{app}$, and $\mathsf{listC}$ are well-typed.

The Henry Ford encodings representing these GADTs in terms of the
equality GADT are:
\begin{equation}\label{eq:eq_ltype}
\begin{array}{l}
\mathsf{data\ LType : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;tBool :\, \forall (B : Set) \to Equal\,A\,Bool
  \to LType\,A}\\ 
\mathsf{\;\;\;\;\;\;\;\;tArr\,\,\, :\, \forall (B\,C : Set) \to
  Equal\,A\,(B \to C) \to LType\,B \to LType\,C \to LType\,A}\\ 
  \mathsf{\;\;\;\;\;\;\;\;tList\,\, :\, \forall (B : Set) \to
    Equal\,A\,(\List\,B) \to LType\,B \to LType\,A} 
\end{array}
\end{equation}
and
\begin{equation}\label{eq:eq_lterm}
\begin{array}{l}
\mathsf{data\ LTerm : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;var\,\,\,\,\,\,\,:\, String \to LType\,A \to
  LTerm\,A} \\  
\mathsf{\;\;\;\;\;\;\;\;abs\,\,\,\,\,\, :\, \forall (B\,C : Set) \to
  Equal\,A\,(B \to C) \to String \to LType\,B \to LTerm\,C \to
  LTerm\,A}\\ 
  \mathsf{\;\;\;\;\;\;\;\;app\,\,\,\,\, :\, \forall (B : Set) \to
    LTerm (B \to A) \to LTerm\,B \to LTerm\,A} \\ 
  \mathsf{\;\;\;\;\;\;\;\;listC\,\,\, :\, \forall (B : Set) \to
    Equal\,A\,(List\,B) \to List\,(LTerm\,B) \to LTerm\,A} 
\end{array}
\end{equation}

\vspace*{0.05in}

We will revisit these GADTs in {\color{red} Sections~\ref{}
  and~\ref{}}.

\vfill

\pagebreak

\section{(Deep) induction for GADTs}

%\begin{itemize}
%    \item Recall structural induction does not work for GADTs because it does not work for truly nested types.
%    \item Induction rules are traditionally derived using functoriality
%    \item This cannot be extended to GADTs in this setting because they have no functorial semantics
%    \item This paper nevertheless shows how to extend (deep) induction to GADTs.
%\end{itemize}

%As we have seen in Section~\ref{ssec:induction-nested},
%truly nested types do not support a structural induction rule,
%which is the reason why it was necessary to introduce a deep induction rule supporting them.
%Consequently, GADTs do not support a structural induction rule either,
%as they generalize nested types.
%Still, there is hope for GADTs to support a deep induction rule,
%like nested types do.

Reasoning about GADTs can generally be quite difficult,
even more so than for ADTs and nested types.
To help with that,
we want to extend the deep induction principle seen in Section~\ref{ssec:induction-nested} to GADTs.

Induction rules, and specifically deep induction rules for nested types,
are traditionally derived using the functorial semantics of data types
in the setting of a parametric model~\cite{jp19}.
In particular, relational parametricity is used to validate the induction principle because induction is, itself,
a form of unary parametricity, where binary relations have been replaced with predicates,
which are essentially unary relations.
{\color{blue} Is there a reference for this?}
%in the sense that induction involves predicates, which are unary relations,
%as opposed to the binary relations involved in relational parametricity.

Unfortunately, this approach cannot possibly be employed
to prove a deep induction rule for GADTs,
as these types do not allow for a functorial interpretation,
at least in a parametric model~\cite{jgj21}.

Nevertheless, this paper shows how to extend deep induction to some GADTs.
We will first demonstrate how to derive the deep induction rule for some example cases,
and then provide a general principle that works for generic GADTs,
as long as these do not feature nesting in their definition.



\subsection{(Deep) induction for $\mathsf{Equal}$}\label{sec:ind-equal}

%\begin{itemize}
%\item Define $\mathsf{Equal}^{\wedge}$
%\[
%\mathsf{Equal^{\wedge} : \forall (a : Set) (b : Set) \to (a \to Set) \to (b \to Set) \to Equal\,a\,b \to Set}
%\]
%is defined by
%\[
%\mathsf{Equal^{\wedge}\,a\,a\,Q\,Q'\,Refl = \forall (x : a) \to Equal\,(Q\,x)(Q'\,x)}
%\]
%\item (Deep) induction rule for $\mathsf{Equal}$
%\item Prove deep induction for $\mathsf{Equal}$ (define term)
%\end{itemize}

As a first example, we derive the induction rule for the $\mathsf{Equal}$ type from example~\ref{example:equal}.
This will provide a simple case study that will inform the investigation of more complex GADTs.
Moreover, since we define GADTs using the $\mathsf{Equal}$ type,
as for example in Equation~\ref{eq:eq-seq},
this example will be instrumental in stating and deriving the induction rule of other GADTs.

To define an induction rule for a type $\mathsf{G}$ we first need a predicate-lifting operation
which takes predicates on a type $\mathsf{A}$ and lifts them to predicates on $\mathsf{G\,A}$.
the predicate-lifting function for $\mathsf{Equal}$ is the function
\[
\mathsf{Equal^{\wedge} : \forall (A\,B : Set) \to (A \to Set) \to (B \to Set) \to Equal\,A\,B \to Set}
\]
defined as
\[
\mathsf{Equal^{\wedge}\,A\,A\,Q\,Q'\,Refl = \forall (a : A) \to Equal\,(Q\,a)(Q'\,a)}
\]
i.e., the function that takes two predicates on the same type and tests them for extensional equality.

Next, we need to associate each constructor of the GADT under consideration
to the expression that a given predicate is preserved by such constructor.
Let $\mathsf{dIndRefl}$ be the following function associated to the $\mathsf{refl}$ constructor:
\[
\begin{array}{l}
\mathsf{\lambda (P : \forall (A\,B : Set) \to (A \to Set) \to (B \to Set) \to Equal\,A\,B \to Set)} \\
\quad\mathsf{\to \forall (C : Set) (Q\, Q' : C \to Set) \to Equal^{\wedge}\,C\,C\,Q\,Q'\,refl \to P\,C\,C\,Q\,Q'\,refl}
\end{array}
\]

The induction rule states that,
if a predicate is preserved by all of the constructors of the GADT under consideration,
then the predicate is satisfied by any element of the GADT.
The induction rule for $\mathsf{Equal}$ is thus the type
\[
\begin{array}{l}
\mathsf{\forall (P : \forall (A\,B : Set) \to (A \to Set) \to (B \to Set) \to Equal\,A\,B \to Set)} \\
\quad \mathsf{\to dIndRefl\,P \to \forall (A\,B : Set) (Q_A : A \to Set) (Q_B : B \to Set) (e: Equal\,A\,B)
  \to Equal^{\wedge}\,A\,B\,Q_A\,Q_B\,e \to P\,A\,B\,Q_A\,Q_B\,e}
\end{array}
\]
To validate the induction rule we need to provide it with a witness, i.e.,
we need to show that the associated type is inhabited.
We thus need to define a term $\mathsf{dIndEqual}$ of the above type,
i.e., we need to define
\[
\mathsf{dIndEqual\,P\,crefl\,A\,B\,Q_A\,Q_B\,e\,liftE : P\,A\,B\,Q_A\,Q_B\,e}
\]
for $\mathsf{crefl : dIndRefl\,P}$,
$\mathsf{Q_A : A \to Set}$, $\mathsf{Q_B : B \to Set}$,
$\mathsf{e : Equal\,A\,B}$
and $\mathsf{liftE : Equal^{\wedge}\,A\,B\,Q_A\,Q_B\,e}$.
By pattern-matching, we only need to consider the case where $\mathsf{A = B}$ and $\mathsf{e = refl}$,
and define
\[
\mathsf{dIndEqual\,P\,crefl\,A\,A\,Q_A\,Q_A'\,refl\,liftE = crefl\,A\,Q_A\,Q_A'\,liftE}
\]
%where
%$\mathsf{Q_A : A \to Set}$, $\mathsf{Q_A' : A \to Set}$
%and $\mathsf{L_E : Equal^{\wedge}\,A\,A\,Q_A\,Q_A'\,Refl}$.
Having provided a well-defined term for it,
we have shown that the induction rule for $\mathsf{Equal}$ is sound.

The type $\mathsf{Equal}$ also has a standard structural induction rule $\mathsf{indEqual}$,
\[
\mathsf{\forall (Q : \forall (A\,B : Set) \to Equal\,A\,B \to Set)
  \to \big( \forall (C : Set) \to P\,C\,C\,refl \big)
  \to \forall (A\,B : Set) (e: Equal\,A\,B) \to P\,A\,B\,e}
\]
As is the case for ADTs and nested types,
the structural induction rule for $\mathsf{Equal}$ is a consequence of the deep induction rule.
Indeed, we can define $\mathsf{indEqual}$ as
\[
\mathsf{indEqual\,Q\,srefl\,A\,B\,e = dIndEqual\,P\,srefl\,A\,B\,K^A_\top\,K^B_\top\,e\,liftE}
\]
where
$\mathsf{Q : \forall (A\,B : Set) \to Equal\,A\,B \to Set}$,
$\mathsf{srefl: \forall (C : Set) \to P\,C\,C\,refl}$
and $\mathsf{e : Equal\,A\,B}$, and
\begin{itemize}
\item $\mathsf{P : \forall (A\,B : Set) \to (A \to Set) \to (B \to Set) \to Equal\,A\,B \to Set}$ is defined as
$\mathsf{P\,A\,B\,Q_A\,Q_B\,e = Q\,A\,B\,e}$;
\item $\mathsf{K^A_\top}$ and $\mathsf{K^B_\top}$ are the constantly $\mathsf{\top}$-valued predicates on, respectively, $\mathsf{A}$ and $\mathsf{B}$;
%\item $\mathsf{K^b_1}$ is the constantly $\mathsf{1}$-valued predicate on $\mathsf{b}$;
\item $\mathsf{liftE : Equal^{\wedge}\,A\,B\,K^A_\top\,K^B_\top\,e}$ is defined by pattern matching,
i.e., in case $\mathsf{A = B}$ and $\mathsf{e = refl}$,
it is defined as $\mathsf{liftE\,a = refl : Equal\,A\,A}$ for every $\mathsf{a : A}$.
\end{itemize}
That the structural induction rule is a consequence of the deep induction one is also true for all the examples below,
even though we will not remark it every time.



\subsection{(Deep) induction for $\mathsf{Seq}$}

Next, we shall provide an induction rule for the $\mathsf{Seq}$ type defined in Example~\ref{example:seq}.
Again, the first step in deriving the induction rule for $\mathsf{Seq}$ consists in defining the predicate-lifting function over it, 
\[
\mathsf{Seq^{\wedge} : \forall (A : Set) \to (A \to Set) \to Seq\,A \to Set}
\]
which is given by pattern-matching as
\[
\mathsf{Seq^{\wedge}\,A\,Q_A\,(const\,a) = Q_A\,a}
\]
where $\mathsf{Q_A : A \to Set}$ and $\mathsf{a : A}$,
and
\[
\begin{array}{l}
\mathsf{Seq^{\wedge}\,A\,Q_A\,(sPair\,B\,C\,e\,s_B\,s_C)} \\
\quad\mathsf{=
\sum [Q_B : B \to Set] [Q_C : C \to Set]\;
Equal^{\wedge}\,A\, (B \times C)\, Q_A\, (Q_B \times Q_C) \, e \times Seq^{\wedge}\,B\,Q_B\,s_B \times Seq^{\wedge}\,C\,Q_C\,s_C
}
\end{array}
\]
where $\mathsf{e : Equal\,A\,(B \times C)}$,
$\mathsf{s_B : Seq\,B}$ and $\mathsf{s_C : Seq\,C}$.
%We also need to define the lifting of predicates over the polymorphic type of pairs,
%$\mathsf{Pair = \forall (B\,C : Set) \to B \times C}$, which is 
%\[
%\mathsf{Pair^{\wedge} : \forall (b\,c : Set) \to (b \to Set) \to (c \to Set) \to Pair\,b\,c \to Set}
%\]
%and it is defined as
%\[
%\mathsf{Pair^{\wedge}\,b\,c\,Q_b\,Q_c\,(y, z) = Q_b\,y \times Q_c\,z}
%\]
%where $\mathsf{Q_b : b \to Set}$, $\mathsf{Q_c : c \to Set}$, $\mathsf{y : b}$ and $\mathsf{z : c}$.

Finally, let $\mathsf{dIndConst}$ be the function
\[
\mathsf{
\lambda (P : \forall (A : Set) \to (A \to Set) \to Seq\,A \to Set)
\to \forall (A : Set) (Q_A : A \to Set) (a : A)
\to Q_A\,x \to P\,A\,Q_A\,(Const\,a)
}
\]
associated to the $\mathsf{const}$ constructor,
and let $\mathsf{dIndSPair}$ be the function
\[
\begin{array}{l}
\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to Seq\,A \to Set)} \\
\quad \mathsf{\to \forall (A\,B\,C : Set) (Q_A : A \to Set) (Q_B : B \to Set) (Q_C : C \to Set)(s_B : Seq\,B) (s_C : Seq\,C) (e : Equal\,A\,(B \times C))} \\
\quad \mathsf{\to Equal^{\wedge} A\, (B \times C)\, Q_A\, (Pair^{\wedge}\,B\,C\,Q_B\,Q_C)\, e
	\to P\,B\,Q_B\,s_B \to P\,C\,Q_C\,s_C
	\to P A Q_A ( SPair\,B\,C\,e\,s_B\,s_C )}
\end{array}
\]
associated to the $\mathsf{sPair}$ constructor.

With these tools we can formulate an induction rule for $\mathsf{Seq}$,
\[
\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to (A \to Set) \to Seq\,A \to Set)}
\mathsf{\to CConst\,P \to CSPair\,P} \\
\quad \mathsf{\to \forall (A : Set)(Q_A : A \to Set)(s_A : Seq\,A) \to Seq^{\wedge}\,A\,Q_A\,s_A \to P\,A\,Q_A\,s_A}
\end{array}
\]
To validate the induction rule, we define a term $\mathsf{dIndSeq}$ for the above type.
We have to define
\[
\mathsf{dIndSeq\,P\,cconst\,cspair\,A\,Q_A\,s_A\,liftA : P\,A\,Q_A\,s_A}
\]
where
$\mathsf{P : \forall (A : Set) \to (A \to Set) \to Seq\,A \to Set}$,
$\mathsf{cconst : cConst\,P}$,
$\mathsf{cspair : cSPair\,P}$,
$\mathsf{Q_A : A \to Set}$, $\mathsf{s_A : Seq\,A}$
and $\mathsf{liftA : Seq^{\wedge}\,A\,Q\,s_A}$,
and we proceed by pattern-matching on $\mathsf{s_A}$.
Let $\mathsf{s_A = const\,a}$ for $\mathsf{a : A}$, and define
\[
\mathsf{dIndSeq\,P\,cconst\,cspair\,A\,Q_A\,(const\,a)\,liftA = cconst\,A\,Q_A\,a\,liftA}
\]
Notice that $\mathsf{Seq^{\wedge}\,A\,Q_A\,(const\,a) = Q_A\,a}$, and thus $\mathsf{liftA : Q_A\,a}$,
making the right-hand-side in the above expression type-check.
Now, let $\mathsf{s_A = sPair\,B\,C\,e\,s_B\,s_C}$
for $\mathsf{e : Equal\,A\,(B \times C)}$, $\mathsf{s_B : Seq\,B}$ and $\mathsf{s_C : Seq\,C}$,
and define
\[
\mathsf{dIndSeq\,P\,cconst\,cspair\,A\,Q_A\,(sPair\,B\,C\,e\,s_B\,s_C)\,(Q_B, Q_C, liftE, liftB, liftC)
	= cspair\,A\,B\,C\,Q_A\,Q_B\,Q_C\,s_B\,s_C\,e\,liftE\,p_B\,p_C}
\]
where $\mathsf{(Q_B, Q_C, liftE, liftB, liftC) : Seq^{\wedge}\,A\,Q\,(sPair\,B\,C\,e\,s_B\,s_C)}$, i.e.,
\begin{itemize}
\item $\mathsf{Q_B : B \to Set}$ and $\mathsf{Q_C : C \to Set}$;
\item $\mathsf{liftE : Equal^{\wedge}\,A\, (B \times C)\, Q_A\, (Q_B \times Q_C) \, e}$;
\item $\mathsf{liftB : Seq^{\wedge}\,B\,Q_B\,s_B}$ and $\mathsf{liftC : Seq^{\wedge}\,C\,Q_C\,s_C}$;
\end{itemize}
and $\mathsf{p_B}$ and $\mathsf{p_C}$ are defined as follows:
\begin{align*}
\mathsf{p_B} &=\mathsf{DISeq\,P\,cconst\,cspair\,B\,Q_B\,s_B\,liftB : P\,B\,Q_B\,s_B} \\
\mathsf{p_C} &=\mathsf{DISeq\,P\,cconst\,cspair\,C\,Q_C\,s_C\,liftC : P\,C\,Q_C\,s_C}
\end{align*}



\subsection{(Deep) induction for $\mathsf{LTerm}$ }

%Same structure as previous two.
%Runs through the paper.
%Still to decide?

%{\color{blue} Some notational conventions: I am using uppercase letters for elements of LType and 
%lowercase letters for elements of LTerm. For example, $\mathsf{(T_b : LType \, b)}$ or $\mathsf{(t_c : LTerm \,c)}$.}

We now present an induction rule for the $\mathsf{LTerm}$ type defined in Example~\ref{example:lterm}.
For that, we need liftings for both $\mathsf{LType}$ and
$\mathsf{LTerm}$. We will also need a lifting of predicates for arrow types, since arrow types appear in 
$\mathsf{LType}$ and $\mathsf{LTerm}$. The lifting for arrow types 
\[
  \mathsf{Arr^{\wedge} : \forall (A\, B : Set) \to (A \to Set) \to (B \to Set) \to (A \to B) \to Set}
\]
is defined as
\[
  \mathsf{Arr^{\wedge}\, A\, B\, Q_A\, Q_B\, f = \forall (a : A) \to Q_A\,a \to Q_B\, (f\,a)}
\]
Now we can define the lifting for $\mathsf{LType}$, which has type 
\[
\mathsf{LType^{\wedge} : \forall (A : Set) \to (A \to Set) \to LType\,A \to Set}
\]
and is defined by pattern-matching as
\[
  \mathsf{LType^{\wedge}\,A\,Q_A\,(tBool\,B\,e)
  = \sum [Q_B : B \to Set]\, Equal^{\wedge}\, A\, B\, Q_A\, K^{Bool}_{\top} \,e}
\]
where $\mathsf{Q_A : A \to Set}$,
$\mathsf{K^{Bool}_{\top}}$ is the constantly $\mathsf{\top}$-valued predicate on $\mathsf{Bool}$
and $\mathsf{e : Equal\,A\,Bool}$;
\[
\begin{array}{l}
\mathsf{LType^{\wedge}\,A\,Q_A\,(tArr\, B\, C\, e\, T_B\, T_C)} \\
\quad
\mathsf{= \sum [Q_B : B \to Set] [Q_C : C \to Set]\,
  Equal^{\wedge}\,A\, (B \to C)\, Q_A\, (Arr^{\wedge} \, B\, C\, Q_B \, Q_C) \, e
  \times \, LType^{\wedge}\,B\,Q_B\,T_B \times LType^{\wedge}\,C\,Q_C\,T_C
}
\end{array}
\]
where $\mathsf{Q_A : A \to Set}$, $\mathsf{e : Equal\, A\, (B \to C)}$, $\mathsf{T_B : LType \,B}$ and 
$\mathsf{T_C : LType \,C}$;
and 
\[
\mathsf{LType^{\wedge}\,A\,Q_A\,(tList\, B\, e\, T_B)
=
\sum [Q_B : B \to Set]\, 
  Equal^{\wedge}\,A\, (List\, B)\, Q_A\, (List^{\wedge} \, B\, Q_B) \, e 
  \times LType^{\wedge}\,B\,Q_B\,T_B
}
\]
where $\mathsf{Q_A : A \to Set}$, $\mathsf{e : Equal\, A\, (List\, B)}$, and $\mathsf{T_B : LType \,B}$.
%Given the lifting for $\mathsf{LType}$, 
We can define the lifting for $\mathsf{LTerm}$. Again, 
the lifting 
\[
\mathsf{LTerm^{\wedge} : \forall (A : Set) \to (A \to Set) \to LTerm\,A \to Set}
\]
is defined by pattern-matching as
\[
  \mathsf{LTerm^{\wedge}\,A\,Q_A\,(var\,s\,T_A) = LType^{\wedge}\, A\, Q_A\, T_A}
\]
where $\mathsf{s : String}$ and $\mathsf{T_A : LType\, A}$;
\[
\begin{array}{l}
\mathsf{LTerm^{\wedge}\,A\,Q_A\, (abs \,B \,C \,e \,s \,T_B \,t_C)} \\ 
\quad \mathsf{
  = \sum [Q_B : B \to Set] [Q_C : C \to Set]\,
      Equal^{\wedge} \, A\, (B \to C)\, Q_A\, (Arr^{\wedge} \, B\, C\, Q_B \, Q_C)\, e
      \times \, LType^{\wedge}\, B\, Q_B\, T_B
      \times \, LTerm^{\wedge}\, C\, Q_C\, t_C }
\end{array}
\]
where $\mathsf{e : Equal \, A \, (B \to C)}$,
$\mathsf{s : String}$,
$\mathsf{T_B : LType\,B}$,
and $\mathsf{t_C : LTerm \, C}$;
\[
\mathsf{LTerm^{\wedge}\,A\,Q_A\, (app\, B\, t_{BA}\, t_B)
=
\sum [Q_B : B \to Set]\, 
  LTerm^{\wedge}\, (B \to A)\, (Arr^{\wedge} \, B\, A\, Q_B \, Q_A)\, t_{BA}
  \times LTerm^{\wedge}\, B\, Q_B\, t_B}
\]
where $\mathsf{t_{BA} : LTerm \, (B \to A)}$ and $\mathsf{t_B : LTerm \, B}$; and
\[
\mathsf{LTerm^{\wedge}\,A\,Q_A\, (listC\, B\, e\, ts)
=
\sum [Q_B : B \to Set]\,
 Equal^{\wedge} \, A\, (List\,B)\, Q_A\, (List^{\wedge} \, B\, Q_B) \, e
 \times List^{\wedge}\, (LTerm\,B) \, (LTerm^{\wedge} \, B\, Q_B) \, ts}
\]
where $\mathsf{e : Equal\, A\, (List \,B)}$ and $\mathsf{ts : List\, (LTerm B)}$. 
Notice that we use the lifting for $\mathsf{List}$ in the case for the $\mathsf{listC}$ constructor. 

With these liftings, we can define the deep induction principle for $\mathsf{LTerm}$.
% Var case 
Let $\mathsf{dIndVar}$ be the function 
\begin{multline*}
\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A \to Set)} \\
\mathsf{\to 
  \forall (A : Set) (Q_A : A \to Set) (s : String) (T_A : LType\, A) 
  \to LType^{\wedge} \, A\, Q_A\, T_A
  \to P \, A\, Q_A\, (var \, s\, T_A)
  }
\end{multline*}
associated to the $\mathsf{var}$ constructor. 
% Abs case 
Let $\mathsf{dIndAbs}$ be the function 
\begin{align*}
  &\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A \to Set)} \\
  &\quad\mathsf{\to 
  \forall (A\,B\,C: Set) (Q_A : A \to Set)  (Q_B : B \to Set) (Q_C : C \to Set)
  (e : Equal\, A\, (B \to C)) (s : String) } \\ 
  &\quad\mathsf{ \to (T_B : LType\, B) \to (t_C : LTerm\, C)
  \to Equal^{\wedge}\,A\,(B \to C)\, Q_A \, (Arr^{\wedge} \, B\, C\, Q_B \, Q_C) \, e
  } \\
  &\quad\mathsf{
  \to LType^{\wedge}\, B\, Q_B\, T_B
  \to P\, C\, Q_C\, t_C\, 
  \to P \, A\, Q_A\, (abs \,B \,C \, e \,s \,T_B \, t_C)
  }
\end{align*}
associated to the $\mathsf{abs}$ constructor. 
% App case 
Let $\mathsf{dIndApp}$ be the function 
\begin{align*}
  &\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A \to Set)} \\
  &\quad \mathsf{\to 
  \forall (A \,B : Set) (Q_A : A \to Set)  (Q_B : B \to Set) 
   (t_{BA} : LTerm\, (B \to A)) (t_B : LTerm\, B)} \\
  &\quad \mathsf{
  \to P\, (B \to A)\, (Arr^{\wedge} \, B\, A\, Q_B \, Q_A) \, t_{BA} \, 
  \to P\, B\, Q_B\, t_B\, 
  \to P \, A\, Q_A\, (app \,B \,t_{BA} \, t_B) }
\end{align*}
associated to the $\mathsf{app}$ constructor. 
% ListC case 
Let $\mathsf{dIndListC}$ be the function 
\begin{align*}
  &\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A \to Set)} \\
  &\quad \mathsf{\to 
  \forall (A \,B : Set) (Q_A : A \to Set)  (Q_B : B \to Set) 
    (e : Equal\, A\, (List\, B)) (ts : List\, (LTerm\, B))} \\ 
  &\quad \mathsf{
    \to Equal^{\wedge}\, A\, (List\,B)\, Q_A\, (List^{\wedge}\, B\, Q_B)\, e 
  \to List^{\wedge}\, (LTerm\,B) (P\, B\, Q_B)\, ts
  \to P \, A\, Q_A\, (listC \,B \,e \, ts) }
\end{align*}
associated to the $\mathsf{listC}$ constructor.

The type of the deep induction principle for $\mathsf{LTerm}$ is
\[
\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A \to Set)
  \to dIndVar\,P \to dIndAbs\,P \to dIndApp\,P \to dIndListC\,P} \\
\quad \mathsf{\to \forall (A : Set)(Q_A : A \to Set)(t_A : LTerm\,A) \to LTerm^{\wedge}\,A\,Q_A\,t_A \to P\,A\,Q_A\,t_A}
\end{array}
\]
To prove the induction principle, we define a term $\mathsf{dIndLTerm}$ for it.
We have to define 
\[ 
\mathsf{dIndLTerm \, P\, cvar \, cabs\, capp\, clistc \, A\, Q_A\, t_A\, liftA : P\, A\, Q_A\, t_A}
\]
where $\mathsf{cvar: dIndVar}$, $\mathsf{cabs: dIndAbs}$, $\mathsf{capp : dIndApp}$, $\mathsf{clistc : dIndListC}$,
$\mathsf{Q_A : A \to Set}$, $\mathsf{t_A : LTerm\,A}$, and $\mathsf{liftA : LTerm^{\wedge}\,A\,Q_A\,t_A}$.
% where $\mathsf{P : \forall (a : Set) \to (a \to Set) \to LTerm\,a \to Set}$, 
As before, we prove the induction principle by pattern matching on $\mathsf{t_A}$. 
For the $\mathsf{var}$ constructor case, let $\mathsf{t_A = var\, s\, T_A}$ and define
\[
  \mathsf{dIndLTerm \, P\, cvar \, cabs\, capp\, clistc \, A\, Q_A\, (var\,s\,T_A) \, liftA = cvar \, A\, Q_A\, s\, T_A\, liftA }
\]
for $\mathsf{s : String}$ and $\mathsf{T_A : LType\,A}$.
% where $\mathsf{L_a : LTerm^{\wedge}\, a\, Q_a\, (Var\,s\,T_a)}$, i.e., $\mathsf{L_a : LType^{\wedge}\,a\,Q_a\,T_a}$ 
Notice that $\mathsf{LTerm^{\wedge}\, A\, Q_A\, (var\,s\,T_A) = LType^{\wedge}\,A\,Q_A\,T_A}$, so 
$\mathsf{liftA : LType^{\wedge}\,A\,Q_A\,T_A}$.
%
% Abs case 
For the $\mathsf{abs}$ case, let $\mathsf{t_A = abs \,B \,C \, e \,s \,T_B \, t_C} $ and define
\[
\begin{array}{l}
\mathsf{dIndLTerm \, P\, cvar \, cabs\, capp\, clistc \, A\, Q_A\, (abs \,B \,C \,e \,s \,T_B \, t_C) \, (Q_B , Q_C , liftE, lift_{T_B}, lift_{t_C})} \\
\quad \mathsf{= cabs\,A\,B\,C\, Q_A\, Q_B\, Q_C\, e\, s\, T_B\, t_C\, liftE\, lift_{T_B}\, p_C}
\end{array}
\]
where $\mathsf{(Q_B , Q_C , liftE, lift_{T_B}, lift_{t_C}) : LTerm^{\wedge}\, A\, Q_A\, (abs \,B \,C \, e \,s \,T_B \, t_C)}$, i.e.,
\begin{itemize}
  \item $\mathsf{Q_B : B \to Set}$;
  \item $\mathsf{Q_C : C \to Set}$;
  \item $\mathsf{liftE : Equal^{\wedge} \, A\, (B \to C)\, Q_A\, (Arr^{\wedge} \, B\, C\, Q_B \, Q_C) \, e}$;
  \item $\mathsf{lift_{T_B}: LType^{\wedge} \, B\, Q_B\, T_B}$;
  \item $\mathsf{lift_{t_C}: LTerm^{\wedge} \, C\, Q_C\, T_C}$;
\end{itemize}
and $\mathsf{p_C}$ is defined as:
\[
  \mathsf{p_C =  dIndLTerm\,P\,cvar\,cabs \,capp \,clistc\, C\, Q_C\, t_C\, lift_{t_C}  : P \, C\, Q_C \, t_C }
\]
% App case - (App \,b \,t_{ba} \, t_b)
For the $\mathsf{app}$ case, let $\mathsf{t_A = app \,B \,\,t_{BA} \, t_B} $ and define
\[
  \mathsf{dIndLTerm \, P\, cvar \, cabs\, capp\, clistc \, A\, Q_A\,  (app \,B \,\,t_{BA} \, t_B)\, (Q_B , list_{t_{BA}}, list_{t_B})} \\
  \mathsf{= capp\,A\,B\,Q_A\, Q_B\, t_{BA}\, t_B\, p_{BA} \, p_B}
\]
where $\mathsf{(Q_B , lift_{t_{BA}}, list_{t_B}) : LTerm^{\wedge}\, A\, Q_A\, (app \,B \,t_{BA} \, t_B)}$, i.e.,
\begin{itemize}
  \item $\mathsf{Q_B : B \to Set}$;
  \item $\mathsf{lift_{t_{BA}}: LTerm^{\wedge} \, (B \to A)\, (Arr^{\wedge} \, B\, A\, Q_B \, Q_A)\, t_{BA}}$;
  \item $\mathsf{lift_{t_B}: LTerm^{\wedge} \, B\, Q_B\, t_B}$;
\end{itemize}
and $\mathsf{p_{BA}}$ and $\mathsf{p_B}$
and are defined as:
\begin{align*}
  \mathsf{p_{BA}} &= \mathsf{dIndLTerm\,P\,cvar\,cabs \,capp \,clistc\, (B \to A)\,(Arr^{\wedge} \, B\, A\, Q_B \, Q_A) \, t_{BA}\, lift_{t_{BA}}
  : P \, (B \to A)\, (Arr^{\wedge} \, B\, A\, Q_B \, Q_A) \, t_{BA} } \\
  \mathsf{p_B} &= \mathsf{dIndLTerm\,P\,cvar\,cabs \,capp \,clistc\, B\, Q_B\, t_B\, lift_{t_B}  : P \, B\, Q_B \, t_B } 
\end{align*}
% ListC case - (ListC \,b \,e \, ts)
Finally, for the $\mathsf{listC}$ case, let $\mathsf{t_A = listC \,B \,e \, ts}$ and define
\begin{multline*}
  \mathsf{dIndLTerm \, P\, cvar \, cabs\, capp\, clistc \, A\, Q_A\, (listC \,B \,e \, ts) \, (Q_B , liftE, lift_{List})
  = clistc \,A\,B\,Q_A\, Q_B\, e\, ts\, liftE\, p_{List} }
\end{multline*}
where $\mathsf{(Q_B , liftE, lift_{List}): LTerm^{\wedge}\, A\, Q_A\, (listC \,B \,e \, ts)}$, i.e.,
\begin{itemize}
  \item $\mathsf{Q_B : B \to Set}$;
  \item $\mathsf{listE : Equal^{\wedge}\, A\, (List\,B)\, Q_A\, (List^{\wedge}\, B\, Q_B)\, e}$;
  \item $\mathsf{lift_{List}: List^{\wedge} \, (LTerm\, B) \, (LTerm^{\wedge}\, B\, Q_B) \, ts}$;
\end{itemize}
and $\mathsf{p_{List}}$ is defined as:
\[
  \mathsf{p_{List} = liftListMap \, (LTerm\, B) \, (LTerm^{\wedge} \, B \, Q_B)\, 
    (P\,B\,Q_B)\, p_{ts} \, ts\, lift_{List}  : List^{\wedge}\, (LTerm\,B) \, (P\,B\,Q_B) \, ts}
\]
and $\mathsf{p_{ts}}$ is defined as:
\[
\mathsf{
  p_{ts} = dIndLTerm\, P\, cvar\, cabs\, capp\, clistc\, B\, Q_B :  PredMap\,(LTerm\,B) \,(LTerm^{\wedge}\, B\, Q_B) \, (P\,B\,Q_B)
  }
\]
where 
\[
\mathsf{liftListMap : \forall\, (A : Set) \to (Q_A \, Q'_A : A \to Set) 
  \to PredMap\,A\,Q_A\,Q'_A \to PredMap\,(List\,A) \,(List^{\wedge}\, A\, Q_A)\, (List^{\wedge}\, A\, Q'_A)}
\]
takes a morphism of predicates and produces a morphism of lifted predicates. 
$\mathsf{PredMap}$ is the type constructor that produces the type of morphisms between predicates, and it is defined as follows: 
\begin{align*}
  &\mathsf{PredMap : \forall\, (A : Set) \to (A \to Set) \to (A \to Set) \to Set } \\
  &\mathsf{PredMap \,A\, Q_A\,Q'_A\, = \forall\, (a : A) \to Q_A\,a \to Q'_A\,a}
\end{align*}



\subsection{General case}

%We restrict our scope to GADTs not featuring nesting,
%in the sense that their constructors contain no nested calls of the recursive variable,
%as truly nested types do.
%This way we can avoid the issue described in Section~\ref{sec:GADT-nested}.
%The reason for this restriction will be discussed in Section~\ref{sec:GADT-nested}.

Finally, we generalize the approach taken in the previous examples
and provide a general framework to derive induction rules for arbitrary GADTs.
%Since, as seen in Section~\ref{sec:GADT-nested},
%GADTs featuring nesting do not admit an induction rule,
%we restrict our scope to GADTs not featuring nesting.
For that, we need to give a grammar for the types we will be considering.
A generic GADT
\begin{equation*}
\begin{array}{l}
\mathsf{data\ G : Set^\alpha \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;c_i\, :\, F_i\,G\,\ol{B} \to G (\ol{K_i\,\ol{B}})}
\end{array}
\end{equation*}
is defined by a finite number of constructors $\mathsf{c_i}$.
In the definition above, $\mathsf{F_i}$ is a type constructor with signature $\mathsf{(Set^{\alpha} \to Set) \to Set^{\beta} \to Set}$
and each $\mathsf{K_i}$ is a type constructor with signature $\mathsf{Set^{\beta} \to Set}$
(i.e. a type constructor of arity $\mathsf{\beta}$).
The overline notation denotes a finite list:
%$\mathsf{\ol{a}}$ is a list of types of length $\mathsf{\alpha}$,
%so that it can be applied to the type constructor $\mathsf{G}$ of arity $\mathsf{\alpha}$.
%and the vertical bars notation denotes the length of a list:
%$\mathsf{G}$ depends on a finite list of types $\mathsf{\ol{a}}$ of length $\mathsf{\alpha}$,
each of the $\mathsf{\alpha}$-many $\mathsf{K_i}$ is a type constructor of arity $\mathsf{\beta}$
so that it can be applied to the list of types $\mathsf{\ol{B}}$ of length $\mathsf{\beta}$.
%depends on a finite list of types $\mathsf{\ol{b}}$ of length $\mathsf{\beta}$,
Moreover, notice that the arity of $\mathsf{G}$ matches the number of type constructors $\mathsf{K_i}$.
We allow each $\mathsf{F_i}$ to be inductively built in the following ways (and with the following restrictions):
\begin{itemize}
\item $\mathsf{F_i = F_i' \times F_i''}$ where $\mathsf{F_i'}$ and $\mathsf{F_i''}$ have the same signature as $\mathsf{F_i}$ and are built recursively from the same induction rules.
\item $\mathsf{F_i = F_i' + F_i''}$ where $\mathsf{F_i'}$ and $\mathsf{F_i''}$ have the same signature as $\mathsf{F_i}$ and are built recursively from the same induction rules.
\item $\mathsf{F_i = F_i' \to F_i''}$
where $\mathsf{F_i'}$ does not contain the recursive variable,
i.e., $\mathsf{F_i' : Set^\beta \to Set}$ is a type constructor of arity $\mathsf{\beta}$,
and $\mathsf{F_i''}$ has the same signature as $\mathsf{F_i}$ and is built recursively from the same induction rules.
\item $\mathsf{F_i\,G\,\ol{B} = G(\ol{F_j\,\ol{B}})}$
where none of the $\mathsf{\alpha}$-many $\mathsf{F_j}$ contains the recursive variable,
i.e., $\mathsf{F_j : Set^\beta \to Set}$
is a type constructor of arity $\mathsf{\beta}$
for each $\mathsf{j = 1, \dots, \alpha}$.
Such restriction is necessary to prevent nesting,
as that would break the induction rule as discussed in Section~\ref{sec:GADT-nested}.
\item $\mathsf{F_i\,G\,\ol{B} = H\,\ol{B}}$
where $\mathsf{H}$ is a type constructor of arity $\mathsf{\beta}$ not containing the recursive variable,
i.e., $\mathsf{H : Set^\beta \to Set}$.
Notice that this covers the case in which $\mathsf{F_i}$ is a closed type,
so, in particular, the unit and empty types, $\mathsf{1}$ and $\mathsf{0}$,
and the case in which $\mathsf{F_i}$ is a variable.
%The only requirement on $\mathsf{H}$ is that it needs to have a predicate-lifting function
%(and any type made of constant types, sums, products, arrow types and other GADTs satisfies this condition).
\item $\mathsf{F_i\,G\,\ol{B} = H (\ol{F_k\,G\,\ol{B}})}$
where $\mathsf{H}$ is a $\mathsf{\gamma}$-ary type constructor not containing the recursive variable,
i.e., $\mathsf{H : Set^\gamma \to Set}$,
and $\mathsf{F_k}$ has the same signature as $\mathsf{F_i}$  and is built recursively from the same induction rules, for every $\mathsf{k = 1 \dots \gamma}$.
Moreover, we require that $\mathsf{H}$ is not a GADT itself (but we allow it to be an ADT or even a nested type).
This way we know that $\mathsf{H}$ admits functorial semantics~\cite{jp20}, and thus there is a map function for $\mathsf{H^{\wedge}}$,
\[
\mathsf{HLMap : \forall (\ol{C : Set}) (\ol{Q_C\;Q_C' : C \to Set})
	\to \ol{PredMap\,C\,Q_C\,Q_C'}
	\to PredMap\,(H\,\ol{C})\,(H^{\wedge}\,\ol{C}\,\ol{Q_C})\,(H^{\wedge}\,\ol{C}\,\ol{Q_C'})}
\]
%where $\mathsf{PredMap : \forall (C : Set) \to (C \to Set) \to (C \to Set) \to Set}$
%is defined as
%\[
%\mathsf{PredMap\,C\,Q_c\,Q_c' = \forall (x : c) \to Q_c\,x \to Q_c'\,x}
%\]
%and represents the type of morphisms between predicates.
A concrete way to define $\mathsf{HLMap}$ is to proceed by induction on the structure of the type $\mathsf{H}$,
and give an inductive definition when $\mathsf{H}$ is an ADT or a nested type.
Such details are not essential to the present discussion, and thus we omit them.
\end{itemize}
We can summarize the above inductive definition with the following grammar
(but beware that the above restrictions and requirements still apply):
\[
\mathsf{F_i\,G\,\ol{B} :=
F_i'\,G\,\ol{B} \times F_i''\,G\,\ol{B}
\ \vert\ F_i'\,G\,\ol{B} + F_i''\,G\,\ol{B}
\ \vert\ F_i'\,\ol{B} \to F_i''\,G\,\ol{B}
\ \vert\ G(\ol{F_j\,\ol{B}})
\ \vert\ H\,\ol{B}
\ \vert\ H (\ol{F_k\,G\,\ol{B}})
}
\]
A further requirement that applies to all of the types appearing above,
including the types $\mathsf{K_i}$,
is that every type needs to have a predicate-lifting function.
This is not an overly restrictive condition, though:
all types made by sums, products, arrow types and type application do, and so do GADTs as defined above.
A concrete way to define the predicate-lifting function for a type is to proceed by induction on the structure of the type,
and we have seen in the previous sections examples of how to do so for products and type application.
We do not give here the general definition of lifting,
as that would require to first present a full type calculus,
and that is beyond the scope of the paper.

%Before proceeding with the derivation of the induction rule for a generic GADT,
%we need to define the type
%\[
%\mathsf{PredMap\,a\,Q_a\,Q_a' = \forall (x : a) \to Q_a\,x \to Q_a'\,x}
%\]
%where $\mathsf{Q_a}$ and  $\mathsf{Q_a'}$ are predicates on  $\mathsf{a : Set}$,
%which represents the type of morphisms between predicates $\mathsf{Q_a}$ and  $\mathsf{Q_a'}$.
%Moreover, if $\mathsf{H}$ is a type constructor having an associated predicate-lifting function $\mathsf{H^{\wedge}}$,
%we define a map function $\mathsf{HLMap}$ for the lifting $\mathsf{H^{\wedge}}$ as
%\[
%\mathsf{HLMap : \forall (a : Set) (Q_a\;Q_a' : a \to Set) \to PredMap\,a\,Q_a\,Q_a' \to PredMap\,(G\,a)\,(G^{\wedge}\,a\,Q_a)\,(G^{\wedge}\,a\,Q_a')}
%\]

Consider a generic GADT as defined above,
\begin{equation}\label{eq:gadt}
\begin{array}{l}
\mathsf{data\ G : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;c\, :\, F\,G\,\ol{B} \to G (K\,\ol{B})}
\end{array}
\end{equation}
which, for ease of notation,
we assume to be a unary type constructor (i.e. it depends on a single type parameter $\mathsf{A}$)
and to have only one constructor $\mathsf{c}$.
Extending the argument to GADTs of arbitrary arity and with multiple constructors presents no difficulty
other than heavier notation.
In the definition above, $\mathsf{F}$ has signature $\mathsf{(Set \to Set) \to Set^{\beta} \to Set}$
and each $\mathsf{K}$ has signature $\mathsf{Set^{\beta} \to Set}$.
The constructor $\mathsf{c}$ can be rewritten using the $\mathsf{Equal}$ type as
\[
\mathsf{c : \forall (\ol{B : Set}) \to Equal\,A\,(K\,\ol{B}) \to F\,G\,\ol{B} \to G\,A}
\]
which is the form we shall use from now on.

In order to state the induction rule for $\mathsf{G}$,
we first need to define $\mathsf{G}$'s associated predicate-lifting function 
\[
\mathsf{G^{\wedge} : \forall (A : Set) \to (A \to Set) \to G\,A \to Set}
\]
as
\[
\mathsf{G^{\wedge}\,A\,Q_A\,(c\,\ol{B}\,e\,x)
= \sum [\ol{Q_B : B \to Set}]\,
Equal^{\wedge}\,A\,(K\,\ol{B})\,Q_A\,(K^{\wedge}\,\ol{B}\,\ol{Q_B})\,e
\times F^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,{\ol{Q_B}}\,x}
\]
where $\mathsf{Q_A : A \to Set}$
and $\mathsf{c\,\ol{B}\,e\,x : G\,A}$,
i.e., $\mathsf{e : Equal\,A\,(K\,\ol{B})}$ and $\mathsf{x : F\,G\,\ol{B}}$.
As already mentioned before, we also assume to have liftings for $\mathsf{F}$,
\[
\mathsf{F^{\wedge} : \forall (G : Set^{\alpha} \to Set) (\ol{B : Set})
\to (\forall (A : Set) \to (A \to Set) \to G\,A \to Set)
\to (\ol{B \to Set})
\to F\,G\,\ol{B} \to Set}
\]
and for  $\mathsf{K}$,
\[
\mathsf{K^{\wedge} : \forall (\ol{B : Set}) \to (\ol{B \to Set}) \to K\,\ol{B} \to Set}
\]
Finally, associate the function
\[
\begin{array}{l}
\mathsf{dIndC = \lambda (P : \forall (A : Set) \to (A \to Set) \to G\,A \to Set)} \\
\quad \mathsf{\to \forall (A : Set) (\ol{B : Set}) (Q_A : A \to Set) (\ol{Q_B : B \to Set}) (e : Equal\,A\,(K\,\ol{B})) (x : F\,G\,\ol{B})} \\
\quad \mathsf{\to Equal^{\wedge}\,A\,(K\,\ol{B})\,Q_A\,(K^{\wedge}\,\ol{B}\,\ol{Q_B})\,e
	\to F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}\,x
	\to P\,A\,Q_A\,(c\,\ol{B}\,e\,x)}
\end{array}
\]
to the constructor $\mathsf{c}$.

%We can now define the induction rule for $\mathsf{G}$
The induction rule for $\mathsf{G}$ is
\[
\mathsf{\forall (P : \forall (A : Set) \to (A \to Set) \to G\,A \to Set) \to dIndC\,P
%\mathsf{\to \Big(
%\forall (\ol{a : Set}) (\ol{b : Set}) (\ol{Q_a : a \to Set}) (\ol{Q_b : b \to Set}) (\ol{e_a : Equal\,a\,(K\,\ol{b})}) (x : F\,G\,\ol{b})} \\
%\mathsf{\to \ol{Equal^{\wedge}\,a\,(K\,\ol{b})\,Q_a\,(K^{\wedge}\,\ol{b}\,\ol{Q_b})\,e_a}
%	\to F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,x
%	\to P\,\ol{a}\,\ol{Q_a}\,(C\,\ol{b}\,\ol{e_a}\,x)
%\Big)} \\
\to \forall (A : Set)(Q_A : A \to Set)(y : G\,A) \to G^{\wedge}\,A\,Q_A\,y \to P\,A\,Q_A\,y}
\]
As we already did in the previous examples,
we validate the induction rule by providing a term $\mathsf{dIndG}$ for the type above.
Define
\[
\mathsf{dIndG\,P\,cc\,A\,Q_A\,(c\,\ol{B}\,e\,x)\,(\ol{Q_B}, liftE, liftF)
= cc\,A\,\ol{B}\,Q_A\,\ol{Q_B}\,e\,x\,liftE\,(p\,x\,liftF)}
\]
where $\mathsf{cc : dIndC\,P}$ and
\begin{itemize}
\item $\mathsf{c\,\ol{B}\,e\,x : G\,A}$,
i.e., $\mathsf{e : Equal\,A\,(K\,\ol{B})}$,
and $\mathsf{x : F\,G\,\ol{B}}$;
\item $\mathsf{(\ol{Q_B}, liftE, liftF) : G^{\wedge}\,A\,Q_A (c\,\ol{B}\,e\,x)}$,
i.e.,
$\mathsf{Q_B : B \to Set}$ for each $\mathsf{B}$,
$\mathsf{liftE : Equal^{\wedge}\,A\,(K\,\ol{B})\,Q_A\,(K^{\wedge}\,\ol{B}\,\ol{Q_B})\,e}$,
and $\mathsf{liftF : F^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,{\ol{Q_B}}\,x}$.
\end{itemize}
Finally, the morphism of predicates
\[
\mathsf{p : PredMap\,(F\,G\,\ol{B})\,(F^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}) (F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B})}
\]
is defined by structural induction on $\mathsf{F}$ as follows:
\begin{itemize}
\item Case $\mathsf{F = F_1 \times F_2}$ where $\mathsf{F_1}$ and $\mathsf{F_2}$ have the same signature as $\mathsf{F}$.
We have that
\[
\mathsf{F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}
= Pair^{\wedge}(F_1\,G\,\ol{B})(F_2\,G\,\ol{B})(F_1^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}) (F_2^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B})}
\]
By inductive hypothesis, there exist morphisms of predicates
\begin{gather*}
\mathsf{p_1 : PredMap\,(F_1\,G\,\ol{B})\,((F_1)^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}) ((F_1)^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B})} \\
\mathsf{p_2 : PredMap\,(F_2\,G\,\ol{B})\,((F_2)^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}) ((F_2)^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B})}
\end{gather*}
Thus, we define $\mathsf{p (x_1, x_2) (liftF_1, liftF_2) = (p_1\,x_1\,liftF_1, p_2\,x_2\,liftF_2)}$ 
for 
$\mathsf{x_1 : F_1\,G\,\ol{B}}$,
$\mathsf{liftF_1 : F_1^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}\,x_1}$,
$\mathsf{x_2 : F_2\,G\,\ol{B}}$
and $\mathsf{liftF_2 : F_2^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}\,x_2}$.
%%%
\item Case $\mathsf{F = F_1 + F_2}$ where $\mathsf{F_1}$ and $\mathsf{F_2}$ have the same signature as $\mathsf{F}$.
Analogous to case $\mathsf{F = F_1 \times F_2}$.
%%%
\item Case $\mathsf{F = F_1 \to F_2}$
where $\mathsf{F_1}$ does not contain the recursive variable,
i.e., $\mathsf{F_1 : Set^\beta \to Set}$,
and $\mathsf{F_2}$ has the same signature as $\mathsf{F}$.
We have that
\[
\mathsf{F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}\,x = \forall (z : F_1\,\ol{B}) \to F_1^{\wedge}\,\ol{B}\,\ol{Q_B}\,z \to F_2^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}\,(x\,z)}
\]
where $\mathsf{x : F\,G\,\ol{B} = F_1\,\ol{B} \to F_2\,G\,\ol{B}}$.
By inductive hypothesis, there exist a morphism of predicates
\[
\mathsf{p_2 : PredMap\,(F_2\,G\,\ol{B}) (F_2^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}) (F_2^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B})}
\]
Thus, we define $\mathsf{p\,x\,liftF : F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}\,x}$
for $\mathsf{liftF : F^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}\,x}$
as $\mathsf{p\,x\,liftF\,z\,liftF_1 = p_2 (x\,z) (liftF\,z\,liftF_1)}$
for $\mathsf{z : F_1\,\ol{B}}$
and $\mathsf{liftF_1 : F_1^{\wedge}\,\ol{B}\,\ol{Q_B}\,z}$.
Notice that $\mathsf{F_1}$ not containing the recursive variable
is a necessary restriction, as the proof relies on
$\mathsf{F^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}\,x}$
and $\mathsf{F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}\,x}$
having the same domain $\mathsf{F_1^{\wedge}\,\ol{B}\,\ol{Q_B}\,z}$.
%%%
\item Case $\mathsf{F\,G\,\ol{B} = G(F'\,\ol{B})}$
where $\mathsf{F'}$ does not contain the recursive variable,
i.e., $\mathsf{F' : Set^\beta \to Set}$.
Thus, $\mathsf{F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B} = P (F'\,\ol{B}) (F'^{\wedge}\,\ol{B}\,\ol{Q_B})}$.
So, $\mathsf{p}$ is defined as
\[
\mathsf{p = dIndG\,P\,cc\,(F'\,\ol{B})\,(F'^{\wedge}\,\ol{B}\,\ol{Q_B})}
\]
%for $\mathsf{L_F : F^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}\,x}$.
%Note that the fact that the type constructor $\mathsf{F'}$ does not contain the recursive variable
%means that $\mathsf{G}$ does not feature nesting.
%As explained and exemplified in Section~\ref{sec:GADT-nested},
%that assumption is required to make induction work.
%%%
\item Case $\mathsf{F\,G\,\ol{B} = H\,\ol{B}}$
where $\mathsf{H}$ is a $\mathsf{\beta}$-ary type constructor not containing the recursive variable,
i.e., $\mathsf{H : Set^\beta \to Set}$.
In such case, $\mathsf{p : PredMap (H\,\ol{B}) (H^{\wedge}\,\ol{B}\,\ol{Q_B}) (H^{\wedge}\,\ol{B}\,\ol{Q_B})}$
is just the identity morphism of predicates.
%%%
\item Case $\mathsf{F\,G\,\ol{B} = H (\ol{F_k\,G\,\ol{B}})}$
where $\mathsf{H}$ is a $\mathsf{\gamma}$-ary type constructor not containing the recursive variable,
i.e., $\mathsf{H : Set^\gamma \to Set}$,
and $\mathsf{F_k}$ has the same signature as $\mathsf{F}$, for every $\mathsf{k = 1 \dots \gamma}$.
Moreover, we assume that $\mathsf{H}$ has an associated predicate-lifting function,
\[
\mathsf{H^{\wedge} : \forall (\ol{C : Set}) \to (\ol{C \to Set}) \to H\,\ol{C} \to Set}
\]
and that this predicate-lifting function has a map function $\mathsf{HLMap}$ of type
\[
\mathsf{\forall (\ol{C : Set}) (\ol{Q_C\;Q_C' : C \to Set}) \to PredMap\,\ol{C}\,\ol{Q_C}\,\ol{Q_C'}
\to PredMap\,(H\,\ol{C})\,(H^{\wedge}\,\ol{C}\,\ol{Q_C})\,(H^{\wedge}\,\ol{C}\,\ol{Q_C'})}
\]
That means that $\mathsf{H}$ cannot be a GADT,
as GADTs have no functorial semantics~\cite{jgj21}.
and incur in the issue exposed in Section~\ref{sec:GADT-nested},
but it can be an ADT or even a nested type as those types have functorial semantics~\cite{jp19,jgj21}.
Thus,
\[
\mathsf{F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B} = H^{\wedge} (\ol{F_k\,G\,\ol{B}}) (\ol{F_k^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}})}
\]
By induction hypothesis, there is a morphism of predicates
\[
\mathsf{p_k : PredMap\,(F_k\,G\,\ol{B}) (F_k^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}) (F_k^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B})}
\]
for every $\mathsf{k = 1 \dots \gamma}$.
So, $\mathsf{p}$ is defined as
\[
\mathsf{p
= HLMap\,(\ol{F_k\,G\,\ol{B}}) (\ol{F_k^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}}) (\ol{F_k^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}})\,\ol{p_k}}
\]
\end{itemize}
%Notice that, by proceeding by structural induction as above,
%we have implicitly defined a grammar for GADTs admitting an induction rule.
%In particular, we allow $\mathsf{F}$ to feature sums, products, arrow types and (limited) type application.



\section{Induction for GADTs with nesting}\label{sec:GADT-nested}

%%% Change title: something about the inherent limitations of the method
%%% we might want to extend previous result
%%% but we cannot so we already have the best possible result

In the previous sections,
we derive induction rules for examples of GADTs that do not feature nesting,
in the sense that their constructors contain no nested calls of the recursive variable,
as truly nested types (such as $\mathsf{Bush}$, Equation~\ref{eq:bush}) do.
Since both nested types
and GADTs without nesting admit induction rules,
as seen in the previous sections,
it is just natural to expect that GADTs with nesting would as well.
Surprisingly, that is not the case:
indeed, the induction principle generally relies on (unary) parametricity of the semantic interpretation,
and in the case of nested types it also relies on functorial semantics~\cite{jp20},
but GADTs cannot admit both functorial and parametric semantics at the same time~\cite{jgj21}.
In this section we show how induction for GADTs featuring nesting goes wrong
by analyzing the following concrete example of such a type.
\begin{equation}\label{gadt-nested}
\begin{array}{l}
\mathsf{data\, G\,(a : Set) : Set\,where}\\
\mathsf{\;\;\;\;\;\;C :\, G(G\,a) \to G(a \times a)}
\end{array}
\end{equation}
The constructor $\mathsf{C}$ can be rewritten as
\[
\mathsf{C : \exists (b : Set) \to Equal\,a\,(b \times b) \to G(G\,b) \to G\,a}
\]
which is the form we shall use from now on.
The predicate-lifting function of $\mathsf{G}$,
\[
\mathsf{G^{\wedge} : \forall (a : Set) \to (a \to Set) \to G\,\ol{a} \to Set}
\]
is defined as
\[
\mathsf{G^{\wedge}\,a\,Q_a\,(C\,b\,e\,x)
= \exists (Q_b : b \to Set)
\to Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e
\times G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x}
\]
where $\mathsf{Q_a : a \to Set}$, $\mathsf{e : Equal\,a\,(b \times b)}$ and $\mathsf{x : G(G\,b)}$.
Finally, let $\mathsf{CC}$ be the function
\begin{multline*}
\mathsf{\lambda (P : \forall (a : Set) \to (a \to Set) \to G\,a \to Set)} \\
\mathsf{\to \forall (a\;b : Set) (Q_a : a \to Set) (Q_b : b \to Set) (e : Equal\,a\,(b \times b)) (x : G\,(G\,b))} \\
\mathsf{\to Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e
	\to P\,(G\,b)\,(P\,b\,Q_b)\,x
	\to P\,a\,Q_a\,(C\,b\,e\,x)}
\end{multline*}
associated to the $\mathsf{C}$ constructor.

The induction rule for $\mathsf{G}$ is
\begin{multline*}
\mathsf{\forall (P : \forall (a : Set) \to (a \to Set) \to G\,a \to Set) \to CC\,P} \\
\mathsf{\to \forall (a : Set)(Q_a : a \to Set)(y : G\,a) \to G^{\wedge}\,a\,Q_a\,y \to P\,a\,Q_a\,y}
\end{multline*}
Consistently with the previous examples,
to validate the induction rule
we try to define a term of the above type, $\mathsf{DIG}$, as
\[
\mathsf{DIG\,P\,cc\,a\,Q_a\,(C\,b\,e\,x)\,(Q_b, L_E, L_G)
= cc\,a\,b\,Q_a\,Q_b\,e\,x\,L_E\,p}
\]
where $\mathsf{cc : CC\,P}$ and
\begin{itemize}
\item $\mathsf{C\,b\,e\,x : G\,a}$,
i.e., $\mathsf{e : Equal\,a\,(b \times b)}$ and $\mathsf{x : G(G\,b)}$;
\item $\mathsf{(Q_b, L_E, L_G) : G^{\wedge}\,a\,Q_a\,(C\,b\,e\,x)}$,
i.e., $\mathsf{Q_b : b \to Set}$, $\mathsf{L_E : Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e}$,
and $\mathsf{L_G : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x}$.
\end{itemize}
We still need to define $\mathsf{p : P\,(G\,b)\,(P\,b\,Q_b)\,x}$.
We do so by using the induction rule and letting
\[
\mathsf{p = DIG\,P\,cc\,(G\,b)\,(P\,b\,Q_b)\,x\,q}
\]
where we still need to provide $\mathsf{q : G^{\wedge}\,(G\,b)\,(P\,b\,Q_b)\,x}$.
If we had the map function of $\mathsf{G^{\wedge}}$,
\[
\mathsf{GLMap : \forall (a : Set) (Q_a\;Q_a' : a \to Set) \to PredMap\,a\,Q_a\,Q_a' \to PredMap\,(G\,a)\,(G^{\wedge}\,a\,Q_a)\,(G^{\wedge}\,a\,Q_a')}
\]
then we would be able to define
\[
\mathsf{q = GLMap\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,(P\,b\,Q_b)\,(DIG\,P\,cc\,b\,Q_b)\,x\,L_G}
\]
Unfortunately, we cannot define such a $\mathsf{GLMap}$.
Indeed, its definition would have to be
\[
\mathsf{GLMap\,a\,Q_a\,Q_a'\,M\,(C\,b\,e\,x)\,(Q_b, L_E, L_G) = (Q_b', L_E', L_G')}
\]
where $\mathsf{Q_a : a \to Set}$, $\mathsf{Q_a' : a \to Set}$,
$\mathsf{M : PredMap\,a\,Q_a\,Q_a'}$,
$\mathsf{C\,b\,e\,x : G\,a}$, i.e.,
\begin{itemize}
\item $\mathsf{e : Equal\,a\,(b \times b)}$;
\item $\mathsf{x : G\,(G\,b)}$;
\end{itemize}
$\mathsf{(Q_b, L_E, L_G) :G^{\wedge}\,a\,Q_a\,(C\,b\,e\,x)}$, i.e.,
\begin{itemize}
\item $\mathsf{Q_b : b \to Set}$;
\item $\mathsf{L_E : Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e}$;
\item $\mathsf{L_G : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x}$;
\end{itemize}
and $\mathsf{(Q_b', L_E', L_G') : G^{\wedge}\,a\,Q_a'\,(C\,b\,e\,x)}$, i.e.,
\begin{itemize}
\item $\mathsf{Q_b' : b \to Set}$;
\item $\mathsf{L_E' : Equal^{\wedge}\,a\,(b \times b)\,Q_a'\,(Pair^{\wedge}\,b\,b\,Q'_b\,Q'_b)\,e}$;
\item $\mathsf{L_G' : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b')\,x}$;
\end{itemize}
%\begin{gather*}
%\mathsf{Q_a\;Q_a' : a \to Set} \\
%\mathsf{Q_b\;Q_b' : b \to Set} \\
%%\mathsf{M : PredMap\,b\,Q_a\,Q_a'} \\
%\mathsf{L_E : Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e} \\
%\mathsf{L_G\ : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x} \\
%\mathsf{L_E' : Equal^{\wedge}\,a\,(b \times b)\,Q_a'\,(Pair^{\wedge}\,b\,b\,Q'_b\,Q'_b)\,e} \\
%\mathsf{L_G' : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b')\,x}
%\end{gather*}
In other words, we have a proof $\mathsf{L_E}$ of the (extensional) equality
of the predicates $\mathsf{Q_a}$ and $\mathsf{Pair^{\wedge}\,b\,b\,Q_b\,Q_b}$
and a morphism of predicates $\mathsf{M}$ from $\mathsf{Q_a}$ to $\mathsf{Q_a'}$,
and we need to use those to deduce a proof of the (extensional) equality
of the predicates $\mathsf{Q_a'}$ and $\mathsf{Pair^{\wedge}\,b\,b\,Q_b'\,Q_b'}$,
for some  for some predicate $\mathsf{Q_b'}$ on $\mathsf{b}$.
But that is not generally possible:
the facts that $\mathsf{Q_a}$ is equal to $\mathsf{Pair^{\wedge}\,b\,b\,Q_b\,Q_b}$
and that there is a morphism of predicates $\mathsf{M}$ from $\mathsf{Q_a}$ to $\mathsf{Q_a'}$
do not guarantee that $\mathsf{Q_a'}$ is equal to $\mathsf{Pair^{\wedge}\,bb\,Q_b'\,Q_b'}$ for some $\mathsf{Q_b'}$.

At a deeper level, the fundamental issue is that
the $\mathsf{Equal}$ type does not have functorial semantics,
so that having morphisms $\mathsf{A \to A'}$ and $\mathsf{B \to B'}$
and a proof that $\mathsf{A}$ is equal to $\mathsf{A'}$
does not provide a proof that $\mathsf{B}$ is equal to $\mathsf{B'}$.
This is because GADTs can either have a syntax-only semantics or a functorial-completion semantics.
Since we are interested in induction rules, we considered the syntax-only semantics,
which is parametric but not functorial.
Had we considered the functorial-completion semantics, which is functorial,
we would have forfeited parametricity instead.
In both cases, thus, we cannot derive an induction rule for GADTs featuring nesting.
Unlike nestes types, indeed, GADTs do not admit a semantic interpretation that is both parametric and functorial~\cite{jgj21}.



\section{Applications}

{\color{red} Can get rid of Maybe using non-empty lists and postulates}

In this section we use deep induction for the $\mathsf{LTerm}$ GADT to 
extract the type from a lambda term. 
We have a predicate 
\begin{align*}
  &\mathsf{getType : \forall \, (a : Set) \to (t : LTerm\,a) \to Set} \\
  &\mathsf{getType \,a \,t = Maybe \, (LType \, a)}
\end{align*}
that takes a lambda term and produces its type (using $\mathsf{Maybe}$ to represent
potential failure).
We want to show this predicate is satisfied for every element of $\mathsf{LTerm\,a}$.
Because of the $\mathsf{ListC}$ constructor, this cannot be achieved without 
deep induction. In particular, deep induction is required to apply the induction to the 
individual terms in a list of terms. 

So, using deep induction, we want to prove: 
\[
  \mathsf{getTypeProof : \forall \, (a : Set) \to (t : LTerm\,a) \to getType \,a \,t} \\
\]
which we prove by 
\[
  \mathsf{getTypeProof \,a \,t = 
    DILTerm\, (\lambda \, b\, Q_b\, t\, \to getType \,b\, t) \,
    gtVar\,  gtABs\,  gtApp\,  gtListC\,  a\,\, K1\,\, t\, (LTerm^{\wedge}K1\, a\, t)
    }
\]
where $\mathsf{K1 : a \to Set}$ is the constantly true predicate:
\[
  \mathsf{K1 \, x = \top}
\]
and $\mathsf{LTerm^{\wedge}K1\, a\, t : LTerm^{\wedge}\, a\, K1\, t}$.
Notice that there is no space in $\mathsf{LTerm^{\wedge}K1}$, because
\[
  \mathsf{LTerm^{\wedge}K1 : \forall (a : Set) (t : LTerm A) \to LTerm^{\wedge}\, a\, K1\,t}
\]
is a function that we will define. In addition to defining $\mathsf{LTerm^{\wedge}K1}$,
we also have to give a proof for each constructor $\mathsf{Var, Abs, App, ListC}$:
\begin{multline*}
  \mathsf{gtVar : \forall (a : Set) (Q_a : a \to Set) (s : String) (T_a : LType\, a) 
      \to LType^{\wedge} \, a\, Q_a\, T_a\, \to Maybe\, (LType\, a)}
\end{multline*}

% abs 
\begin{multline*}
    \mathsf{gtAbs : \forall (a \, b\, c: Set) (Q_a : a \to Set) (Q_b : b \to Set) (Q_c : c \to Set) 
      (e : Equal\, a\, (b \to c)) (s : String)} \\ 
    %
    \mathsf{ (T_b : LType\, b) (t_c : LTerm \, c)
      \to Equal^{\wedge}\, a\, (b \to c)\, Q_a\, (Arr^{\wedge}\, b\, c\, Q_b\, Q_c)\, e
      \to LType^{\wedge} \, b\, Q_b\, T_b} \\ 
    %
    \mathsf{
      \to Maybe\, (LType\,c) \to Maybe\, (LType\, a)}
\end{multline*}

% app 
\begin{multline*}
    \mathsf{gtApp : \forall (a \, b : Set) (Q_a : a \to Set) (Q_b : b \to Set) 
      (t_{ba} : LTerm\, (b \to a)) (t_b : LTerm\, b)} \\ 
    \mathsf{
      \to Maybe\, (LType\, (b \to a))
      \to Maybe\, (LType\, b)
      \to Maybe\, (LType\, a)
    }
\end{multline*}


% list 
\begin{multline*}
    % abs
    \mathsf{gtListC : \forall (a \, b : Set) (Q_a : a \to Set) (Q_b : b \to Set) 
      (e : Equal\, a\, (List\, b)) (ts : List\, (LTerm\, b))} \\ 
    \mathsf{
      \to Equal^{\wedge}\, a\, (List\,b) \, Q_a\, (List^{\wedge}\, b\, Q_b)\, e
      \to List^{\wedge}\, (LTerm\, b)\, (getType\, b)\, ts
      \to Maybe\, (LType\, a)
    }
\end{multline*}


For variables we simply return the type $\mathsf{T_a}$, 
and the cases for abstraction and application are similar.
The interesting case is $\mathsf{gtListC}$, in which we have to use 
the results of ($\mathsf{List^{\wedge}\, (LTerm\, b)\, (getType\, b)\, ts}$)
in order to extract the type of one of the terms in the list. 
To define $\mathsf{gtListC}$ we pattern-match on the list of terms $\mathsf{ts}$.  

If $\mathsf{ts}$ is the empty list (denoted by $\mathsf{[]}$), we cannot extract a type, 
so we return $\mathsf{nothing}$. \\
{\color{red} Maybe handle this case differently, by using non-empty lists, for example}
\[
  \mathsf{gtListC\, a\, b\, Q_a\, Q_b\, e\, [] \, L_e L_{ts} = nothing}
\]
If $\mathsf{ts}$ is a non-empty list, we pattern match on $\mathsf{L_{ts}}$ and use the result
to construct the type we need:
\begin{align*}
  &\mathsf{gtListC\, a\, b\, Q_a\, Q_b\, e\, (t :: ts) \, L_e (nothing , L_{ts}) = nothing} \\
  &\mathsf{gtListC\, a\, b\, Q_a\, Q_b\, e\, (t :: ts) \, L_e (just\, T_b , L_{ts}) = just \, (TList\, b\, e\, T_b)}
\end{align*}
where $\mathsf{e : Equal\, a\, (List\,b)}$ and $\mathsf{T_b : LType\, b}$. 

\subsection{Defining $\mathsf{LTerm^{\wedge}K1}$}

{\color{red} Maybe this section can be deleted by assuming $\mathsf{LTerm^{\wedge}\, a\, K1\,t = K1}$.
Maybe we can say this derives from parametricity.
Currently we say that $\mathsf{K1 \times K1 = K1}$ based on the fact that products are a built-in type and so this seems to be obviously true.}

The last piece of infrastructure we need to define $\mathsf{getTypeProof}$ is a function 
\[
  \mathsf{LTerm^{\wedge}K1 : \forall (a : Set) \to (t : LTerm A) \to LTerm^{\wedge}\, a\, K1\,t}
\]
that provides a 
proof of $\mathsf{LTerm^{\wedge}\,a\,K1\,t}$ for any term $\mathsf{t : LTerm\, a}$. 
Because $\mathsf{LTerm^{\wedge}}$ is defined in terms of $\mathsf{LType^{\wedge}}$, $\mathsf{Arr^{\wedge}}$, 
and $\mathsf{List^{\wedge}}$, we will need analogous functions for these liftings as well. 
We only give the definition of $\mathsf{LTerm^{\wedge}K1}$, but the definitions for 
$\mathsf{LType^{\wedge}}$, $\mathsf{Arr^{\wedge}}$, and $\mathsf{List^{\wedge}}$ are analogous. 

$\mathsf{LTerm^{\wedge}K1}$ is defined by pattern matching on the lambda term $\mathsf{t}$. 
For the $\mathsf{Var}$ case, let $\mathsf{t = (Var\, s\, T_a)}$ and define
\[
  \mathsf{LTerm^{\wedge}K1\,a\,(Var\,s\,T_a) = LType^{\wedge}K1\,a\,T_a}
\]
For the $\mathsf{Abs}$ case, let $\mathsf{t = (Abs \,b \,c \, e \,s \,T_b \, t_c)} $ and recall the 
definition of $\mathsf{LTerm^{\wedge}}$ for the $\mathsf{Abs}$ constructor, 
instantiating the predicate $\mathsf{Q_a}$ to $\mathsf{K1}$: 
% \,a\,Q_a\, (Abs \,b \,c \,e \,s \,T_b \,t_c)}$, :
\begin{multline*}
  \mathsf{LTerm^{\wedge}\,a\,K1\,
  (Abs \,b \,c \,e \,s \,T_b \,t_c)} \\ 
\mathsf{
  = \exists (Q_b : b \to Set) (Q_c : c \to Set) \to
      Equal^{\wedge} \, a\, (b \to c)\, K1\, (Arr^{\wedge} \, b\, c\, Q_b \, Q_c)\, e} \\ 
\mathsf{
      \times \, LType^{\wedge}\, b\, Q_b\, T_b
      \times \, LTerm^{\wedge}\, c\, Q_c\, t_c }
\end{multline*}
so to define the $\mathsf{Abs}$ case of $\mathsf{LTerm^{\wedge}K1}$, we need a proof of 
\[
  \mathsf{Equal^{\wedge} \, a\, (b \to c)\, K1\, (Arr^{\wedge} \, b\, c\, Q_b \, Q_c)\, e}
\]
i.e., that $\mathsf{K1}$ is (extensionally) equal to the lifting $\mathsf{(Arr^{\wedge} \, b\, c\, Q_b \, Q_c)}$
for some predicates $\mathsf{Q_b, Q_c}$. The only reasonable choice for $\mathsf{Q_b}$ and $\mathsf{Q_c}$ 
is to let both be $\mathsf{K1}$, which means we need a proof of:
\[
  \mathsf{Equal^{\wedge} \, a\, (b \to c)\, K1\, (Arr^{\wedge} \, b\, c\, K1 \, K1)\, e}
\]
Since we are working with proof-relevant predicates (i.e., functions into $\mathsf{Set}$ rather than 
functions into $\mathsf{Bool}$), 
the lifting $\mathsf{(Arr^{\wedge} \, b\, c\, K1 \, K1)}$ of $\mathsf{K1}$ to arrow types
is not identical to $\mathsf{K1}$ on arrow types, but the predicates are (extensionally) isomorphic. 
We discuss this issue in more detail at the end of the section. 
For now, we assume a proof 
\[
  \mathsf{Equal^{\wedge}ArrK1 : Equal^{\wedge} \, a\, (b \to c)\, K1\, (Arr^{\wedge} \, b\, c\, K1 \, K1)\, e}
\]
and define the $\mathsf{Abs}$ case of $\mathsf{LTerm^{\wedge}K1}$ as 
\[
  \mathsf{LTerm^{\wedge}K1\,a\, (Abs \,b \,c \, e \,s \,T_b \, t_c) = 
    (K1 , K1 , Equal^{\wedge}ArrK1 , LType^{\wedge}K1 \,b\,T_b\, , LTerm^{\wedge}K1\,c\,t_c)
  }
\]
For the $\mathsf{App}$ case, let $\mathsf{t = (App \,b \,\,t_{ba} \, t_b)}$ and just as we did for the $\mathsf{Abs}$ case, 
recall the definition of $\mathsf{LTerm^{\wedge}\,a\,(App \,b \,\,t_{ba} \, t_b)}$ with all of the predicates
instantiated with $\mathsf{K1}$: 
\[
\mathsf{
      LTerm^{\wedge}\, (b \to a)\, (Arr^{\wedge} \, b\, a\, K1 \, K1)\, t_{ba}
      \times LTerm^{\wedge}\, b\, K1\, t_b }
\]
The second component can be given using $\mathsf{LTerm^{\wedge}K1}$, and we can 
define the first component using a proof of
\[
\mathsf{LTerm^{\wedge}\, (b \to a)\, K1\,\, t_{ba}}
\]
and a map-like function 
\begin{multline*}
  \mathsf{LTerm^{\wedge}EqualMap : \forall\, \{a : Set\} \to (Q_a\,Q'_a : a \to Set) 
    \to (Equal^{\wedge}\,a\,a\,Q_a\,Q'_a\,rfl)} \\
    \mathsf{
    \to PredMap\, (LTerm^{\wedge}\,a\,Q_a)\,(LTerm^{\wedge}\,a\,Q'_a)}
\end{multline*}
that takes two (extensionally) equal predicates with the same carrier 
and produces a morphism of predicates between their liftings. The definition is 
straightforward enough, so we omit the details. 
But it is worth noting that while a true $\mathsf{HLMap}$ function, 
which takes a \emph{morphism} of predicates instead of a proof of equality, cannot be defined 
for GADTs in general, an analogue of $\mathsf{LTerm^{\wedge}EqualMap}$ should be definable 
for every GADT. These analogues of $\mathsf{LTerm^{\wedge}EqualMap}$ will be required to define 
$\mathsf{G^{\wedge}K1}$ whenever $\mathsf{G}$ has a constructor of the form
  ($\mathsf{c : G \, (F\, b) \to G\,(K\,b)}$).

Using $\mathsf{LTerm^{\wedge}EqualMap}$, we can define the $\mathsf{App}$ case of $\mathsf{LTerm^{\wedge}K1}$ as 
\[
  \mathsf{LTerm^{\wedge}K1\,a\, (App \,b \,\,t_{ba} \, t_b) = 
    (K1 , L_{Arr^{\wedge}\,K1} , LTerm^{\wedge}K1\,b\,t_b)}
\]
where $\mathsf{ L_{Arr^{\wedge}\,K1} : LTerm^{\wedge}\, (b \to a)\, (Arr^{\wedge} \, b\, a\, K1 \, K1)\, t_{ba}}$ is defined as
\[
  \mathsf{L_{Arr^{\wedge}\,K1} =  LTerm^{\wedge}EqualMap\,K1\,(Arr^{\wedge}\,b\,a\,K1\,K1)\,\, Equal^{\wedge}ArrK1\, \,\,t_{ba}\, \,L_{K1}}
\]
where $\mathsf{L_{K1} = LTerm^{\wedge}K1\, (b \to a)\, t_{ba} : LTerm^{\wedge}\, (b \to a) \, K1\, t_{ba}}$.

Finally, we define the $\mathsf{ListC}$ case for $\mathsf{LTerm^{\wedge}K1}$. 
Let $\mathsf{t = (ListC\, b\, e\, ts)}$ and recall the definition of $\mathsf{LTerm^{\wedge}\,a\,(ListC\, b\, e\, ts)}$ with
all of the predicates instantiated to $\mathsf{K1}$: 
\[
\mathsf{ Equal^{\wedge} \, a\, (List\,b)\, K1\, (List^{\wedge} \, b\, K1) \, e
      \times List^{\wedge}\, (LTerm\,b) \, (LTerm^{\wedge} \, b\, K1) \, ts }
\]
We can give the first component by assuming a proof \,
$\mathsf{Equal^{\wedge}ListK1 : Equal^{\wedge} \, a\, (List\,b)\, K1\, (List^{\wedge} \, b\, K1) \, e}$, 
but for the second component we again have multiple liftings nested together. In this case, we can 
get a proof of
\[
\mathsf{ List^{\wedge}\, (LTerm\,b) \, (LTerm^{\wedge} \, b\, K1) \, ts }
\]
using 
\[\mathsf{List^{\wedge}map : \forall\, (a : Set) \to (Q_a \, Q'_a : a \to Set) 
  \to PredMap\,Q_a\,Q'_a \to PredMap \,(List^{\wedge}\, a\, Q_a)\, (List^{\wedge}\, a\, Q'_a)}\]
to map a morphism of predicates 
\[
  \mathsf{PredMap \, (K1)\, (LTerm^{\wedge}\,b\,K1)}
\]
to a morphism of lifted predicates
\[
  \mathsf{PredMap \,(List^{\wedge}\,(LTerm\,b)\,K1) \, (List^{\wedge}\,(LTerm\,b)\, (LTerm^{\wedge}\,b\,K1))}
\]

We define the $\mathsf{ListC}$ case of $\mathsf{LTerm^{\wedge}K1}$ as 
\[
  \mathsf{LTerm^{\wedge}K1\,a\, (ListC\, b\, e\, ts) =
    (K1 , \, Equal^{\wedge}ListK1 , \,  L_{List^{\wedge}LTerm^{\wedge}K1} ) }
\]
where
 $\mathsf{L_{List^{\wedge}LTerm^{\wedge}K1} : List^{\wedge}\, (LTerm\,b) \, (LTerm^{\wedge} \, b\, K1) \, ts}$
\[
  \mathsf{ 
 L_{List^{\wedge}LTerm^{\wedge}K1} =
  List^{\wedge}map \, (LTerm\,b) \, K1 \, (LTerm^{\wedge}\, b\, K1) \, m_{K1} \, ts \, (List^{\wedge}K1\, (LTerm\, b)\, ts)
    }
\]
and 
 $\mathsf{m_{K1} : PredMap \, (K1)\, (LTerm^{\wedge}\,b\,K1)}$
\[
  \mathsf{m_{K1} \, t\, \ast\, = LTerm^{\wedge}K1\, b\, t}
\]
where $\mathsf{\ast}$ is the single element of $\mathsf{(K1\, t)}$. 
The use of $\mathsf{List^{\wedge}map}$ is required in the $\mathsf{ListC}$ case because 
$\mathsf{ListC}$ takes an argument of type $\mathsf{List\, (LTerm\, b)}$. 
The same technique can be used to define $\mathsf{G^{\wedge}K1}$ whenever $\mathsf{G}$ has 
a constructor of the form ($\mathsf{c : F \, (G\, a) \to G\, (K\,b)}$). 
We only allow constructors of this form when 
$\mathsf{F}$ is a nested type or ADT, so we are guaranteed to have a $\mathsf{F^{\wedge}map}$ function. 


\subsection{Liftings of $\mathsf{K1}$}
To provide a proof of $\mathsf{G^{\wedge}\, a\, K1 \, t}$ for every term $\mathsf{t : G\, a}$, 
we need to know that the lifting of $\mathsf{K1}$ by a type $\mathsf{H}$ is extensionally equal to $\mathsf{K1}$ on $\mathsf{H}$. 
For example, we might need a proof that $\mathsf{Pair^{\wedge}\,a\,b\,K1\,K1}$ is equal to the predicate $\mathsf{K1}$ on pairs. 
Given a pair $\mathsf{(x , y) : a \times b}$, we have 

\begin{align*}
  &\mathsf{Pair^{\wedge}\,a\,b\,K1\,K1 (x, y)}  \\
  = \, \, &\mathsf{K1 \, x \times K1\, y} \\ 
  = \, \, &\mathsf{\top \times \top}
\end{align*}
while 
\begin{align*}
 \mathsf{K1\, (x, y) = \top}
\end{align*}
and while these types are not equal they are clearly isomorphic. So for simplicity of presentation, we 
assume ($\mathsf{F^{\wedge}\,a\,K1}$) is equal to $\mathsf{K1}$ for every nested type and ADT $\mathsf{F}$. 

%\section{Primitive representation for GADTs}




\section{Conclusion/Related work}

Mention Patricia/Neil2008 paper

No induction with primitive representation (reference Haskell Symposium paper and~\cite{jp19} and paper Patricia Neil Clement 2010)


\section{TODO}

\begin{itemize}
\item find correct entcsmacro file (current one is for 2018). Maybe ask Ana Sokolova (anas@cs.uni-salzburg.at).
\item reference (correctly) Haskell Symposium paper
\item reference inspiration for STLC GADT : https://www.seas.upenn.edu/~cis194/spring15/lectures/11-stlc.html
\end{itemize}

\begin{thebibliography}{10}\label{bibliography}

\bibitem{atk12} Atkey, R.  {\em Relational parametricity for higher
  kinds}.  Computer Science Logic, pp.~46-61, 2012.

\bibitem{bfss90} Bainbridge, E. S., Freyd, P. Scedrov, A., and Scott,
  P. J. {\em Functorial polymorphism}. Theoretical Computer Science
  70(1), pp. 35-64, 1990.

\bibitem{bm98} Bird, R. and Meertens, L. {\em Nested
  datatypes}. Proceedings, Mathematics of Program Construction,
  pp. 52–67, 1998.

\bibitem{ch03} Cheney, J. and Hinze, R. {\em First-class phantom
 types}. CUCIS TR2003-1901, Cornell University, 2003.

\bibitem{ch88} Coquand, T. and Huet, G. {\em The calculus of
  constructions}. Information and Computation 76(2/3), 1988.

\bibitem{chl} Chlipala, A. {\em Library Inductive
  Types}. $\mathtt{http://adam.chlipala.net/cpdt/html/InductiveTypes.html}$

\bibitem{coq20} The Coq Development Team. {\em The Coq Proof
  Assistant}, version 8.11.0, January 2020.
  $\mathtt{https://doi.org/10.5281/zenodo.3744225}$

\bibitem{gjfor15} Ghani, N., Johann, P., Nordvall Forsberg, F.,
  Orsanigo, F., and Revell, T. {\em Bifibrational functorial semantics
    for parametric polymorphism}. Proceedings, Mathematical
  Foundations of Program Semantics, pp. 165-181, 2015.

\bibitem{hin03} Hinze, R. {\em Fun with phantom types}. Proceedings,
 The Fun of Programming, pp. 245–262, 2003.

\bibitem{jgj21f} Johann, P., Ghiorzi, E., and Jeffries, D. {\em
  Parametricity for primitive nested types}. Proceedings, Foundations
  of Software Science and Computation Structures, pp. 324-343, 2021.

\bibitem{jgj21} Johann, P., Ghiorzi, E., and Jeffries, D. {\em
  Parametricity in the presence of GADTs}. Submitted, 2021.

\bibitem{jp19} Johann, P. and Polonsky, A. {\em Higher-kinded data
  types: Syntax and semantics} Proceedings, Logic in Computer Science
  2019. {\color{red} PAGES?}

\bibitem{jp20} Johann, P. and Polonsky, A. {\em Deep induction:
  Induction rules for (truly) nested types}.  Proceedings, Foundations
  of Software Science and Computation Structures, pp. 339-358, 2020.

\bibitem{mac71} MacLane, S. {\em Catgories for the Working
  Mathematician}. Springer, 1971.

\bibitem{mcb99} McBride, C. {\em Dependently Typed Programs and their
  Proofs}. PhD thesis, University of Edinburgh, 1999.

\bibitem{min15} Minsky, Y.  {\em Why {GADT}s matter for performance}.
  $\mathtt{https://blog.janestreet.com/why-gadts-matter-for-performance/}$,
  2015.

\bibitem{pl04} Pasalic, E., and Linger, N.  {\em Meta-programming with
  typed object-language representations}.  Generic Programming and
  Component Engineering, pp.~136-167, 2004.

\bibitem{pen20} Penner, C.  {\em Simpler and safer {API} design using
  {GADT}s}.  $\mathtt{https://chrispenner.ca/posts/gadt-design}$,
  2020.

\bibitem{pvww06} Peyton Jones, S., Vytiniotis, D., Weirich, S., and
  Washburn, G. {\em Simple unification-based type inference for
    GADTs}. Proceedings, International Conference on Functional
  Programming, 2006. {\color{red} PAGES?}

\bibitem{pr06} Pottier, F., and R{\'e}gis-Gianas, Y.  {\em Stratified
  type inference for generalized algebraic data types}.  Principles of
  Programming Languages, pp.~232-244, 2006.

\bibitem{sjsv09} Schrijvers, T, Peyton Jones, S. L., Sulzmann, M., and
  Vytiniotis, D. {\em Complete and decidable type inference for
    GADTs}. Proceedings, International Conference on Functional
  Programming, pp. 341– 352, 2009.

\bibitem{sp04} Sheard, T., and Pasalic, E. {\em Meta-programming with
  built-in type equality}. Proceedings, Workshop on Logical Frameworks
  and Meta-languaegs, 2004. {\color{red} PAGES?}

\bibitem{xcc03} Xi, H., Chen, C. and Chen, G. {\em Guarded recursive
  datatype constructors}. Proceedings, Principles of Programming
  Languages, pp. 224–235, 2003.

\bibitem{vw10} Vytiniotis, D., and Weirich, S.  {\em Parametricity,
  type equality, and higher-order polymorphism}.  Journal of
  Functional Programming 20(2), pp.~175--210, 2010.

\end{thebibliography}

\end{document}



