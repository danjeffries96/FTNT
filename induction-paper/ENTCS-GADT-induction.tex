\documentclass[9pt]{entcs}
\usepackage{entcsmacro}
\usepackage{graphicx}
\sloppy
% The following is enclosed to allow easy detection of differences in
% ascii coding.
% Upper-case    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
% Lower-case    a b c d e f g h i j k l m n o p q r s t u v w x y z
% Digits        0 1 2 3 4 5 6 7 8 9
% Exclamation   !           Double quote "          Hash (number) #
% Dollar        $           Percent      %          Ampersand     &
% Acute accent  '           Left paren   (          Right paren   )
% Asterisk      *           Plus         +          Comma         ,
% Minus         -           Point        .          Solidus       /
% Colon         :           Semicolon    ;          Less than     <
% Equals        =3D           Greater than >          Question mark ?
% At            @           Left bracket [          Backslash     \
% Right bracket ]           Circumflex   ^          Underscore    _
% Grave accent  `           Left brace   {          Vertical bar  |
% Right brace   }           Tilde        ~

\bibliographystyle{entcs}

\def\lastname{Johann, Ghiorzi, and Jeffries}

\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage{ccicons}
\usepackage{verbatim}


\usepackage{amscd}
\usepackage{MnSymbol}
\usepackage{xcolor}

\usepackage{bbold}
\usepackage{url}
\usepackage{upgreek}
\usepackage{stmaryrd}

\usepackage{lipsum}
\usepackage{tikz-cd}
\usetikzlibrary{cd}
\usetikzlibrary{calc}
\usetikzlibrary{arrows}

\usepackage{bussproofs}
\EnableBpAbbreviations

\newcommand{\new}[1]{{\color{blue} {#1}}}

\newcommand{\set}{\mathtt{Set}}


\input{macros}




\begin{document}
\begin{frontmatter}
  \title{(Deep) Induction for GADTs}

  \author{Patricia Johann~~~~}%\thanksref{JohannEmail}}
  \author{Enrico Ghiorzi~~~~}%\thanksref{GhiorziEmail}}
  \author{Daniel Jeffries}%\thanksref{JeffriesEmail}}
%  \thanks[JohannEmail]{Email: \href{mailto:johannp@appstate.edu} {\texttt{\normalshape johannp@appstate.edu}}}
%  \thanks[GhiorziEmail]{Email: \href{mailto:ghiorzie@appstate.edu} {\texttt{\normalshape ghiorzie@appstate.edu}}}
%  \thanks[JeffriesEmail]{Email: \href{mailto:jeffriesd@appstate.edu} {\texttt{\normalshape jeffriesd@appstate.edu}}}
  \address{$\mathtt{\{johannp,ghiorzie,jeffriesd\}@appstate.edu}$\\Department of Computer Science, Appalachian State University}

\begin{abstract} 
  Abstract goes here.
\end{abstract}

\begin{keyword}
  Please list keywords from your paper here, separated by commas.
\end{keyword}

\end{frontmatter}

\begin{itemize}
\item Weird to code in Agda if we're talking about induction rules for
  Coq? 
\item Agda style conventions
 \item spacing in data type declarations
\end{itemize}
  
\section{Introduction}\label{sec:intro}

Induction is one of the most important techniques available for
working with advanced data types, so it is both inevitable and
unsurprising that it plays an essential role in modern proof
assistants. In the proof assistant Coq~\cite{coq20}, for example,
functions and predicates over advanced types are defined inductively,
and almost all non-trivial proofs of their properties are either
proved by induction outright or rely on lemmas that are. Every time a
new inductive data type is declared in Coq, an induction rule is
automatically generated for it.

The data types handled by Coq are (possibly mutually inductive)
polynomial ADTs, and the induction rules automatically generated for
them are the expected ones for standard structural induction. It has
long been understood, however, that these rules are too weak to be
genuinely useful for so-called {\em deep ADTs}~\cite{jp20}, i.e., ADTs
that are (possibly mutually inductively) defined in terms of (other)
such ADTs.\footnote{Such data types are called nested inductive types
  by Chlipala~\cite{chl}, reflecting the fact that ``inductive type''
  means ``ADT''~in~Coq.} Consider, for example, the following type of
rose trees, here coded in Agda and defined in terms of the standard
type of lists:
\[\begin{array}{l}
\mathsf{data\, Rose\, : Set \to Set\,where}\\
\mathsf{\;\;\;\;\;\;\;\;empty\, :\, Rose\,A}\\
\mathsf{\;\;\;\;\;\;\;\;node\,\,\,\, :\, A \to List\,(Rose\,A) \to Rose\,A} 
\end{array}\]
\noindent
The induction rule Coq automatically generates for rose trees is
\[\begin{array}{l}
\mathsf{\forall\, (a : \set)\,(P : Rose\,a \to \set) \to P\,empty \to}\\
\mathsf{\hspace*{0.15in}
 (\forall\, (x : a)\,(ts :
  List\,(Rose\,a)) \to P\,(node\,x\,ts)) \to 
  \forall \,(x : Rose\,a) \to P\,x}
\end{array}\]
\noindent
Unfortunately, this is neither the induction rule we intuitively
expect, nor is it expressive enough to prove even basic properties of
rose trees that ought to be amenable to inductive proof. What is
needed here is an enhanced notion of induction that, when specialized
to rose trees, will propagate the predicate $\mathsf{P}$ through the
outer list structure and to the rose trees sitting inside
$\mathsf{node}$'s list argument. More generally, this enhanced notion
of induction should traverse {\em all} of the structure present in a
data type, propagating suitable predicates to {\em all} of the data
contained in the structure. With data types becoming ever more
advanced, and with deeply structured such types becoming ever more
%increasingly
ubiquitous in formalizations, it is critically important that proof
assistants
%like Coq, Agda, and Lean 
be able to automatically generate genuinely useful induction
principles for data types that go well beyond traditional ADTs. Such
data types include (truly) nested types~\cite{bm98}\footnote{A truly
  nested type is a nested type that is defined over itself.},
generalized algebraic data types
(GADTs)~\cite{ch03,pvww06,sp04,xcc03}, more richly indexed
families~\cite{ch88}, and deep variants of all of these.

{\em Deep induction}~\cite{jp20} is a generalization of structural
induction that fits this bill exactly. Whereas structural induction
rules induct over only the top-level structure of data, leaving any
data internal to the top-level structure untouched, deep induction
rules induct over {\em all} of the structured data present. The key
idea is to parameterize induction rules not just over a predicate over
the top-level data type being considered, but also over additional
custom predicates on the types of primitive data they contain. These
custom predicates are then lifted to predicates on any internal
structures containing these data, and the resulting predicates on
these internal structures are lifted to predicates on any internal
structures containing structures at the previous level, and so on,
until the internal structures at all levels of the data type
definition, including the top level, have been so
processed. Satisfaction of a predicate by the data at one level of a
structure is then conditioned upon satisfaction of the appropriate
predicates by {\em all} of the data at the preceding level.

Deep induction was shown in~\cite{jp20} to be the form of induction
most appropriate to nested types (including ADTs) that are defined
over, or mutually recursively with, other such types (including,
possibly, themselves). Deep induction delivers the following genuinely
useful induction rule for rose trees:
\begin{equation}\label{eq:rose}
\begin{array}{l}
\mathsf{\forall \,(a : \set)\,(P : Rose\,a \to \set)\,(Q : a \to \set)
  \to P\,empty \to}\\ 
\mathsf{\hspace*{0.15in}(\forall \,(x : a)\, (ts :
  List\,(Rose\,a))\to Q\,x \to List^\land\,P\,ts \to P\,(node\,x\,ts)) \to}\\
\mathsf{\hspace*{0.15in}\forall \,(x :
  Rose\,a) \to Rose^\land\,Q\, x \to P\,x} 
\end{array}
\end{equation}

\noindent
%Here, $\mathsf{List^\land}$ lifts its predicate argument $\mathsf{P}$
%on data of type $\mathsf{Rose\,a}$ to a predicate on data of type
%$\mathsf{List\,(Rose\,a)}$ asserting that $\mathsf{P}$ holds for every
%element of its argument list, and similarly for the lifting
%$\mathsf{Rose^\land}$ and the predicate $\mathsf{Q}$.
Here, $\mathsf{List^\land}$ (resp., $\mathsf{Rose^\land}$) lifts its
predicate argument $\mathsf{P}$ (resp., $\mathsf{Q}$) on data of type
$\mathsf{Rose\,a}$ (resp., $\mathsf{a}$) to a predicate on data of
type $\mathsf{List\,(Rose\,a)}$ (resp., $\mathsf{Rose\,a}$) asserting
that $\mathsf{P}$ (resp., $\mathsf{Q}$) holds for every element of its
list (resp., rose tree) argument.\footnote{Predicate liftings such as
  $\mathsf{List^\land}$ and $\mathsf{Rose^\land}$ can either be
  supplied as primitives or generated automatically from their
  associated data type definitions as described in
  Section~\ref{sec:ADTs-and-nesteds} below. The predicate lifting for
  a container type like $\mathsf{List\,t}$ or $\mathsf{Rose\,t}$
  simply traverses containers of that type and applies its predicate
  argument pointwise to the constituent data of type $\mathsf{t}$.}
Deep induction was also shown in~\cite{jp20} to
% be the missing piece making it possible to
%be the theretofore missing component needed to
% be the essential ingredient making it possible to
deliver the first-ever induction rules --- structural or otherwise ---
for the $\mathsf{Bush}$ data type~\cite{bm98} and other truly nested
types. Deep induction for ADTs and nested types is reviewed in
Section~\ref{sec:ADTs-and-nesteds} below.

This paper shows how to extend deep induction to proper GADTs, i.e.,
to GADTs that are not simply nested types (and thus are not ADTs).  A
constructor for such a GADT $\mathsf{G}$ may, like a constructor for a
nested type, take as arguments data whose types involve instances of
$\mathsf{G}$ other than the one being defined --- including instances
that involve $\mathsf{G}$ itself. But if $\mathsf{G}$ is a proper GADT
then at least one of its constructors will also have such a structured
instance of $\mathsf{G}$ --- albeit one not involving $\mathsf{G}$
itself --- as its codomain.
%But while the types of the arguments to a GADT's constructor can
%include instances of $\mathsf{G}$ that themselves involve
%$\mathsf{G}$, its return type cannot.
For example, the constructor $\mathsf{pair}$ for the GADT {\color{red}
  Perhaps also show non-inhabitation?}
\begin{equation}\label{eq:seq}
\begin{array}{l}
\mathsf{data\, Seq\,(a : Set) : Set\,where}\\
\mathsf{\;\;\;\;\;\;\;\;const :\, a \to Seq\,a}\\
\mathsf{\;\;\;\;\;\;\;\;\;\;\,pair :\, Seq \,a \to Seq\,b \to
  Seq\,(a \times b)}
\end{array}
\end{equation}
\noindent
of sequences only constructs sequences of pairs, rather than sequences
of arbitrary type, as does $\mathsf{const}$. If all of the
constructors for a GADT $\mathsf{G}$ return structured instances of
$\mathsf{G}$, then some of $\mathsf{G}$'s instances might not be
inhabited. GADTs therefore have two distinct, but equally natural,
semantics: a functorial semantics interpreting them as left Kan
extensions~\cite{mac71}, and a parametric semantics interpreting them
as their Church encodings~\cite{atk12,vw10}. As explained
in~\cite{jgj21}, a key difference in the two semantics is that the
former views GADTs as their {\em functorial completions}~\cite{jp19},
and thus as containing more data than just those expressible in
syntax. By contrast, the latter views them as what might be called
{\em syntax-only} GADTs. Happily, these two views of GADTs coincide
for those that are ADTs or other nested types. However, both they and
their attendant properties differ greatly for proper GADTs. In fact,
the views deriving from the functorial and parametric semantics for
proper GADTs are sufficiently distinct that, by contrast with the
situation for ADTs and other nested
types~\cite{bfss90,gjfor15,jgj21f}, it is not actually possible to
define a functorial parametric semantics for them~\cite{jgj21}.

This observation seems, at first, to be a death knell for the prospect
of extending deep induction to GADTs. Indeed, since induction can be
seen as unary parametricity, we quickly realize that GADTs viewed as
their functorial completions cannot possibly support induction rules.
This makes sense intuitively: induction is a syntactic proof
technique, so of course it cannot be used to prove properties of those
elements of a GADT's functorial completion that are not expressible in
syntax. All is not lost, however. As we show below, the Church
encoding interpretation's syntax-only view does support induction
rules --- including deep induction rules --- for GADTs. Perhaps
surprisingly, ours are the first-ever induction rules --- deep or
otherwise --- for a general class of proper GADTs. But this paper
actually delivers more: it gives a general framework for deriving deep
induction rules for a general class of GADTs directly from their
syntax. This framework can serve as a basis for extending modern proof
assistants' automatic generation of structural induction rules for
ADTs to automatic generation of deep induction rules for GADTs. As
for ADTs and other nested types, the structural induction rule for any
GADT can be recovered from its deep induction rule simply by taking
the custom predicates in its deep induction rule to be constantly
$\mathsf{True}$-valued predicates.

Deep induction rules for GADTs cannot, however, be derived by somehow
extending the techniques of~\cite{jp20} to syntax-only GADTs. Indeed,
the derivation of induction rules given there makes crucial use of the
functoriality of data types' interpretations from~\cite{jp19}, and
that is precisely what the interpretation of GADTs as their Church
encodings fails to deliver. Instead, we first give the (deep)
induction rule and a predicate lifting styled after those
of~\cite{jp20} for the simplest and most important GADT, namely the
$\mathsf{Equality}$ GADT. We then treat any other GADT by writing it
as its so-called {\em Henry Ford
  encoding}~~\cite{ch03,hin03,mcb99,sjsv09,sp04} and using the
predicate liftings for $\mathsf{Equality}$ and any other constituent
data types to appropriately thread the custom predicates through the
structures of the GADT. {\color{red} Significantly, since we are
  treating GADTs as syntax-only, rather than functorial, we cannot
  handle truly nested GADTs like we handled truly nested types, but
  this is not much of a restriction, since GADTs defined over
  themselves have not, to our knowledge, appeared in applications.}
This process yields, in particular, the deep induction rule for
$\mathsf{Seq}$ given in Section~\ref{sec:ind-seq}. {\color{red} MORE
  HERE???}

All of the deep induction rules appearing in this paper have been
derived using our general framework. Our Agda code implementing them
is available at~\cite{web-page}.

\subsection{Related Work}

Ullrich's plugin?

Tassi's Elpi

Peter Selinger and  Fu Peng

\section{Deep induction for ADTs and nested types}\label{sec:ADTs-and-nesteds}

\begin{comment}
\subsection{Syntax of ADTs and nested types}\label{ssec:syntax-adts}

\emph{(Polynomial) algebraic data types} (ADTs), both built-in and user-defined,
have long been at the core of functional languages such as Haskell, ML, Agda, Epigram, and Idris.
ADTs are used extensively in functional programming to structure computations,
to express invariants of the data over which computations are defined,
and to ensure the type safety of programs specifying those computations.
ADTs include unindexed types, such as the type of natural numbers,
and types indexed over other types, such as the quintessential example of an ADT,
the type of lists (here coded in Agda)
\begin{equation}\label{eq:list}
\begin{array}{l}
\mathsf{data\ List : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;nil\,\,\,\,\,\, :\, List\,A}\\
\mathsf{\;\;\;\;\;\;\;cons\, :\, A \to List\,A \to List\,A} 
\end{array}
\end{equation}
Note that all occurrences of $\mathsf{List}$ in the above encoding
are instantiated at the same index $\mathsf{A}$.  Thus, the instances
of $\mathsf{List}$ at various indices are defined independently from
one another.  That is a defining feature of ADTs: an ADT defines a
\emph{family of inductive types}, one for each index type.

Over time, there has been a notable trend toward data types whose
non-regular indexing can capture invariants and other sophisticated
properties that can be used for program verification and other
applications.  A simple example of such a type is given by Bird and
Meertens’~\cite{bm98} prototypical \emph{nested type}
\begin{equation}\label{eq:ptree}
\begin{array}{l}
\mathsf{data\ PTree : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;pLeaf\,\,\, :\, A \to PTree\,A}\\
\mathsf{\;\;\;\;\;\;\;pNode\, :\, PTree\,(A \times A) \to PTree\,A} 
\end{array}
\end{equation}
of perfect trees, which can be thought of as constraining lists to
have lengths that are powers of 2.  In the above code, the constructor
$\mathsf{PNode}$ uses data of type $\mathsf{PNode\,(A \times A)}$ to
construct data of type $\mathsf{PNode\,A}$.  Thus, it is clear that
the instantiations of $\mathsf{PNode}$ at various indices cannot be
defined independently, so that the entire family of types must
actually be defined at once.  A nested type thus defines not a family
of inductive types, but rather an \emph{inductive family of types}.

Nested types include simple nested types, like perfect trees,
none of whose recursive occurrences occur below another type constructor,
and \emph{truly} nested types, such as the nested type
\begin{equation}\label{eq:bush}
\begin{array}{l}
\mathsf{data\ Bush : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;bNil\,\,\,\,\,\, :\, Bush\,A}\\
\mathsf{\;\;\;\;\;\;bCons\, :\, A \to Bush\,(Bush\,A) \to Bush\,A} 
\end{array}
\end{equation}
of bushes, whose recursive occurrences appear below their own type constructors.
Note that, while the constructors of a nested type can contain occurrences of the type instantiated at any index,
the return types of its constructors still have to be the same type instance of the type being defined.
In other words, all constructors of $\mathsf{PTree\,A}$ have to return an element of type $\mathsf{PTree\,A}$,
and all constructors of $\mathsf{Bush\,A}$ have to return an element of type $\mathsf{Bush\,A}$.
%the return types of the constructors are still required to be instantiated at the same variable $\mathsf{a}$.}
%As previously noted, the return types of the constructors of a nested
%type have to be the same type instance of the type being defined.
\end{comment}

\subsection{Induction principles for ADTs and nested
  types}\label{ssec:induction-nested} 

A structural induction principle for a data type allows us to prove
that if a predicate holds for every element inductively produced by
the data type's constructors then it holds for every element of the
data type.  In this paper, we are interested in induction principles
for proof-relevant predicates.  A proof-relevant predicate on a type
$\mathsf{A : Set}$ is a function $\mathsf{P\,:\,A \to Set}$ mapping
each $\mathsf{x : A}$ to the set of proofs that $\mathsf{P\,x}$ holds.
For example, the induction principle for the standard data type
\begin{equation*}\label{eq:list}
\begin{array}{l}
\mathsf{data\ List : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;nil\,\,\,\,\,\, :\, List\,A}\\
\mathsf{\;\;\;\;\;\;\;cons\, :\, A \to List\,A \to List\,A} 
\end{array}
\end{equation*}
of lists is
\begin{equation*}
\mathsf{
\forall (A : Set) (P : List\,A \to Set)
\to P\,nil
\to \big( \forall (a : A) (as: List\,A)
\to P\,as
\to P\,(cons\,a\,as)\big)
\to \forall (as : List\,A)
\to P\, as
}
\end{equation*}
As in Coq's induction rule for rose trees, the data inside a
structure of type $\mathsf{List}$ is treated monolithically (i.e.,
ignored) by this structural induction rule.
%Indeed, the structural induction rule for a data type inducts
%over only the top-level structures of data types, leaving any data
%internal to the top-level structure untouched.  Since this kind of
%induction principle is only concerned with the structure of the type,
%and unconcerned with the contained data, we will then refer to it as
%\emph{structural induction}.
By contrast, the deep induction rule for lists is parameterized over a
custom predicate $\mathsf{Q}$ on $\mathsf{A}$ as described in the
introduction. For $\mathsf{List^\wedge}$ as described in the
introduction, it is
\[
\begin{array}{l}
\mathsf{\forall (A : Set) (P : List\, A \to Set) (Q : A \to Set)
\to P\,Nil \to \big( \forall (a : A) (as: List\,A) \to Q\,a \to P\,as
\to P\,(Cons\,a\,as)\big)} \\ 
\quad\mathsf{\to \forall (as : List\,A) \to List^{\wedge}\,A\,Q\,as
  \to P\,as } 
\end{array}
\]

Structural induction can also be extended to nested types, such as the
following type of perfect trees~\cite{bm98}:
\begin{equation*}\label{eq:ptree}
\begin{array}{l}
\mathsf{data\ PTree : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;pleaf\,\,\, :\, A \to PTree\,A}\\
\mathsf{\;\;\;\;\;\;\;pnode\, :\, PTree\,(A \times A) \to PTree\,A} 
\end{array}
\end{equation*}
Perfect trees can be thought of as lists constrained to have lengths
that are powers of 2. In the above code, the constructor
$\mathsf{pnode}$ uses data of type $\mathsf{PTree\,(A \times A)}$ to
construct data of type $\mathsf{PTree\,A}$. Thus, it is clear that the
instances of $\mathsf{PTree}$ at various indices cannot be defined
independently, and that the entire inductive family of types must
therefore be defined at once. This intertwinedness of the instances
of nested types is reflected in their structural induction rules,
which must necessarily involve polymorphic predicates, rather than the
monomorphic predicates appearing in structural induction rules for
ADTs. The structural induction rule for perfect trees, for example, is
\[\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to PTree\, A \to Set)
\to \big( \forall (A : Set) (a : A) \to P\,A\,(pleaf\, a) \big)} \\
\quad\mathsf{\to \big( \forall (A : Set) (tt : PTree\,(A \times A))
  \to P\,(A \times A)\,tt \to P\,a\,(pnode\,tt)\big) \to \forall (A :
  Set) (t : PTree\,A) \to P\,A\,t } 
\end{array}\]
The deep induction rule for perfect trees similarly uses polymorphic
predicates but otherwise follows the now-familiar pattern:
\[\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to (A \to Set) \to PTree\,A
  \to Set) \to \big( \forall (A : Set) (Q : A \to Set) (a : A) \to
  Q\,a \to P\,A\,Q\,(Pleaf\, a) \big)} \\ \quad \mathsf{\to \big(
  \forall (A : Set) (Q : A \to Set) (tt : PTree\,(A \times A)) \to
  P\,(A \times A)\,(Pair^{\wedge}\,A\,A\,Q\,Q)\,tt \to
  P\,A\,Q\,(Pnode\,tt)\big)} \\ \quad \mathsf{\to \forall (A : Set) (Q
  : A \to Set) (t : PTree\,A) \to PTree^{\wedge}\,A\,Q\,t \to
  P\,A\,Q\,t }
\end{array}\]
Here, $\mathsf{Pair^{\wedge} : \forall (A\; B: Set) \to (A \to Set)
  \to (B \to Set) \to A \times B \to Set}$ lifts predicates
$\mathsf{Q_A}$ on data of type $\mathsf{A}$ and $\mathsf{Q_B}$ on data
of type $\mathsf{B}$ to a predicate on pairs of type $\mathsf{A \times
  B}$ in such a way that $\mathsf{Pair^{\wedge}\,A\,B\,Q_A\,Q_B\,(a,b)
 = Q_A\,a \times Q_B\,b}$. Similarly, $\mathsf{PTree^{\wedge} :
  \forall (A : Set) \to (A \to Set) \to PTree\,A \to Set}$ lifts a
predicate $\mathsf{Q}$ on data of type $\mathsf{A}$ to a predicate on
data of type $\mathsf{PTree\,A}$ asserting that $\mathsf{Q}$ holds for
every element of type $\mathsf{A}$ contained in its perfect tree
argument.

It is not possible to extend structural induction to {\em truly}
nested types, i.e., to nested types whose recursive occurrences appear
below their own type constructors. Indeed, defining any induction rule
for such a type requires that we can lift the predicate argument to
that rule over the type itself. The observation that any induction
rule for a truly nested type would thus necessarily have to be a deep
induction rule was, in fact, the original motivation for the
introduction of deep induction in~\cite{jp20}.

The quintessential example of a truly nested type is that of
bushes~\cite{bm98}:
\begin{equation*}\label{eq:bush}
\begin{array}{l}
\mathsf{data\ Bush : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;bnil\,\,\,\,\,\, :\, Bush\,A}\\
\mathsf{\;\;\;\;\;\;bvons\, :\, A \to Bush\,(Bush\,A) \to Bush\,A} 
\end{array}
\end{equation*}
Its (deep) induction rule is
\[\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to (A \to Set) \to Bush\, A \to Set)
\to \big( \forall (A : Set) \to P\,A\,bnil \big)} \\ 
\quad\mathsf{\to \big( \forall (A : Set) (Q : A \to Set) (a : A) (bb :
  Bush\,(Bush\,A)) \to Q\,a \to
  P\,(Bush\,A)\,(Bush^{\wedge}\,A\,Q)\,bb \to P\,A\,Q\,(bcons\,a\,bb)
  \big)} \\ 
\quad\mathsf{\to \forall (A : Set) (Q : A \to Set) (b : Bush\,A) \to
  Bush^{\wedge}\,A\,Q\,b \to P\,A\,Q\,b } 
\end{array}\]
where $\mathsf{Bush^{\wedge} : \forall (A : Set) \to (A \to Set) \to
  Bush\,A \to Set}$ is the following lifting of a predicate
$\mathsf{Q}$ on data of type $\mathsf{A}$ to a predicate on data of
type $\mathsf{Bush\,A}$ asserting that $\mathsf{Q}$ holds for every
element of type $\mathsf{A}$ contained in its argument bush:
\begin{align*}
\mathsf{Bush^{\wedge}\,A\,Q\,bnil} &= \mathsf{\top} \\
\mathsf{Bush^{\wedge}\,A\,Q\,(bcons\,a\,bb)} &= \mathsf{Q\,a \times
  Bush^{\wedge}\,(Bush\,A)\,(Bush^{\wedge}\,A\,Q)\,bb}
\end{align*}

It is worth noting that for those nested types that do admit both
structural induction and deep induction, the latter generalizes the
former. Indeed, the structural induction rule for a nested type is
recoverable from its deep induction rule by taking the custom
predicates on their data of primitive types to be constantly
$\mathsf{True}$-valued predicates. Such an instantiation ensures that
a deep induction rule only inspects the top-level structure of its
argument data, rather than the contents of that structure.  A concrete
example of such a derivation is given in Section~\ref{sec:ind-equal}.

\section{(Deep) GADTs}\label{sec:GADTs}

While a constructor of a nested type can take {\em as arguments} data
whose types involve instances of that type at indices other than the
one being defined, its return type must still be at the (variable)
type instance being defined. For example, every constructor of
$\mathsf{PTree\,A}$ must return an element of type
$\mathsf{PTree\,A}$. \emph{Generalized algebraic data types}
(GADTs)~\cite{ch03,sp04,xcc03} relax this restriction, allowing their
constructors both to take as arguments \emph{and return as results}
data whose types involve instances of the GADT other than the one
being defined. As with the return type of the $\mathsf{sPair}$
constructor in~\eqref{eq:seq}, these indices can be structured.
%Applications of GADTs include generic programming, modeling
%programming languages via higher-order abstract syntax, maintaining
%invariants in data structures, and expressing constraints in embedded
%domain-specific languages. GADTs have also been used, e.g., to
%implement tagless interpreters~\cite{pl04,pr06,pvww06}, to improve
%memory performance~\cite{min15}, and to design APIs~\cite{pen20}.

GADTs are used in precisely those situations in which different
behaviors at different instances of data types are desired. This is
achieved by allowing the programmer to give the type signatures of the
GADT's data constructors independently, and then using {\color{red}
  pattern matching} to force the desired type refinement. For example,
the {\em equality} GADT
\begin{equation}\label{eq:equal}
\begin{array}{l}
\mathsf{data\ Equal : Set \to Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;\;\;\;\,refl :\, Equal\,A\,A}
\end{array}
\end{equation}
is parametrized by two type indices, but it is only possible to
construct data elements of type $\mathsf{Equal\,a\,b}$ if $\mathsf{a}$
and $\mathsf{b}$ are instantiated at the same type. If the types
$\mathsf{a}$ and $\mathsf{b}$ are syntactically identical then the
type $\mathsf{Equal\,a\,b}$ contains a single data element. It
contains no data elements otherwise.

The importance of the equality GADT lies in the fact that we can
understand other GADTs in terms of it. For example, the GADT of
sequences in~\eqref{eq:seq} comprises constant sequences of data of
any type $\mathsf{A}$ and sequences obtained by pairing the data in
two already existing sequences. This GADT can be understood as its
{\em Henry Ford encoding}~\cite{ch03,hin03,mcb99,sjsv09,sp04}, which
makes critical use of the equality GADT, as follows:
\begin{equation}\label{eq:eq_seq}
\begin{array}{l}
\mathsf{data\ Seq : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;const :\, A \to Seq\,A}\\ 
\mathsf{\;\;\;\;\;\;\;\;pair\,\, :\, \forall (B\,C : Set) \to
  Equal\,A\,(B \times C) \to Seq\,B \to Seq\,C \to Seq\,A}\\ 
\end{array}
\end{equation}
Here, the requirement that $\mathsf{pair}$ produce data at an
instance of $\mathsf{Seq}$ that is a product type is replaced with the
requirement that $\mathsf{pair}$ produce data at an instance of
$\mathsf{Seq}$ that is \emph{equal} to a product type. As we will see
below, this use of the equality GADT is key to deriving deep induction
rules for more general GADTs.

\vspace*{0.05in}

Finally, we give an example of a deep GADT. The $\mathsf{LTerm}$ GADT
encodes terms of a simply typed lambda calculus. More robust
variations on this calculus are, of course, possible. But since
$\mathsf{LTerm}$ is rich enough to illustrate all of the essential
aspects of deep GADTs --- and later, in Section~\ref{sec:ind-lam},
their deep induction rules --- while still being small enough to
ensure clarity of exposition, we keep our calculus to a minimum.

Types are either booleans, arrow types, or list types, and are
represented by the following GADT:
\begin{equation*}\label{eq:eq_ltype}
\begin{array}{l}
\mathsf{data\ LType : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;bool :\, \forall (B : Set) \to LType\,Bool}\\
\mathsf{\;\;\;\;\;\;\;\;arr\,\,\, :\, \forall (B\,C : Set) \to
  LType\,B \to LType\,C \to LType\,(B \to C)}\\
\mathsf{\;\;\;\;\;\;\;\;list\,\, :\, \forall (B : Set)
  \to LType\,B \to LType\,(List\,B)}
\end{array}
\end{equation*}
Terms are either variables, abstractions, applications, or lists of
such terms. They are represented by
\begin{equation*}\label{eq:eq_lterm}
\begin{array}{l}
\mathsf{data\ LTerm : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;var\,\,\,\,\,\,\,:\, String \to LType\,A \to
  LTerm\,A} \\  
\mathsf{\;\;\;\;\;\;\;\;abs\,\,\,\,\,\, :\, \forall (B\,C : Set) \to
  String \to LType\,B \to LTerm\,C \to
  LTerm\,(B \to C)}\\ 
  \mathsf{\;\;\;\;\;\;\;\;app\,\,\,\,\, :\, \forall (B : Set) \to
    LTerm (B \to A) \to LTerm\,B \to LTerm\,A} \\ 
  \mathsf{\;\;\;\;\;\;\;\;list\,\,\, :\, \forall (B : Set) \to
    List\,(LTerm\,B) \to LTerm\,(List \,B)} 
\end{array}
\end{equation*}
The type parameter for the GADT $\mathsf{LTerm}$ tracks the types of
simply typed lambda calculus terms. For example, $\mathsf{LTerm\,A}$
is the type of lambda terms of type $\mathsf{A}$. Variables are tagged
with their types by the data constructors $\mathsf{var}$ and
$\mathsf{abs}$, whose $\mathsf{LType}$ arguments ensure that the
tagging types are legal.
%types, e.g., $\mathsf{Bool}$, $\mathsf{Bool \to Bool}$,
%  $\mathsf{List\, (Bool \to Bool)}$, etc. That is, the presence of
%$\mathsf{LType}$ in these constructors thus guarantees that
As a result, all lambda terms produced by $\mathsf{var}$,
$\mathsf{abs}$, $\mathsf{app}$, and $\mathsf{list}$ are necessarily
well-typed.

{\color{red} Maybe only give in the following form.}
The Henry Ford encodings representing $\mathsf{LType}$ and
$\mathsf{LTerm}$ in terms of the equality GADT are:
\begin{equation}\label{eq:eq_ltype}
\begin{array}{l}
\mathsf{data\ LType : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;bool :\, \forall (B : Set) \to Equal\,A\,Bool
  \to LType\,A}\\ 
\mathsf{\;\;\;\;\;\;\;\;arr\,\,\, :\, \forall (B\,C : Set) \to
  Equal\,A\,(B \to C) \to LType\,B \to LType\,C \to LType\,A}\\ 
  \mathsf{\;\;\;\;\;\;\;\;list\,\, :\, \forall (B : Set) \to
    Equal\,A\,(\List\,B) \to LType\,B \to LType\,A} 
\end{array}
\end{equation}
and
\begin{equation}\label{eq:eq_lterm}
\begin{array}{l}
\mathsf{data\ LTerm : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;var\,\,\,\,\,\,\,:\, String \to LType\,A \to
  LTerm\,A} \\  
\mathsf{\;\;\;\;\;\;\;\;abs\,\,\,\,\,\, :\, \forall (B\,C : Set) \to
  Equal\,A\,(B \to C) \to String \to LType\,B \to LTerm\,C \to
  LTerm\,A}\\ 
  \mathsf{\;\;\;\;\;\;\;\;app\,\,\,\,\, :\, \forall (B : Set) \to
    LTerm (B \to A) \to LTerm\,B \to LTerm\,A} \\ 
  \mathsf{\;\;\;\;\;\;\;\;list\,\,\, :\, \forall (B : Set) \to
    Equal\,A\,(List\,B) \to List\,(LTerm\,B) \to LTerm\,A} 
\end{array}
\end{equation}
We will revisit these GADTs in Sections~\ref{sec:deep-ind-GADTs}
and~\ref{sec:app}.

\section{(Deep) induction for GADTs}\label{sec:deep-ind-GADTs}

{\color{red} Combine and/or put in figures?}

The equality constraints engendered by GADTs' data constructors makes
deriving (deep) induction rules for then more involved than for ADTs
and other nested types. Nevertheless, we show in this section how to
do so. We first illustrate the key components of our approach by
deriving deep induction rules for the three specific GADTs introduced
in Section~\ref{sec:GADTs}. Then, in Section~\ref{sec:framework}, we
abstract these to a general framework that can be applied to any deep
GADT that is not truly nested. {\color{red} directly or indirectly ---
  what should we call these?} As expected, the derivation for the
equality GADT plays a central role in that for more general ones.
%instrumental in stating and deriving the induction rules for other
%GADTs.

\subsection{(Deep) induction for equality}\label{sec:ind-equal}

To define the deep induction rule for any deep GADT $\mathsf{G}$ we
first need a predicate lifting that lifts any predicate on a type
$\mathsf{A}$ and to a predicate on $\mathsf{G\,A}$. The predicate
lifting 
\[\mathsf{Equal^{\wedge} : \forall (A\,B : Set) \to (A \to Set) \to (B
  \to Set) \to Equal\,A\,B \to Set}\] 
for $\mathsf{Equal}$ is defined by
\[\mathsf{Equal^{\wedge}\,A\,A\,Q\,Q'\,refl = \forall (a : A) \to
  Equal\,(Q\,a)(Q'\,a)}\]
As expected, it takes two predicates on the same type as input and
tests them for extensional equality.

Next, we need to associate with each data constructor $\mathsf{c}$ of
$\mathsf{G}$ an induction hypothesis asserting that, if the custom
predicate arguments to a predicate $\mathsf{P}$ on $\mathsf{G}$ can be
lifted to $\mathsf{G}$ itself, then $\mathsf{c}$ {\color{red}
  preserves} $\mathsf{P}$. The following induction hypothesis
$\mathsf{dIndRefl}$ is thus associated with the $\mathsf{refl}$
constructor for $\mathsf{Equal}$:
\begin{equation*}\label{eq:ind-refl}
\begin{array}{l}
\mathsf{\lambda (P : \forall (A\,B : Set) \to (A \to Set) \to (B \to
  Set) \to Equal\,A\,B \to Set)} \\ 
\quad\mathsf{\to \forall (C : Set) (Q\, Q' : C \to Set) \to
  Equal^{\wedge}\,C\,C\,Q\,Q'\,refl \to P\,C\,C\,Q\,Q'\,refl} 
\end{array}
\end{equation*}
The deep induction rule for $\mathsf{G}$ now states that, if a
predicate $\mathsf{P}$ is {\color{red} preserved} by all of
$\mathsf{G}$'s constructors, then $\mathsf{P}$ is satisfied by every
element of $\mathsf{G}$ to which the custom predicate arguments to
$\mathsf{P}$ can be successfully lifted.  The deep induction rule for
the GADT $\mathsf{Equal}$ is thus
\begin{equation}\label{eq:ind-equal}
\begin{array}{l}
\mathsf{\forall (P : \forall (A\,B : Set) \to (A \to Set) \to (B \to
  Set) \to Equal\,A\,B \to Set) \to dIndRefl\,P \to}\\ \quad 
  \mathsf{\forall (A\,B : Set) (Q_A : A \to Set) (Q_B : B \to Set) (e:
  Equal\,A\,B) \to Equal^{\wedge}\,A\,B\,Q_A\,Q_B\,e \to
  P\,A\,B\,Q_A\,Q_B\,e}
\end{array}
\end{equation}

To prove that the deep induction rule for $\mathsf{Equal}$ is sound we
must provide a witness inhabiting the type in~\eqref{eq:ind-equal}.
We first note that, by {\color{red} pattern matching}, we only need to
consider the case where $\mathsf{A} = \mathsf{B}$ and $\mathsf{e} =
\mathsf{refl}$.  We can therefore define a term $\mathsf{dIndEqual}$
of the type in \eqref{eq:ind-equal} by
\[\mathsf{dIndEqual\;P\;crefl\;A\;A\;Q_A\;Q_A'\;refl\;liftE =
  crefl\;A\;Q_A\;Q_A'\,liftE}\] 
We can also recover the structural induction rule
\begin{equation}\label{eq:sind-equal}
\mathsf{\forall (Q : \forall (A\,B : Set)
  \to Equal\,A\,B \to Set) \to \big( \forall (C : Set) \to
  P\,C\,C\,refl \big) \to \forall (A\,B : Set) (e: Equal\,A\,B) \to
  P\,A\,B\,e}
\end{equation}
for $\mathsf{Equal}$ by defining a term $\mathsf{indEqual}$ of the
type in~\eqref{eq:sind-equal} by
\[\mathsf{indEqual\;Q\;srefl\;A\;B\;e =
  dIndEqual\;P\;srefl\;A\;B\;K^A_\top\;K^B_\top\;e\,liftE}\] Here,
$\mathsf{e : Equal\,A\,B}$,
$\mathsf{P : \forall (A\,B : Set) \to (A \to Set) \to (B \to
  Set) \to Equal\,A\,B \to Set}$ is defined by
  $\mathsf{P\;A\;B\;Q_A\;Q_B\;e =}$ $\mathsf{Q\;A\;B\;e}$,
$\mathsf{K^A_\top}$ and $\mathsf{K^B_\top}$ are the constantly
  {\color{red} $\mathsf{\top}$}-valued predicates on $\mathsf{A}$ and
  $\mathsf{B}$, respectively, and
$\mathsf{liftE :}$ $\mathsf{Equal^{\wedge}\;A\;B\;K^A_\top\;K^B_\top\;e}$
  is fully defined (by pattern matching) by $\mathsf{liftE\,a = refl :
    Equal\,A\,A}$ for every $\mathsf{a : A}$.


{\color{red} Although the structural induction rule for any GADT
  $\mathsf{G}$ can similarly be recovered from its deep induction rule
  by instantiating every custom predicate by the appropriate
  constantly {\color{red}$\mathsf{\top}$}-valued predicate, we will
  not explicitly note this for each of the examples below.}

\subsection{(Deep) induction for sequences}\label{sec:ind-seq}

To derive the deep induction rule for the GADT $\mathsf{Seq}$ we use
its Henry Ford encoding from~\eqref{eq:eq_seq}.  As usual, the first
step is to define the predicate lifting $\mathsf{Seq^\wedge : \forall
  (A : Set) \to (A \to Set) \to Seq\,A \to Set}$. It is defined by
\[\mathsf{Seq^{\wedge}\,A\,Q_A\,(const\,a) = Q_A\,a}\]
for $\mathsf{a : A}$, and
\[\begin{array}{l}
\mathsf{Seq^{\wedge}\,A\,Q_A\,(sPair\,B\,C\,e\,s_B\,s_C)}
\\ \quad\mathsf{= \exists [Q_B] \exists [Q_C]\, Equal^{\wedge}\,A\, (B
  \times C)\, Q_A\, (Q_B \times Q_C) \, e \times
  Seq^{\wedge}\,B\,Q_B\,s_B \times Seq^{\wedge}\,C\,Q_C\,s_C }
\end{array}\]
for $\mathsf{Q_B : B \to Set}$, $\mathsf{Q_C : C \to Set}$, $\mathsf{e
  : Equal\,A\,(B \times C)}$, $\mathsf{s_B : Seq\,B}$, $\mathsf{s_C :
  Seq\,C}$, and $\mathsf{\exists [x]\, F \,x}$ is syntactic sugar for the
type of dependent pairs $\mathsf{(x,b)}$ where $\mathsf{x : A}$ and
$\mathsf{b : F\, x}$ and $\mathsf{F : A \to Set}$.

Next, let $\mathsf{dIndConst}$ be the induction hypothesis
\[\mathsf{
\lambda (P : \forall (A : Set) \to (A \to Set) \to Seq\,A \to Set) \to
\forall (A : Set) (Q_A : A \to Set) (a : A) \to Q_A\,x \to
P\,A\,Q_A\,(const\,a)}\] associated with the constructor
$\mathsf{const}$, and let $\mathsf{dIndPair}$ be the induction
hypothesis
\[\begin{array}{l}
\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to Seq\,A \to
  Set)} \to \\ 
\quad \mathsf{\forall (A\,B\,C : Set) (Q_A : A \to Set) (Q_B : B
  \to Set) (Q_C : C \to Set)(s_B : Seq\,B) (s_C : Seq\,C) (e :
  Equal\,A\,(B \times C)) \to} \\ 
\quad \mathsf{Equal^{\wedge} A\, (B \times C)\, Q_A\,
  (Pair^{\wedge}\,B\,C\,Q_B\,Q_C)\, e \to P\,B\,Q_B\,s_B \to
  P\,C\,Q_C\,s_C \to P A Q_A ( pair\,B\,C\,e\,s_B\,s_C )}
\end{array}\]
associated with the constructor $\mathsf{pair}$. The deep induction
rule for $\mathsf{Seq}$ is thus
\begin{equation}\label{eq:ind-seq}
\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to (A \to Set) \to Seq\,A \to
  Set)} \mathsf{\to dIndConst\,P \to dIndPair\,P \to} \\ \quad
\mathsf{\forall (A : Set)(Q_A : A \to Set)(s_A : Seq\,A) \to
  Seq^{\wedge}\,A\,Q_A\,s_A \to P\,A\,Q_A\,s_A}
\end{array}
\end{equation}

To prove that the deep induction rule for $\mathsf{Seq}$ is sound we
must provide a witness $\mathsf{dIndSeq}$ inhabiting the type
in~\eqref{eq:ind-seq}. We proceed by pattern matching on
$\mathsf{s_A}$.
\begin{itemize}
\item If $\mathsf{s_A = const\,a}$ for $\mathsf{a : A}$, then we
  define \[\mathsf{dIndSeq\;P\;cconst\;cpair\;A\;Q_A\;(const\,a)\;liftA
    = cconst\;A\;Q_A\;a\;liftA}\] Since
  $\mathsf{Seq^{\wedge}\,A\,Q_A\,(const\,a)}$ $\mathsf{= Q_A\,a}$, and
  thus $\mathsf{liftA : Q_A\,a}$, the definition does indeed
  type-check.
\item If $\mathsf{s_A = sPair\,B\,C\,e\,s_B\,s_C}$ for $\mathsf{e :
  Equal\,A\,(B \times C)}$, $\mathsf{s_B : Seq\,B}$, and $\mathsf{s_C
  : Seq\,C}$, then we define
  \[\mathsf{dIndSeq\,P\,cconst\,cpair\,A\,Q_A\,(sPair\,B\,C\,e\,s_B\,s_C)\,
    (Q_B,Q_C, liftE, liftB, liftC) =
    cpair\,A\,B\,C\,Q_A\,Q_B\,Q_C\,s_B\,s_C\,e\,liftE\,p_B\,p_C}\]
  Here, $\mathsf{Q_B : B \to Set}$, $\mathsf{Q_C : C \to Set}$,
  $\mathsf{liftE : Equal^{\wedge}\,A\, (B \times C)\, Q_A\, (Q_B
    \times Q_C) \, e}$, $\mathsf{liftB : Seq^{\wedge}\,B\,Q_B\,s_B}$,
  and $\mathsf{liftC :}$\\
\noindent
$\mathsf{Seq^{\wedge}\,C\,Q_C\,s_C}$ --- which together ensure that
  $\mathsf{(Q_B, Q_C, liftE, liftB, liftC) :
    Seq^{\wedge}\,A\,Q\,(sPair\,B\,C\,e\,s_B\,s_C)}$ --- and\\
%  $\mathsf{p_B}$ and $\mathsf{p_C}$\\ are defined by
$\mathsf{p_B}
  =\mathsf{dIndSeq\,P\,cconst\,cpair\,B\,Q_B\,s_B\,liftB :
    P\,B\,Q_B\,s_B}$ and $\mathsf{p_C}
  =\mathsf{dIndSeq\,P\,cconst\,cpair\,C\,Q_C\,s_C\,liftC :
    P\,C\,Q_C\,s_C}$.
\end{itemize}

\subsection{(Deep) induction for simply typed lambda
  terms}\label{sec:ind-lam} 

To derive the deep induction rule for the GADT $\mathsf{LTerm}$ we use
its Henry Ford encoding from~\ref{eq:eq_ltype}
and~\eqref{eq:eq_lterm}. The first step is to define the predicate
liftings for $\mathsf{LType}$ and $\mathsf{LTerm}$. We will also need
a predicate lifting for arrow types, since arrow types appear in
$\mathsf{LType}$ and $\mathsf{LTerm}$.

The predicate lifting $\mathsf{Arr^{\wedge} : \forall (A\, B : Set)
  \to (A \to Set) \to (B \to Set) \to (A \to B) \to Set}$ for arrow
types is defined by
\[\mathsf{Arr^{\wedge}\, A\, B\, Q_A\, Q_B\, f = \forall (a : A) \to
  Q_A\,a \to Q_B\, (f\,a)}\] The predicate lifting
$\mathsf{LType^{\wedge} : \forall (A : Set) \to (A \to Set) \to
  LType\,A \to Set}$ for $\mathsf{LType}$ is defined by
pattern matching by
\[ \mathsf{LType^{\wedge}\,A\,Q_A\,(bool\,B\,e)
  = \exists [Q_B]\, Equal^{\wedge}\, A\, B\, Q_A\, K^{Bool}_{\top}
  \,e}\] where $\mathsf{Q_A : A \to Set}$, $\mathsf{Q_B : B \to Set}$,
$\mathsf{K^{Bool}_{\top}}$ is the constantly $\mathsf{\top}$-valued
predicate on $\mathsf{Bool}$, and $\mathsf{e : Equal\,A\,Bool}$;
\[\mathsf{LType^{\wedge}\,A\,Q_A\,(arr\, B\, C\, e\, T_B\, T_C)}
\mathsf{= \exists [Q_B] \,\exists [Q_c]\, Equal^{\wedge}\,A\,
  (B \to C)\, Q_A\, (Arr^{\wedge} \, B\, C\, Q_B \, Q_C) \, e \times
  \, LType^{\wedge}\,B\,Q_B\,T_B \times LType^{\wedge}\,C\,Q_C\,T_C}\]
where $\mathsf{Q_A : A \to Set}$, $\mathsf{Q_B : B \to Set}$,
$\mathsf{Q_C : C \to Set}$, $\mathsf{e : Equal\, A\, (B \to C)}$,
$\mathsf{T_B : LType \,B}$ and $\mathsf{T_C : LType \,C}$; and
\[\mathsf{LType^{\wedge}\,A\,Q_A\,(list\, B\, e\, T_B)
=
\exists [Q_B]\,
  Equal^{\wedge}\,A\, (List\, B)\, Q_A\, (List^{\wedge} \, B\, Q_B) \, e 
  \times LType^{\wedge}\,B\,Q_B\,T_B
}
\]
where $\mathsf{Q_A : A \to Set}$, $\mathsf{Q_B : B \to Set}$,
$\mathsf{e : Equal\, A\, (List\, B)}$, and $\mathsf{T_B : LType \,B}$.
The predicate lifting $\mathsf{LTerm^{\wedge} :}$ $\mathsf{\forall (A
  : Set) \to (A \to Set) \to LTerm\,A \to Set}$ for $\mathsf{LTerm}$
is defined by pattern matching by
\[\mathsf{LTerm^{\wedge}\,A\,Q_A\,(var\,s\,T_A) = LType^{\wedge}\, A\,
  Q_A\, T_A}\] where $\mathsf{s : String}$ and $\mathsf{T_A : LType\, A}$;
\[\mathsf{LTerm^{\wedge}\,A\,Q_A\, (abs \,B \,C \,e \,s \,T_B \,t_C)}
\mathsf{ = \exists [Q_B]\,\exists [Q_C]\, Equal^{\wedge} \, A\, (B \to
  C)\, Q_A\, (Arr^{\wedge} \, B\, C\, Q_B \, Q_C)\, e \times \,
  LType^{\wedge}\, B\, Q_B\, T_B \times \, LTerm^{\wedge}\, C\, Q_C\,
  t_C }\] where $\mathsf{Q_B : B \to Set}$, $\mathsf{Q_C : C \to
  Set}$, $\mathsf{e : Equal \, A \, (B \to C)}$, $\mathsf{s :
  String}$, $\mathsf{T_B : LType\,B}$, and $\mathsf{t_C : LTerm \,
  C}$;
\[\mathsf{LTerm^{\wedge}\,A\,Q_A\, (app\, B\, t_{BA}\, t_B)
= \exists [Q_B]\, LTerm^{\wedge}\, (B \to A)\, (Arr^{\wedge} \, B\,
A\, Q_B \, Q_A)\, t_{BA} \times LTerm^{\wedge}\, B\, Q_B\, t_B}\]
where $\mathsf{Q_B : B \to Set}$, $\mathsf{t_{BA} : LTerm \, (B \to
  A)}$, and $\mathsf{t_B : LTerm \, B}$; and
\[\mathsf{LTerm^{\wedge}\,A\,Q_A\, (list\, B\, e\, ts) =
\exists [Q_B]\, Equal^{\wedge} \, A\, (List\,B)\, Q_A\, (List^{\wedge}
\, B\, Q_B) \, e \times List^{\wedge}\, (LTerm\,B) \, (LTerm^{\wedge}
\, B\, Q_B) \, ts} 
\]
where $\mathsf{Q_B : B \to Set}$, $\mathsf{e : Equal\, A\, (List
  \,B)}$, $\mathsf{ts : List\, (LTerm B)}$, and $\mathsf{List^\wedge}$
is the predicate lifting for lists from~\eqref{eq:rose}.

With these liftings in hand, we can define the deep induction
principle for $\mathsf{LTerm}$.
% Var case 
Let $\mathsf{dIndVar}$ be the induction hypothesis
\begin{multline*}
\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A
  \to Set)} \\ \mathsf{\to 
  \forall (A : Set) (Q_A : A \to Set) (s : String) (T_A : LType\, A) 
  \to LType^{\wedge} \, A\, Q_A\, T_A
  \to P \, A\, Q_A\, (var \; s\, T_A)
  }
\end{multline*}
associated with the constructor $\mathsf{var}$,
% Abs case 
let $\mathsf{dIndAbs}$ be the induction hypothesis
\begin{align*}
  &\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A
    \to Set)} \\ 
  &\quad\mathsf{\to 
  \forall (A\,B\,C: Set) (Q_A : A \to Set)  (Q_B : B \to Set) (Q_C : C
  \to Set) (e : Equal\, A\, (B \to C)) (s : String) } \\ 
  &\quad\mathsf{ \to (T_B : LType\, B) \to (t_C : LTerm\, C)
  \to Equal^{\wedge}\,A\,(B \to C)\, Q_A \, (Arr^{\wedge} \, B\, C\,
  Q_B \, Q_C) \, e } \\
  &\quad\mathsf{
  \to LType^{\wedge}\, B\, Q_B\, T_B
  \to P\, C\, Q_C\, t_C\, 
  \to P \, A\, Q_A\, (abs \,B \,C \, e \,s \,T_B \, t_C)
  }
\end{align*}
associated with the constructor $\mathsf{abs}$, let
% App case 
Let $\mathsf{dIndApp}$ be the induction hypothesis
\begin{align*}
  &\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A
    \to Set)} \\ 
  &\quad \mathsf{\to 
  \forall (A \,B : Set) (Q_A : A \to Set)  (Q_B : B \to Set) 
   (t_{BA} : LTerm\, (B \to A)) (t_B : LTerm\, B)} \\
  &\quad \mathsf{
  \to P\, (B \to A)\, (Arr^{\wedge} \, B\, A\, Q_B \, Q_A) \, t_{BA} \, 
  \to P\, B\, Q_B\, t_B\, 
  \to P \, A\, Q_A\, (app \,B \,t_{BA} \, t_B) }
\end{align*}
associated with the constructor $\mathsf{app}$, and 
% ListC case 
let $\mathsf{dIndList}$ be the induction hypothesis
\begin{align*}
  &\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A
    \to Set)} \\ 
  &\quad \mathsf{\to 
  \forall (A \,B : Set) (Q_A : A \to Set)  (Q_B : B \to Set) 
    (e : Equal\, A\, (List\, B)) (ts : List\, (LTerm\, B))} \\ 
  &\quad \mathsf{
    \to Equal^{\wedge}\, A\, (List\,B)\, Q_A\, (List^{\wedge}\, B\, Q_B)\, e 
  \to List^{\wedge}\, (LTerm\,B) (P\, B\, Q_B)\, ts
  \to P \, A\, Q_A\, (list \,B \,e \, ts) }
\end{align*}
associated with the constructor $\mathsf{list}$. The deep induction
principle for $\mathsf{LTerm}$ is thus
\begin{equation}\label{eq:ind-lam}
\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A
  \to Set) \to dIndVar\,P \to dIndAbs\,P \to dIndApp\,P \to
  dIndList\,P \to} \\ \quad \mathsf{\forall (A : Set)(Q_A : A \to
  Set)(t_A : LTerm\,A) \to LTerm^{\wedge}\,A\,Q_A\,t_A \to
  P\,A\,Q_A\,t_A}
\end{array}
\end{equation}

To prove that the deep induction principle for $\mathsf{LTerm}$ is
sound, we must provide a witness $\mathsf{dIndLTerm}$ inhabiting the
type in~\eqref{eq:ind-lam}. We proceed by pattern matching on
$\mathsf{t_A}$.
\begin{itemize}
\item If $\mathsf{t_A = var\; s\, T_A}$, then we define
\[ \mathsf{dIndLTerm \, P\, cvar \, cabs\, capp\, clist \, A\, Q_A\,
  (var\;s\,T_A) \, liftA = cvar \, A\, Q_A\, s\, T_A\, liftA }\] for
$\mathsf{s : String}$ and $\mathsf{T_A : LType\,A}$.  Note that
$\mathsf{LTerm^{\wedge}\, A\, Q_A\, (var\;s\,T_A) =
  LType^{\wedge}\,A\,Q_A\,T_A}$, so $\mathsf{liftA :
  LType^{\wedge}\,A\,Q_A\,T_A}$.
% Abs case 
\item If $\mathsf{t_A = abs \,B \,C \, e \,s \,T_B \, t_C} $, then we
  define
\[
\begin{array}{l}
\mathsf{dIndLTerm \, P\, cvar \, cabs\, capp\, clist \, A\, Q_A\,
  (abs \,B \,C \,e \,s \,T_B \, t_C) \, (Q_B , Q_C , liftE,
  lift_{T_B}, lift_{t_C})} \\ \quad \mathsf{= cabs\,A\,B\,C\, Q_A\,
  Q_B\, Q_C\, e\, s\, T_B\, t_C\, liftE\, lift_{T_B}\, p_C}
\end{array}
\]
Here, $\mathsf{Q_B : B \to Set}$, $\mathsf{Q_C : C \to Set}$,
$\mathsf{liftE : Equal^{\wedge} \, A\, (B \to C)\, Q_A\, (Arr^{\wedge}
  \, B\, C\, Q_B \, Q_C) \, e}$, $\mathsf{lift_{T_B}: LType^{\wedge}
  \, B\, Q_B\, T_B}$, and $\mathsf{lift_{t_C}: LTerm^{\wedge} \, C\,
  Q_C\, T_C}$ --- which together ensure that $\mathsf{(Q_B , Q_C ,
  liftE, lift_{T_B}, lift_{t_C}) : LTerm^{\wedge}\, A\, Q_A\, (abs \,B
  \,C \, e \,s \,T_B \, t_C)}$ --- and $\mathsf{p_C =
  dIndLTerm\,P\,cvar\,cabs \,capp \,clist\, C\, Q_C\, t_C\,
  lift_{t_C} : P \, C\, Q_C \, t_C }$.
% App case - (App \,b \,t_{ba} \, t_b)
\item If $\mathsf{t_A = app \,B \,\,t_{BA} \, t_B} $, then we define
\[ \mathsf{dIndLTerm \, P\, cvar \, cabs\, capp\, clist \, A\, Q_A\,
    (app \,B \,\,t_{BA} \, t_B)\, (Q_B , list_{t_{BA}}, list_{t_B})}
  \mathsf{ = capp\,A\,B\,Q_A\, Q_B\, t_{BA}\, t_B\, p_{BA} \, p_B}
\]
Here, $\mathsf{Q_B : B \to Set}$, $\mathsf{lift_{t_{BA}}:
  LTerm^{\wedge} \, (B \to A)\, (Arr^{\wedge} \, B\, A\, Q_B \, Q_A)\,
  t_{BA}}$, and $\mathsf{lift_{t_B}: LTerm^{\wedge} \, B\, Q_B\, t_B}$
--- so that\\ $\mathsf{(Q_B , lift_{t_{BA}}, list_{t_B}) : 
  LTerm^{\wedge}\, A\, Q_A\, (app \,B \,t_{BA} \, t_B)}$ --- and
$\mathsf{p_B} = \mathsf{dIndLTerm\,P\,cvar\,cabs \,capp \,clist\, B\,
  Q_B\, t_B\, lift_{t_B} : P \, B\, Q_B \, t_B }$ and $\mathsf{p_{BA}}
= \mathsf{dIndLTerm\,P\,cvar\,cabs \,capp \,clist\, (B \to
  A)\,(Arr^{\wedge} \, B\, A\, Q_B \, Q_A) \, t_{BA}\, lift_{t_{BA}} :
  P \, (B \to A)\, (Arr^{\wedge} \, B\, A\, Q_B \, Q_A) \, t_{BA} }$.
% ListC case - (ListC \,b \,e \, ts)
\item If let $\mathsf{t_A = list \,B \,e \, ts}$, then we define
\begin{multline*}
  \mathsf{dIndLTerm \, P\, cvar \, cabs\, capp\, clistc \, A\, Q_A\, (list \,B \,e \, ts) \, (Q_B , liftE, lift_{List})
  = clistc \,A\,B\,Q_A\, Q_B\, e\, ts\, liftE\, p_{List} }
\end{multline*}
Here, $\mathsf{Q_B : B \to Set}$, $\mathsf{listE : Equal^{\wedge}\,
  A\, (List\,B)\, Q_A\, (List^{\wedge}\, B\, Q_B)\, e}$, and
$\mathsf{lift_{List}: List^{\wedge} \, (LTerm\, B) \,
  (LTerm^{\wedge}\, B\, Q_B) \, ts}$ --- so that $\mathsf{(Q_B ,
  liftE, lift_{List}): LTerm^{\wedge}\, A\, Q_A\, (list \,B \,e \,
  ts)}$ --- and
$\mathsf{p_{List} = liftListMap \, (LTerm\, B) \, (LTerm^{\wedge} \, B
  \, Q_B)\, (P\,B\,Q_B)\, p_{ts} \, ts\, lift_{List} : }$\\
$\mathsf{List^{\wedge}\,
  (LTerm\,B) \, (P\,B\,Q_B) \, ts}$ and
$\mathsf{ p_{ts} = dIndLTerm\, P\, cvar\, cabs\, capp\, clist\, B\,
  Q_B : PredMap\,(LTerm\,B) \,(LTerm^{\wedge}\, B\, Q_B) \,
  (P\,B\,Q_B)}$. Moreover, $\mathsf{PredMap : \forall\, (A : Set) \to
  (A \to Set) \to   (A \to Set) \to Set }$ is the type constructor
producing the type of morphisms between predicates defined by
\[\mathsf{PredMap \,A\, Q\,Q'\, = \forall\, (a : A) \to Q\,a \to
  Q'\,a}\] and $\mathsf{liftListMap : \forall\, (A : Set) \to (Q \, Q'
  : A \to Set) \to PredMap\,A\,Q\,Q' \to PredMap\,(List\,A)
  \,(List^{\wedge}\, A\, Q)\, (List^{\wedge}\, A\, Q')}$ {\color{red}
  defined by ?????} takes a morphism $\mathsf{f}$ of predicates and
produces a morphism of lifted predicates {\color{red} by mapping
  $\mathsf{f}$ over the input list to which $\mathsf{Q}$ is lifted ---
  or other simple description?}
\end{itemize}



\section{The general framework}\label{sec:framework}

{\color{red} HERE!!!!}

%Since, as seen in Section~\ref{sec:GADT-nested},
%GADTs featuring nesting do not admit an induction rule,
%we restrict our scope to GADTs not featuring nesting.
Finally, we generalize the approach taken in the previous examples and
provide a general framework to derive deep induction rules for
arbitrary GADTs.  For that, we need to give a grammar for the types we
will be considering.  A generic GADT
\begin{equation*}
\begin{array}{l}
\mathsf{data\ G : Set^\alpha \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;c_i\, :\, F_i\,G\,\ol{B} \to G (\ol{K_i\,\ol{B}})}
\end{array}
\end{equation*}
is defined by a finite number of constructors $\mathsf{c_i}$.
In the definition above, $\mathsf{F_i}$ is a type constructor with signature $\mathsf{(Set^{\alpha} \to Set) \to Set^{\beta} \to Set}$
and each $\mathsf{K_i}$ is a type constructor with signature $\mathsf{Set^{\beta} \to Set}$
(i.e. a type constructor of arity $\mathsf{\beta}$).
The overline notation denotes a finite list:
%$\mathsf{\ol{a}}$ is a list of types of length $\mathsf{\alpha}$,
%so that it can be applied to the type constructor $\mathsf{G}$ of arity $\mathsf{\alpha}$.
%and the vertical bars notation denotes the length of a list:
%$\mathsf{G}$ depends on a finite list of types $\mathsf{\ol{a}}$ of length $\mathsf{\alpha}$,
each of the $\mathsf{\alpha}$-many $\mathsf{K_i}$ is a type constructor of arity $\mathsf{\beta}$
so that it can be applied to the list of types $\mathsf{\ol{B}}$ of length $\mathsf{\beta}$.
%depends on a finite list of types $\mathsf{\ol{b}}$ of length $\mathsf{\beta}$,
Moreover, notice that the arity of $\mathsf{G}$ matches the number of type constructors $\mathsf{K_i}$.
We allow each $\mathsf{F_i}$ to be inductively built in the following ways (and with the following restrictions):
\begin{itemize}
\item $\mathsf{F_i = F_i' \times F_i''}$ where $\mathsf{F_i'}$ and $\mathsf{F_i''}$ have the same signature as $\mathsf{F_i}$ and are built recursively from the same induction rules.
\item $\mathsf{F_i = F_i' + F_i''}$ where $\mathsf{F_i'}$ and $\mathsf{F_i''}$ have the same signature as $\mathsf{F_i}$ and are built recursively from the same induction rules.
\item $\mathsf{F_i = F_i' \to F_i''}$
where $\mathsf{F_i'}$ does not contain the recursive variable,
i.e., $\mathsf{F_i' : Set^\beta \to Set}$ is a type constructor of arity $\mathsf{\beta}$,
and $\mathsf{F_i''}$ has the same signature as $\mathsf{F_i}$ and is built recursively from the same induction rules.
\item $\mathsf{F_i\,G\,\ol{B} = G(\ol{F_j\,\ol{B}})}$
where none of the $\mathsf{\alpha}$-many $\mathsf{F_j}$ contains the recursive variable,
i.e., $\mathsf{F_j : Set^\beta \to Set}$
is a type constructor of arity $\mathsf{\beta}$
for each $\mathsf{j = 1, \dots, \alpha}$.
Such restriction is necessary to prevent nesting,
as that would break the induction rule as discussed in Section~\ref{sec:GADT-nested}.
\item $\mathsf{F_i\,G\,\ol{B} = H\,\ol{B}}$
where $\mathsf{H}$ is a type constructor of arity $\mathsf{\beta}$ not containing the recursive variable,
i.e., $\mathsf{H : Set^\beta \to Set}$.
Notice that this covers the case in which $\mathsf{F_i}$ is a closed type,
so, in particular, the unit and empty types, $\mathsf{1}$ and $\mathsf{0}$,
and the case in which $\mathsf{F_i}$ is a variable.
%The only requirement on $\mathsf{H}$ is that it needs to have a predicate-lifting function
%(and any type made of constant types, sums, products, arrow types and other GADTs satisfies this condition).
\item $\mathsf{F_i\,G\,\ol{B} = H (\ol{F_k\,G\,\ol{B}})}$
where $\mathsf{H}$ is a $\mathsf{\gamma}$-ary type constructor not containing the recursive variable,
i.e., $\mathsf{H : Set^\gamma \to Set}$,
and $\mathsf{F_k}$ has the same signature as $\mathsf{F_i}$  and is built recursively from the same induction rules, for every $\mathsf{k = 1 \dots \gamma}$.
Moreover, we require that $\mathsf{H}$ is not a GADT itself (but we allow it to be an ADT or even a nested type).
This way we know that $\mathsf{H}$ admits functorial semantics~\cite{jp20}, and thus there is a map function for $\mathsf{H^{\wedge}}$,
\[
\mathsf{HLMap : \forall (\ol{C : Set}) (\ol{Q_C\;Q_C' : C \to Set})
	\to \ol{PredMap\,C\,Q_C\,Q_C'}
	\to PredMap\,(H\,\ol{C})\,(H^{\wedge}\,\ol{C}\,\ol{Q_C})\,(H^{\wedge}\,\ol{C}\,\ol{Q_C'})}
\]
%where $\mathsf{PredMap : \forall (C : Set) \to (C \to Set) \to (C \to Set) \to Set}$
%is defined as
%\[
%\mathsf{PredMap\,C\,Q_c\,Q_c' = \forall (x : c) \to Q_c\,x \to Q_c'\,x}
%\]
%and represents the type of morphisms between predicates.
A concrete way to define $\mathsf{HLMap}$ is to proceed by induction on the structure of the type $\mathsf{H}$,
and give an inductive definition when $\mathsf{H}$ is an ADT or a nested type.
Such details are not essential to the present discussion, and thus we omit them.
\end{itemize}
We can summarize the above inductive definition with the following grammar
(but beware that the above restrictions and requirements still apply):
\[
\mathsf{F_i\,G\,\ol{B} :=
F_i'\,G\,\ol{B} \times F_i''\,G\,\ol{B}
\ \vert\ F_i'\,G\,\ol{B} + F_i''\,G\,\ol{B}
\ \vert\ F_i'\,\ol{B} \to F_i''\,G\,\ol{B}
\ \vert\ G(\ol{F_j\,\ol{B}})
\ \vert\ H\,\ol{B}
\ \vert\ H (\ol{F_k\,G\,\ol{B}})
}
\]
A further requirement that applies to all of the types appearing above,
including the types $\mathsf{K_i}$,
is that every type needs to have a predicate-lifting function.
This is not an overly restrictive condition, though:
all types made by sums, products, arrow types and type application do, and so do GADTs as defined above.
A concrete way to define the predicate-lifting function for a type is to proceed by induction on the structure of the type,
and we have seen in the previous sections examples of how to do so for products and type application.
We do not give here the general definition of lifting,
as that would require to first present a full type calculus,
and that is beyond the scope of the paper.

%Before proceeding with the derivation of the induction rule for a generic GADT,
%we need to define the type
%\[
%\mathsf{PredMap\,a\,Q_a\,Q_a' = \forall (x : a) \to Q_a\,x \to Q_a'\,x}
%\]
%where $\mathsf{Q_a}$ and  $\mathsf{Q_a'}$ are predicates on  $\mathsf{a : Set}$,
%which represents the type of morphisms between predicates $\mathsf{Q_a}$ and  $\mathsf{Q_a'}$.
%Moreover, if $\mathsf{H}$ is a type constructor having an associated predicate-lifting function $\mathsf{H^{\wedge}}$,
%we define a map function $\mathsf{HLMap}$ for the lifting $\mathsf{H^{\wedge}}$ as
%\[
%\mathsf{HLMap : \forall (a : Set) (Q_a\;Q_a' : a \to Set) \to PredMap\,a\,Q_a\,Q_a' \to PredMap\,(G\,a)\,(G^{\wedge}\,a\,Q_a)\,(G^{\wedge}\,a\,Q_a')}
%\]

Consider a generic GADT as defined above,
\begin{equation}\label{eq:gadt}
\begin{array}{l}
\mathsf{data\ G : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;c\, :\, F\,G\,\ol{B} \to G (K\,\ol{B})}
\end{array}
\end{equation}
which, for ease of notation,
we assume to be a unary type constructor (i.e. it depends on a single type parameter $\mathsf{A}$)
and to have only one constructor $\mathsf{c}$.
Extending the argument to GADTs of arbitrary arity and with multiple constructors presents no difficulty
other than heavier notation.
In the definition above, $\mathsf{F}$ has signature $\mathsf{(Set \to Set) \to Set^{\beta} \to Set}$
and each $\mathsf{K}$ has signature $\mathsf{Set^{\beta} \to Set}$.
The constructor $\mathsf{c}$ can be rewritten using the $\mathsf{Equal}$ type as
\[
\mathsf{c : \forall (\ol{B : Set}) \to Equal\,A\,(K\,\ol{B}) \to F\,G\,\ol{B} \to G\,A}
\]
which is the form we shall use from now on.

In order to state the induction rule for $\mathsf{G}$,
we first need to define $\mathsf{G}$'s associated predicate-lifting function 
\[
\mathsf{G^{\wedge} : \forall (A : Set) \to (A \to Set) \to G\,A \to Set}
\]
as
\[
\mathsf{G^{\wedge}\,A\,Q_A\,(c\,\ol{B}\,e\,x)
= \sum [\ol{Q_B : B \to Set}]\,
Equal^{\wedge}\,A\,(K\,\ol{B})\,Q_A\,(K^{\wedge}\,\ol{B}\,\ol{Q_B})\,e
\times F^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,{\ol{Q_B}}\,x}
\]
where $\mathsf{Q_A : A \to Set}$
and $\mathsf{c\,\ol{B}\,e\,x : G\,A}$,
i.e., $\mathsf{e : Equal\,A\,(K\,\ol{B})}$ and $\mathsf{x : F\,G\,\ol{B}}$.
As already mentioned before, we also assume to have liftings for $\mathsf{F}$,
\[
\mathsf{F^{\wedge} : \forall (G : Set^{\alpha} \to Set) (\ol{B : Set})
\to (\forall (A : Set) \to (A \to Set) \to G\,A \to Set)
\to (\ol{B \to Set})
\to F\,G\,\ol{B} \to Set}
\]
and for  $\mathsf{K}$,
\[
\mathsf{K^{\wedge} : \forall (\ol{B : Set}) \to (\ol{B \to Set}) \to K\,\ol{B} \to Set}
\]
Finally, associate the function
\[
\begin{array}{l}
\mathsf{dIndC = \lambda (P : \forall (A : Set) \to (A \to Set) \to G\,A \to Set)} \\
\quad \mathsf{\to \forall (A : Set) (\ol{B : Set}) (Q_A : A \to Set) (\ol{Q_B : B \to Set}) (e : Equal\,A\,(K\,\ol{B})) (x : F\,G\,\ol{B})} \\
\quad \mathsf{\to Equal^{\wedge}\,A\,(K\,\ol{B})\,Q_A\,(K^{\wedge}\,\ol{B}\,\ol{Q_B})\,e
	\to F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}\,x
	\to P\,A\,Q_A\,(c\,\ol{B}\,e\,x)}
\end{array}
\]
with the constructor $\mathsf{c}$.

%We can now define the induction rule for $\mathsf{G}$
The induction rule for $\mathsf{G}$ is
\[
\mathsf{\forall (P : \forall (A : Set) \to (A \to Set) \to G\,A \to Set) \to dIndC\,P
%\mathsf{\to \Big(
%\forall (\ol{a : Set}) (\ol{b : Set}) (\ol{Q_a : a \to Set}) (\ol{Q_b : b \to Set}) (\ol{e_a : Equal\,a\,(K\,\ol{b})}) (x : F\,G\,\ol{b})} \\
%\mathsf{\to \ol{Equal^{\wedge}\,a\,(K\,\ol{b})\,Q_a\,(K^{\wedge}\,\ol{b}\,\ol{Q_b})\,e_a}
%	\to F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,x
%	\to P\,\ol{a}\,\ol{Q_a}\,(C\,\ol{b}\,\ol{e_a}\,x)
%\Big)} \\
\to \forall (A : Set)(Q_A : A \to Set)(y : G\,A) \to G^{\wedge}\,A\,Q_A\,y \to P\,A\,Q_A\,y}
\]
As we already did in the previous examples,
we validate the induction rule by providing a term $\mathsf{dIndG}$ for the type above.
Define
\[
\mathsf{dIndG\,P\,cc\,A\,Q_A\,(c\,\ol{B}\,e\,x)\,(\ol{Q_B}, liftE, liftF)
= cc\,A\,\ol{B}\,Q_A\,\ol{Q_B}\,e\,x\,liftE\,(p\,x\,liftF)}
\]
where $\mathsf{cc : dIndC\,P}$ and
\begin{itemize}
\item $\mathsf{c\,\ol{B}\,e\,x : G\,A}$,
i.e., $\mathsf{e : Equal\,A\,(K\,\ol{B})}$,
and $\mathsf{x : F\,G\,\ol{B}}$;
\item $\mathsf{(\ol{Q_B}, liftE, liftF) : G^{\wedge}\,A\,Q_A (c\,\ol{B}\,e\,x)}$,
i.e.,
$\mathsf{Q_B : B \to Set}$ for each $\mathsf{B}$,
$\mathsf{liftE : Equal^{\wedge}\,A\,(K\,\ol{B})\,Q_A\,(K^{\wedge}\,\ol{B}\,\ol{Q_B})\,e}$,
and $\mathsf{liftF : F^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,{\ol{Q_B}}\,x}$.
\end{itemize}
Finally, the morphism of predicates
\[
\mathsf{p : PredMap\,(F\,G\,\ol{B})\,(F^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}) (F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B})}
\]
is defined by structural induction on $\mathsf{F}$ as follows:
\begin{itemize}
\item Case $\mathsf{F = F_1 \times F_2}$ where $\mathsf{F_1}$ and $\mathsf{F_2}$ have the same signature as $\mathsf{F}$.
We have that
\[
\mathsf{F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}
= Pair^{\wedge}(F_1\,G\,\ol{B})(F_2\,G\,\ol{B})(F_1^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}) (F_2^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B})}
\]
By inductive hypothesis, there exist morphisms of predicates
\begin{gather*}
\mathsf{p_1 : PredMap\,(F_1\,G\,\ol{B})\,((F_1)^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}) ((F_1)^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B})} \\
\mathsf{p_2 : PredMap\,(F_2\,G\,\ol{B})\,((F_2)^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}) ((F_2)^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B})}
\end{gather*}
Thus, we define $\mathsf{p (x_1, x_2) (liftF_1, liftF_2) = (p_1\,x_1\,liftF_1, p_2\,x_2\,liftF_2)}$ 
for 
$\mathsf{x_1 : F_1\,G\,\ol{B}}$,
$\mathsf{liftF_1 : F_1^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}\,x_1}$,
$\mathsf{x_2 : F_2\,G\,\ol{B}}$
and $\mathsf{liftF_2 : F_2^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}\,x_2}$.
%%%
\item Case $\mathsf{F = F_1 + F_2}$ where $\mathsf{F_1}$ and $\mathsf{F_2}$ have the same signature as $\mathsf{F}$.
Analogous to case $\mathsf{F = F_1 \times F_2}$.
%%%
\item Case $\mathsf{F = F_1 \to F_2}$
where $\mathsf{F_1}$ does not contain the recursive variable,
i.e., $\mathsf{F_1 : Set^\beta \to Set}$,
and $\mathsf{F_2}$ has the same signature as $\mathsf{F}$.
We have that
\[
\mathsf{F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}\,x = \forall (z : F_1\,\ol{B}) \to F_1^{\wedge}\,\ol{B}\,\ol{Q_B}\,z \to F_2^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}\,(x\,z)}
\]
where $\mathsf{x : F\,G\,\ol{B} = F_1\,\ol{B} \to F_2\,G\,\ol{B}}$.
By inductive hypothesis, there exist a morphism of predicates
\[
\mathsf{p_2 : PredMap\,(F_2\,G\,\ol{B}) (F_2^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}) (F_2^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B})}
\]
Thus, we define $\mathsf{p\,x\,liftF : F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}\,x}$
for $\mathsf{liftF : F^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}\,x}$
as $\mathsf{p\,x\,liftF\,z\,liftF_1 = p_2 (x\,z) (liftF\,z\,liftF_1)}$
for $\mathsf{z : F_1\,\ol{B}}$
and $\mathsf{liftF_1 : F_1^{\wedge}\,\ol{B}\,\ol{Q_B}\,z}$.
Notice that $\mathsf{F_1}$ not containing the recursive variable
is a necessary restriction, as the proof relies on
$\mathsf{F^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}\,x}$
and $\mathsf{F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}\,x}$
having the same domain $\mathsf{F_1^{\wedge}\,\ol{B}\,\ol{Q_B}\,z}$.
%%%
\item Case $\mathsf{F\,G\,\ol{B} = G(F'\,\ol{B})}$
where $\mathsf{F'}$ does not contain the recursive variable,
i.e., $\mathsf{F' : Set^\beta \to Set}$.
Thus, $\mathsf{F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B} = P (F'\,\ol{B}) (F'^{\wedge}\,\ol{B}\,\ol{Q_B})}$.
So, $\mathsf{p}$ is defined as
\[
\mathsf{p = dIndG\,P\,cc\,(F'\,\ol{B})\,(F'^{\wedge}\,\ol{B}\,\ol{Q_B})}
\]
%for $\mathsf{L_F : F^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}\,x}$.
%Note that the fact that the type constructor $\mathsf{F'}$ does not contain the recursive variable
%means that $\mathsf{G}$ does not feature nesting.
%As explained and exemplified in Section~\ref{sec:GADT-nested},
%that assumption is required to make induction work.
%%%
\item Case $\mathsf{F\,G\,\ol{B} = H\,\ol{B}}$
where $\mathsf{H}$ is a $\mathsf{\beta}$-ary type constructor not containing the recursive variable,
i.e., $\mathsf{H : Set^\beta \to Set}$.
In such case, $\mathsf{p : PredMap (H\,\ol{B}) (H^{\wedge}\,\ol{B}\,\ol{Q_B}) (H^{\wedge}\,\ol{B}\,\ol{Q_B})}$
is just the identity morphism of predicates.
%%%
\item Case $\mathsf{F\,G\,\ol{B} = H (\ol{F_k\,G\,\ol{B}})}$
where $\mathsf{H}$ is a $\mathsf{\gamma}$-ary type constructor not containing the recursive variable,
i.e., $\mathsf{H : Set^\gamma \to Set}$,
and $\mathsf{F_k}$ has the same signature as $\mathsf{F}$, for every $\mathsf{k = 1 \dots \gamma}$.
Moreover, we assume that $\mathsf{H}$ has an associated predicate-lifting function,
\[
\mathsf{H^{\wedge} : \forall (\ol{C : Set}) \to (\ol{C \to Set}) \to H\,\ol{C} \to Set}
\]
and that this predicate-lifting function has a map function $\mathsf{HLMap}$ of type
\[
\mathsf{\forall (\ol{C : Set}) (\ol{Q_C\;Q_C' : C \to Set}) \to PredMap\,\ol{C}\,\ol{Q_C}\,\ol{Q_C'}
\to PredMap\,(H\,\ol{C})\,(H^{\wedge}\,\ol{C}\,\ol{Q_C})\,(H^{\wedge}\,\ol{C}\,\ol{Q_C'})}
\]
That means that $\mathsf{H}$ cannot be a GADT,
as GADTs have no functorial semantics~\cite{jgj21}.
and incur in the issue exposed in Section~\ref{sec:GADT-nested},
but it can be an ADT or even a nested type as those types have functorial semantics~\cite{jp19,jgj21}.
Thus,
\[
\mathsf{F^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B} = H^{\wedge} (\ol{F_k\,G\,\ol{B}}) (\ol{F_k^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}})}
\]
By induction hypothesis, there is a morphism of predicates
\[
\mathsf{p_k : PredMap\,(F_k\,G\,\ol{B}) (F_k^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}) (F_k^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B})}
\]
for every $\mathsf{k = 1 \dots \gamma}$.
So, $\mathsf{p}$ is defined as
\[
\mathsf{p
= HLMap\,(\ol{F_k\,G\,\ol{B}}) (\ol{F_k^{\wedge}\,G\,\ol{B}\,G^{\wedge}\,\ol{Q_B}}) (\ol{F_k^{\wedge}\,G\,\ol{B}\,P\,\ol{Q_B}})\,\ol{p_k}}
\]
\end{itemize}
%Notice that, by proceeding by structural induction as above,
%we have implicitly defined a grammar for GADTs admitting an induction rule.
%In particular, we allow $\mathsf{F}$ to feature sums, products, arrow types and (limited) type application.



\section{{\color{red}Induction for GADTs with nesting}}\label{sec:GADT-nested}

%%% Change title: something about the inherent limitations of the method
%%% we might want to extend previous result
%%% but we cannot so we already have the best possible result

In the previous sections,
we derive induction rules for examples of GADTs that do not feature nesting,
in the sense that their constructors contain no nested calls of the recursive variable,
as truly nested types (such as $\mathsf{Bush}$, Equation~\ref{eq:bush}) do.
Since both nested types
and GADTs without nesting admit induction rules,
as seen in the previous sections,
it is just natural to expect that GADTs with nesting would as well.
Surprisingly, that is not the case:
indeed, the induction principle generally relies on (unary) parametricity of the semantic interpretation,
and in the case of nested types it also relies on functorial semantics~\cite{jp20},
but GADTs cannot admit both functorial and parametric semantics at the same time~\cite{jgj21}.
In this section we show how induction for GADTs featuring nesting goes wrong
by analyzing the following concrete example of such a type.
\begin{equation}\label{gadt-nested}
\begin{array}{l}
\mathsf{data\, G\,(a : Set) : Set\,where}\\
\mathsf{\;\;\;\;\;\;C :\, G(G\,a) \to G(a \times a)}
\end{array}
\end{equation}
The constructor $\mathsf{C}$ can be rewritten as
\[
\mathsf{C : \exists (b : Set) \to Equal\,a\,(b \times b) \to G(G\,b) \to G\,a}
\]
which is the form we shall use from now on.
The predicate-lifting function of $\mathsf{G}$,
\[
\mathsf{G^{\wedge} : \forall (a : Set) \to (a \to Set) \to G\,\ol{a} \to Set}
\]
is defined as
\[
\mathsf{G^{\wedge}\,a\,Q_a\,(C\,b\,e\,x)
= \exists (Q_b : b \to Set)
\to Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e
\times G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x}
\]
where $\mathsf{Q_a : a \to Set}$, $\mathsf{e : Equal\,a\,(b \times b)}$ and $\mathsf{x : G(G\,b)}$.
Finally, let $\mathsf{CC}$ be the function
\begin{multline*}
\mathsf{\lambda (P : \forall (a : Set) \to (a \to Set) \to G\,a \to Set)} \\
\mathsf{\to \forall (a\;b : Set) (Q_a : a \to Set) (Q_b : b \to Set) (e : Equal\,a\,(b \times b)) (x : G\,(G\,b))} \\
\mathsf{\to Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e
	\to P\,(G\,b)\,(P\,b\,Q_b)\,x
	\to P\,a\,Q_a\,(C\,b\,e\,x)}
\end{multline*}
associated with the $\mathsf{C}$ constructor.

The induction rule for $\mathsf{G}$ is
\begin{multline*}
\mathsf{\forall (P : \forall (a : Set) \to (a \to Set) \to G\,a \to Set) \to CC\,P} \\
\mathsf{\to \forall (a : Set)(Q_a : a \to Set)(y : G\,a) \to G^{\wedge}\,a\,Q_a\,y \to P\,a\,Q_a\,y}
\end{multline*}
Consistently with the previous examples,
to validate the induction rule
we try to define a term of the above type, $\mathsf{DIG}$, as
\[
\mathsf{DIG\,P\,cc\,a\,Q_a\,(C\,b\,e\,x)\,(Q_b, L_E, L_G)
= cc\,a\,b\,Q_a\,Q_b\,e\,x\,L_E\,p}
\]
where $\mathsf{cc : CC\,P}$ and
\begin{itemize}
\item $\mathsf{C\,b\,e\,x : G\,a}$,
i.e., $\mathsf{e : Equal\,a\,(b \times b)}$ and $\mathsf{x : G(G\,b)}$;
\item $\mathsf{(Q_b, L_E, L_G) : G^{\wedge}\,a\,Q_a\,(C\,b\,e\,x)}$,
i.e., $\mathsf{Q_b : b \to Set}$, $\mathsf{L_E : Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e}$,
and $\mathsf{L_G : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x}$.
\end{itemize}
We still need to define $\mathsf{p : P\,(G\,b)\,(P\,b\,Q_b)\,x}$.
We do so by using the induction rule and letting
\[
\mathsf{p = DIG\,P\,cc\,(G\,b)\,(P\,b\,Q_b)\,x\,q}
\]
where we still need to provide $\mathsf{q : G^{\wedge}\,(G\,b)\,(P\,b\,Q_b)\,x}$.
If we had the map function of $\mathsf{G^{\wedge}}$,
\[
\mathsf{GLMap : \forall (a : Set) (Q_a\;Q_a' : a \to Set) \to PredMap\,a\,Q_a\,Q_a' \to PredMap\,(G\,a)\,(G^{\wedge}\,a\,Q_a)\,(G^{\wedge}\,a\,Q_a')}
\]
then we would be able to define
\[
\mathsf{q = GLMap\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,(P\,b\,Q_b)\,(DIG\,P\,cc\,b\,Q_b)\,x\,L_G}
\]
Unfortunately, we cannot define such a $\mathsf{GLMap}$.
Indeed, its definition would have to be
\[
\mathsf{GLMap\,a\,Q_a\,Q_a'\,M\,(C\,b\,e\,x)\,(Q_b, L_E, L_G) = (Q_b', L_E', L_G')}
\]
where $\mathsf{Q_a : a \to Set}$, $\mathsf{Q_a' : a \to Set}$,
$\mathsf{M : PredMap\,a\,Q_a\,Q_a'}$,
$\mathsf{C\,b\,e\,x : G\,a}$, i.e.,
\begin{itemize}
\item $\mathsf{e : Equal\,a\,(b \times b)}$;
\item $\mathsf{x : G\,(G\,b)}$;
\end{itemize}
$\mathsf{(Q_b, L_E, L_G) :G^{\wedge}\,a\,Q_a\,(C\,b\,e\,x)}$, i.e.,
\begin{itemize}
\item $\mathsf{Q_b : b \to Set}$;
\item $\mathsf{L_E : Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e}$;
\item $\mathsf{L_G : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x}$;
\end{itemize}
and $\mathsf{(Q_b', L_E', L_G') : G^{\wedge}\,a\,Q_a'\,(C\,b\,e\,x)}$, i.e.,
\begin{itemize}
\item $\mathsf{Q_b' : b \to Set}$;
\item $\mathsf{L_E' : Equal^{\wedge}\,a\,(b \times b)\,Q_a'\,(Pair^{\wedge}\,b\,b\,Q'_b\,Q'_b)\,e}$;
\item $\mathsf{L_G' : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b')\,x}$;
\end{itemize}
%\begin{gather*}
%\mathsf{Q_a\;Q_a' : a \to Set} \\
%\mathsf{Q_b\;Q_b' : b \to Set} \\
%%\mathsf{M : PredMap\,b\,Q_a\,Q_a'} \\
%\mathsf{L_E : Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e} \\
%\mathsf{L_G\ : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x} \\
%\mathsf{L_E' : Equal^{\wedge}\,a\,(b \times b)\,Q_a'\,(Pair^{\wedge}\,b\,b\,Q'_b\,Q'_b)\,e} \\
%\mathsf{L_G' : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b')\,x}
%\end{gather*}
In other words, we have a proof $\mathsf{L_E}$ of the (extensional) equality
of the predicates $\mathsf{Q_a}$ and $\mathsf{Pair^{\wedge}\,b\,b\,Q_b\,Q_b}$
and a morphism of predicates $\mathsf{M}$ from $\mathsf{Q_a}$ to $\mathsf{Q_a'}$,
and we need to use those to deduce a proof of the (extensional) equality
of the predicates $\mathsf{Q_a'}$ and $\mathsf{Pair^{\wedge}\,b\,b\,Q_b'\,Q_b'}$,
for some  for some predicate $\mathsf{Q_b'}$ on $\mathsf{b}$.
But that is not generally possible:
the facts that $\mathsf{Q_a}$ is equal to $\mathsf{Pair^{\wedge}\,b\,b\,Q_b\,Q_b}$
and that there is a morphism of predicates $\mathsf{M}$ from $\mathsf{Q_a}$ to $\mathsf{Q_a'}$
do not guarantee that $\mathsf{Q_a'}$ is equal to $\mathsf{Pair^{\wedge}\,bb\,Q_b'\,Q_b'}$ for some $\mathsf{Q_b'}$.

At a deeper level, the fundamental issue is that
the $\mathsf{Equal}$ type does not have functorial semantics,
so that having morphisms $\mathsf{A \to A'}$ and $\mathsf{B \to B'}$
and a proof that $\mathsf{A}$ is equal to $\mathsf{A'}$
does not provide a proof that $\mathsf{B}$ is equal to $\mathsf{B'}$.
This is because GADTs can either have a syntax-only semantics or a functorial-completion semantics.
Since we are interested in induction rules, we considered the syntax-only semantics,
which is parametric but not functorial.
Had we considered the functorial-completion semantics, which is functorial,
we would have forfeited parametricity instead.
In both cases, thus, we cannot derive an induction rule for GADTs featuring nesting.
Unlike nestes types, indeed, GADTs do not admit a semantic interpretation that is both parametric and functorial~\cite{jgj21}.



\section{Case Study: Well-typed lambda terms}\label{sec:app}

{\color{red} Can get rid of Maybe using non-empty lists and postulates}

In this section we use deep induction for the $\mathsf{LTerm}$ GADT to 
extract the type from a lambda term. 
We have a predicate 
\begin{align*}
  &\mathsf{getType : \forall \, (a : Set) \to (t : LTerm\,a) \to Set} \\
  &\mathsf{getType \,a \,t = Maybe \, (LType \, a)}
\end{align*}
that takes a lambda term and produces its type (using $\mathsf{Maybe}$ to represent
potential failure).
We want to show this predicate is satisfied for every element of $\mathsf{LTerm\,a}$.
Because of the $\mathsf{ListC}$ constructor, this cannot be achieved without 
deep induction. In particular, deep induction is required to apply the induction to the 
individual terms in a list of terms. 

So, using deep induction, we want to prove: 
\[
  \mathsf{getTypeProof : \forall \, (a : Set) \to (t : LTerm\,a) \to getType \,a \,t} \\
\]
which we prove by 
\[
  \mathsf{getTypeProof \,a \,t = 
    DILTerm\, (\lambda \, b\, Q_b\, t\, \to getType \,b\, t) \,
    gtVar\,  gtABs\,  gtApp\,  gtListC\,  a\,\, K1\,\, t\, (LTerm^{\wedge}K1\, a\, t)
    }
\]
where $\mathsf{K1 : a \to Set}$ is the constantly true predicate:
\[
  \mathsf{K1 \, x = \top}
\]
and $\mathsf{LTerm^{\wedge}K1\, a\, t : LTerm^{\wedge}\, a\, K1\, t}$.
Notice that there is no space in $\mathsf{LTerm^{\wedge}K1}$, because
\[
  \mathsf{LTerm^{\wedge}K1 : \forall (a : Set) (t : LTerm A) \to LTerm^{\wedge}\, a\, K1\,t}
\]
is a function that we will define. In addition to defining $\mathsf{LTerm^{\wedge}K1}$,
we also have to give a proof for each constructor $\mathsf{Var, Abs, App, ListC}$:
\begin{multline*}
  \mathsf{gtVar : \forall (a : Set) (Q_a : a \to Set) (s : String) (T_a : LType\, a) 
      \to LType^{\wedge} \, a\, Q_a\, T_a\, \to Maybe\, (LType\, a)}
\end{multline*}

% abs 
\begin{multline*}
    \mathsf{gtAbs : \forall (a \, b\, c: Set) (Q_a : a \to Set) (Q_b : b \to Set) (Q_c : c \to Set) 
      (e : Equal\, a\, (b \to c)) (s : String)} \\ 
    %
    \mathsf{ (T_b : LType\, b) (t_c : LTerm \, c)
      \to Equal^{\wedge}\, a\, (b \to c)\, Q_a\, (Arr^{\wedge}\, b\, c\, Q_b\, Q_c)\, e
      \to LType^{\wedge} \, b\, Q_b\, T_b} \\ 
    %
    \mathsf{
      \to Maybe\, (LType\,c) \to Maybe\, (LType\, a)}
\end{multline*}

% app 
\begin{multline*}
    \mathsf{gtApp : \forall (a \, b : Set) (Q_a : a \to Set) (Q_b : b \to Set) 
      (t_{ba} : LTerm\, (b \to a)) (t_b : LTerm\, b)} \\ 
    \mathsf{
      \to Maybe\, (LType\, (b \to a))
      \to Maybe\, (LType\, b)
      \to Maybe\, (LType\, a)
    }
\end{multline*}


% list 
\begin{multline*}
    % abs
    \mathsf{gtListC : \forall (a \, b : Set) (Q_a : a \to Set) (Q_b : b \to Set) 
      (e : Equal\, a\, (List\, b)) (ts : List\, (LTerm\, b))} \\ 
    \mathsf{
      \to Equal^{\wedge}\, a\, (List\,b) \, Q_a\, (List^{\wedge}\, b\, Q_b)\, e
      \to List^{\wedge}\, (LTerm\, b)\, (getType\, b)\, ts
      \to Maybe\, (LType\, a)
    }
\end{multline*}


For variables we simply return the type $\mathsf{T_a}$, 
and the cases for abstraction and application are similar.
The interesting case is $\mathsf{gtListC}$, in which we have to use 
the results of ($\mathsf{List^{\wedge}\, (LTerm\, b)\, (getType\, b)\, ts}$)
in order to extract the type of one of the terms in the list. 
To define $\mathsf{gtListC}$ we pattern-match on the list of terms $\mathsf{ts}$.  

If $\mathsf{ts}$ is the empty list (denoted by $\mathsf{[]}$), we cannot extract a type, 
so we return $\mathsf{nothing}$. \\
{\color{red} Maybe handle this case differently, by using non-empty lists, for example}
\[
  \mathsf{gtListC\, a\, b\, Q_a\, Q_b\, e\, [] \, L_e L_{ts} = nothing}
\]
If $\mathsf{ts}$ is a non-empty list, we pattern match on $\mathsf{L_{ts}}$ and use the result
to construct the type we need:
\begin{align*}
  &\mathsf{gtListC\, a\, b\, Q_a\, Q_b\, e\, (t :: ts) \, L_e (nothing , L_{ts}) = nothing} \\
  &\mathsf{gtListC\, a\, b\, Q_a\, Q_b\, e\, (t :: ts) \, L_e (just\, T_b , L_{ts}) = just \, (TList\, b\, e\, T_b)}
\end{align*}
where $\mathsf{e : Equal\, a\, (List\,b)}$ and $\mathsf{T_b : LType\, b}$. 

\subsection{Defining $\mathsf{LTerm^{\wedge}K1}$}

{\color{red} Maybe this section can be deleted by assuming $\mathsf{LTerm^{\wedge}\, a\, K1\,t = K1}$.
Maybe we can say this derives from parametricity.
Currently we say that $\mathsf{K1 \times K1 = K1}$ based on the fact that products are a built-in type and so this seems to be obviously true.}

The last piece of infrastructure we need to define $\mathsf{getTypeProof}$ is a function 
\[
  \mathsf{LTerm^{\wedge}K1 : \forall (a : Set) \to (t : LTerm A) \to LTerm^{\wedge}\, a\, K1\,t}
\]
that provides a 
proof of $\mathsf{LTerm^{\wedge}\,a\,K1\,t}$ for any term $\mathsf{t : LTerm\, a}$. 
Because $\mathsf{LTerm^{\wedge}}$ is defined in terms of $\mathsf{LType^{\wedge}}$, $\mathsf{Arr^{\wedge}}$, 
and $\mathsf{List^{\wedge}}$, we will need analogous functions for these liftings as well. 
We only give the definition of $\mathsf{LTerm^{\wedge}K1}$, but the definitions for 
$\mathsf{LType^{\wedge}}$, $\mathsf{Arr^{\wedge}}$, and $\mathsf{List^{\wedge}}$ are analogous. 

$\mathsf{LTerm^{\wedge}K1}$ is defined by pattern matching on the lambda term $\mathsf{t}$. 
For the $\mathsf{Var}$ case, let $\mathsf{t = (Var\, s\, T_a)}$ and define
\[
  \mathsf{LTerm^{\wedge}K1\,a\,(Var\,s\,T_a) = LType^{\wedge}K1\,a\,T_a}
\]
For the $\mathsf{Abs}$ case, let $\mathsf{t = (Abs \,b \,c \, e \,s \,T_b \, t_c)} $ and recall the 
definition of $\mathsf{LTerm^{\wedge}}$ for the $\mathsf{Abs}$ constructor, 
instantiating the predicate $\mathsf{Q_a}$ to $\mathsf{K1}$: 
% \,a\,Q_a\, (Abs \,b \,c \,e \,s \,T_b \,t_c)}$, :
\begin{multline*}
  \mathsf{LTerm^{\wedge}\,a\,K1\,
  (Abs \,b \,c \,e \,s \,T_b \,t_c)} \\ 
\mathsf{
  = \exists (Q_b : b \to Set) (Q_c : c \to Set) \to
      Equal^{\wedge} \, a\, (b \to c)\, K1\, (Arr^{\wedge} \, b\, c\, Q_b \, Q_c)\, e} \\ 
\mathsf{
      \times \, LType^{\wedge}\, b\, Q_b\, T_b
      \times \, LTerm^{\wedge}\, c\, Q_c\, t_c }
\end{multline*}
so to define the $\mathsf{Abs}$ case of $\mathsf{LTerm^{\wedge}K1}$, we need a proof of 
\[
  \mathsf{Equal^{\wedge} \, a\, (b \to c)\, K1\, (Arr^{\wedge} \, b\, c\, Q_b \, Q_c)\, e}
\]
i.e., that $\mathsf{K1}$ is (extensionally) equal to the lifting $\mathsf{(Arr^{\wedge} \, b\, c\, Q_b \, Q_c)}$
for some predicates $\mathsf{Q_b, Q_c}$. The only reasonable choice for $\mathsf{Q_b}$ and $\mathsf{Q_c}$ 
is to let both be $\mathsf{K1}$, which means we need a proof of:
\[
  \mathsf{Equal^{\wedge} \, a\, (b \to c)\, K1\, (Arr^{\wedge} \, b\, c\, K1 \, K1)\, e}
\]
Since we are working with proof-relevant predicates (i.e., functions into $\mathsf{Set}$ rather than 
functions into $\mathsf{Bool}$), 
the lifting $\mathsf{(Arr^{\wedge} \, b\, c\, K1 \, K1)}$ of $\mathsf{K1}$ to arrow types
is not identical to $\mathsf{K1}$ on arrow types, but the predicates are (extensionally) isomorphic. 
We discuss this issue in more detail at the end of the section. 
For now, we assume a proof 
\[
  \mathsf{Equal^{\wedge}ArrK1 : Equal^{\wedge} \, a\, (b \to c)\, K1\, (Arr^{\wedge} \, b\, c\, K1 \, K1)\, e}
\]
and define the $\mathsf{Abs}$ case of $\mathsf{LTerm^{\wedge}K1}$ as 
\[
  \mathsf{LTerm^{\wedge}K1\,a\, (Abs \,b \,c \, e \,s \,T_b \, t_c) = 
    (K1 , K1 , Equal^{\wedge}ArrK1 , LType^{\wedge}K1 \,b\,T_b\, , LTerm^{\wedge}K1\,c\,t_c)
  }
\]
For the $\mathsf{App}$ case, let $\mathsf{t = (App \,b \,\,t_{ba} \, t_b)}$ and just as we did for the $\mathsf{Abs}$ case, 
recall the definition of $\mathsf{LTerm^{\wedge}\,a\,(App \,b \,\,t_{ba} \, t_b)}$ with all of the predicates
instantiated with $\mathsf{K1}$: 
\[
\mathsf{
      LTerm^{\wedge}\, (b \to a)\, (Arr^{\wedge} \, b\, a\, K1 \, K1)\, t_{ba}
      \times LTerm^{\wedge}\, b\, K1\, t_b }
\]
The second component can be given using $\mathsf{LTerm^{\wedge}K1}$, and we can 
define the first component using a proof of
\[
\mathsf{LTerm^{\wedge}\, (b \to a)\, K1\,\, t_{ba}}
\]
and a map-like function 
\begin{multline*}
  \mathsf{LTerm^{\wedge}EqualMap : \forall\, \{a : Set\} \to (Q_a\,Q'_a : a \to Set) 
    \to (Equal^{\wedge}\,a\,a\,Q_a\,Q'_a\,rfl)} \\
    \mathsf{
    \to PredMap\, (LTerm^{\wedge}\,a\,Q_a)\,(LTerm^{\wedge}\,a\,Q'_a)}
\end{multline*}
that takes two (extensionally) equal predicates with the same carrier 
and produces a morphism of predicates between their liftings. The definition is 
straightforward enough, so we omit the details. 
But it is worth noting that while a true $\mathsf{HLMap}$ function, 
which takes a \emph{morphism} of predicates instead of a proof of equality, cannot be defined 
for GADTs in general, an analogue of $\mathsf{LTerm^{\wedge}EqualMap}$ should be definable 
for every GADT. These analogues of $\mathsf{LTerm^{\wedge}EqualMap}$ will be required to define 
$\mathsf{G^{\wedge}K1}$ whenever $\mathsf{G}$ has a constructor of the form
  ($\mathsf{c : G \, (F\, b) \to G\,(K\,b)}$).

Using $\mathsf{LTerm^{\wedge}EqualMap}$, we can define the $\mathsf{App}$ case of $\mathsf{LTerm^{\wedge}K1}$ as 
\[
  \mathsf{LTerm^{\wedge}K1\,a\, (App \,b \,\,t_{ba} \, t_b) = 
    (K1 , L_{Arr^{\wedge}\,K1} , LTerm^{\wedge}K1\,b\,t_b)}
\]
where $\mathsf{ L_{Arr^{\wedge}\,K1} : LTerm^{\wedge}\, (b \to a)\, (Arr^{\wedge} \, b\, a\, K1 \, K1)\, t_{ba}}$ is defined as
\[
  \mathsf{L_{Arr^{\wedge}\,K1} =  LTerm^{\wedge}EqualMap\,K1\,(Arr^{\wedge}\,b\,a\,K1\,K1)\,\, Equal^{\wedge}ArrK1\, \,\,t_{ba}\, \,L_{K1}}
\]
where $\mathsf{L_{K1} = LTerm^{\wedge}K1\, (b \to a)\, t_{ba} : LTerm^{\wedge}\, (b \to a) \, K1\, t_{ba}}$.

Finally, we define the $\mathsf{ListC}$ case for $\mathsf{LTerm^{\wedge}K1}$. 
Let $\mathsf{t = (ListC\, b\, e\, ts)}$ and recall the definition of $\mathsf{LTerm^{\wedge}\,a\,(ListC\, b\, e\, ts)}$ with
all of the predicates instantiated to $\mathsf{K1}$: 
\[
\mathsf{ Equal^{\wedge} \, a\, (List\,b)\, K1\, (List^{\wedge} \, b\, K1) \, e
      \times List^{\wedge}\, (LTerm\,b) \, (LTerm^{\wedge} \, b\, K1) \, ts }
\]
We can give the first component by assuming a proof \,
$\mathsf{Equal^{\wedge}ListK1 : Equal^{\wedge} \, a\, (List\,b)\, K1\, (List^{\wedge} \, b\, K1) \, e}$, 
but for the second component we again have multiple liftings nested together. In this case, we can 
get a proof of
\[
\mathsf{ List^{\wedge}\, (LTerm\,b) \, (LTerm^{\wedge} \, b\, K1) \, ts }
\]
using 
\[\mathsf{List^{\wedge}map : \forall\, (a : Set) \to (Q_a \, Q'_a : a \to Set) 
  \to PredMap\,Q_a\,Q'_a \to PredMap \,(List^{\wedge}\, a\, Q_a)\, (List^{\wedge}\, a\, Q'_a)}\]
to map a morphism of predicates 
\[
  \mathsf{PredMap \, (K1)\, (LTerm^{\wedge}\,b\,K1)}
\]
to a morphism of lifted predicates
\[
  \mathsf{PredMap \,(List^{\wedge}\,(LTerm\,b)\,K1) \, (List^{\wedge}\,(LTerm\,b)\, (LTerm^{\wedge}\,b\,K1))}
\]

We define the $\mathsf{ListC}$ case of $\mathsf{LTerm^{\wedge}K1}$ as 
\[
  \mathsf{LTerm^{\wedge}K1\,a\, (ListC\, b\, e\, ts) =
    (K1 , \, Equal^{\wedge}ListK1 , \,  L_{List^{\wedge}LTerm^{\wedge}K1} ) }
\]
where
 $\mathsf{L_{List^{\wedge}LTerm^{\wedge}K1} : List^{\wedge}\, (LTerm\,b) \, (LTerm^{\wedge} \, b\, K1) \, ts}$
\[
  \mathsf{ 
 L_{List^{\wedge}LTerm^{\wedge}K1} =
  List^{\wedge}map \, (LTerm\,b) \, K1 \, (LTerm^{\wedge}\, b\, K1) \, m_{K1} \, ts \, (List^{\wedge}K1\, (LTerm\, b)\, ts)
    }
\]
and 
 $\mathsf{m_{K1} : PredMap \, (K1)\, (LTerm^{\wedge}\,b\,K1)}$
\[
  \mathsf{m_{K1} \, t\, \ast\, = LTerm^{\wedge}K1\, b\, t}
\]
where $\mathsf{\ast}$ is the single element of $\mathsf{(K1\, t)}$. 
The use of $\mathsf{List^{\wedge}map}$ is required in the $\mathsf{ListC}$ case because 
$\mathsf{ListC}$ takes an argument of type $\mathsf{List\, (LTerm\, b)}$. 
The same technique can be used to define $\mathsf{G^{\wedge}K1}$ whenever $\mathsf{G}$ has 
a constructor of the form ($\mathsf{c : F \, (G\, a) \to G\, (K\,b)}$). 
We only allow constructors of this form when 
$\mathsf{F}$ is a nested type or ADT, so we are guaranteed to have a $\mathsf{F^{\wedge}map}$ function. 


\subsection{Liftings of $\mathsf{K1}$}
To provide a proof of $\mathsf{G^{\wedge}\, a\, K1 \, t}$ for every term $\mathsf{t : G\, a}$, 
we need to know that the lifting of $\mathsf{K1}$ by a type $\mathsf{H}$ is extensionally equal to $\mathsf{K1}$ on $\mathsf{H}$. 
For example, we might need a proof that $\mathsf{Pair^{\wedge}\,a\,b\,K1\,K1}$ is equal to the predicate $\mathsf{K1}$ on pairs. 
Given a pair $\mathsf{(x , y) : a \times b}$, we have 

\begin{align*}
  &\mathsf{Pair^{\wedge}\,a\,b\,K1\,K1 (x, y)}  \\
  = \, \, &\mathsf{K1 \, x \times K1\, y} \\ 
  = \, \, &\mathsf{\top \times \top}
\end{align*}
while 
\begin{align*}
 \mathsf{K1\, (x, y) = \top}
\end{align*}
and while these types are not equal they are clearly isomorphic. So for simplicity of presentation, we 
assume ($\mathsf{F^{\wedge}\,a\,K1}$) is equal to $\mathsf{K1}$ for every nested type and ADT $\mathsf{F}$. 

%\section{Primitive representation for GADTs}




\section{Conclusion/Related work}

Mention Patricia/Neil2008 paper

No induction with primitive representation (reference Haskell Symposium paper and~\cite{jp19} and paper Patricia Neil Clement 2010)


\section{TODO}

\begin{itemize}
\item find correct entcsmacro file (current one is for 2018). Maybe ask Ana Sokolova (anas@cs.uni-salzburg.at).
\item reference (correctly) Haskell Symposium paper
\item reference inspiration for STLC GADT : https://www.seas.upenn.edu/~cis194/spring15/lectures/11-stlc.html
\end{itemize}

\begin{thebibliography}{10}\label{bibliography}

\bibitem{atk12} Atkey, R.  {\em Relational parametricity for higher
  kinds}.  Computer Science Logic, pp.~46-61, 2012.

\bibitem{bfss90} Bainbridge, E. S., Freyd, P. Scedrov, A., and Scott,
  P. J. {\em Functorial polymorphism}. Theoretical Computer Science
  70(1), pp. 35-64, 1990.

\bibitem{bm98} Bird, R. and Meertens, L. {\em Nested
  datatypes}. Proceedings, Mathematics of Program Construction,
  pp. 52–67, 1998.

\bibitem{ch03} Cheney, J. and Hinze, R. {\em First-class phantom
 types}. CUCIS TR2003-1901, Cornell University, 2003.

\bibitem{ch88} Coquand, T. and Huet, G. {\em The calculus of
  constructions}. Information and Computation 76(2/3), 1988.

\bibitem{chl} Chlipala, A. {\em Library Inductive
  Types}. $\mathtt{http://adam.chlipala.net/cpdt/html/InductiveTypes.html}$

\bibitem{coq20} The Coq Development Team. {\em The Coq Proof
  Assistant}, version 8.11.0, January 2020.
  $\mathtt{https://doi.org/10.5281/zenodo.3744225}$

\bibitem{gjfor15} Ghani, N., Johann, P., Nordvall Forsberg, F.,
  Orsanigo, F., and Revell, T. {\em Bifibrational functorial semantics
    for parametric polymorphism}. Proceedings, Mathematical
  Foundations of Program Semantics, pp. 165-181, 2015.

\bibitem{hin03} Hinze, R. {\em Fun with phantom types}. Proceedings,
 The Fun of Programming, pp. 245–262, 2003.

\bibitem{jgj21f} Johann, P., Ghiorzi, E., and Jeffries, D. {\em
  Parametricity for primitive nested types}. Proceedings, Foundations
  of Software Science and Computation Structures, pp. 324-343, 2021.

\bibitem{jgj21} Johann, P., Ghiorzi, E., and Jeffries, D. {\em
  Parametricity in the presence of GADTs}. Submitted, 2021.

\bibitem{jp19} Johann, P. and Polonsky, A. {\em Higher-kinded data
  types: Syntax and semantics} Proceedings, Logic in Computer Science
  2019. {\color{red} PAGES?}

\bibitem{jp20} Johann, P. and Polonsky, A. {\em Deep induction:
  Induction rules for (truly) nested types}.  Proceedings, Foundations
  of Software Science and Computation Structures, pp. 339-358, 2020.

\bibitem{mac71} MacLane, S. {\em Catgories for the Working
  Mathematician}. Springer, 1971.

\bibitem{mcb99} McBride, C. {\em Dependently Typed Programs and their
  Proofs}. PhD thesis, University of Edinburgh, 1999.

\bibitem{min15} Minsky, Y.  {\em Why {GADT}s matter for performance}.
  $\mathtt{https://blog.janestreet.com/why-gadts-matter-for-performance/}$,
  2015.

\bibitem{pl04} Pasalic, E., and Linger, N.  {\em Meta-programming with
  typed object-language representations}.  Generic Programming and
  Component Engineering, pp.~136-167, 2004.

\bibitem{pen20} Penner, C.  {\em Simpler and safer {API} design using
  {GADT}s}.  $\mathtt{https://chrispenner.ca/posts/gadt-design}$,
  2020.

\bibitem{pvww06} Peyton Jones, S., Vytiniotis, D., Weirich, S., and
  Washburn, G. {\em Simple unification-based type inference for
    GADTs}. Proceedings, International Conference on Functional
  Programming, 2006. {\color{red} PAGES?}

\bibitem{pr06} Pottier, F., and R{\'e}gis-Gianas, Y.  {\em Stratified
  type inference for generalized algebraic data types}.  Principles of
  Programming Languages, pp.~232-244, 2006.

\bibitem{sjsv09} Schrijvers, T, Peyton Jones, S. L., Sulzmann, M., and
  Vytiniotis, D. {\em Complete and decidable type inference for
    GADTs}. Proceedings, International Conference on Functional
  Programming, pp. 341– 352, 2009.

\bibitem{sp04} Sheard, T., and Pasalic, E. {\em Meta-programming with
  built-in type equality}. Proceedings, Workshop on Logical Frameworks
  and Meta-languaegs, 2004. {\color{red} PAGES?}

\bibitem{xcc03} Xi, H., Chen, C. and Chen, G. {\em Guarded recursive
  datatype constructors}. Proceedings, Principles of Programming
  Languages, pp. 224–235, 2003.

\bibitem{vw10} Vytiniotis, D., and Weirich, S.  {\em Parametricity,
  type equality, and higher-order polymorphism}.  Journal of
  Functional Programming 20(2), pp.~175--210, 2010.

\end{thebibliography}

\end{document}



