\documentclass[9pt]{entcs} \usepackage{entcsmacro}
\usepackage{graphicx}
\sloppy
% The following is enclosed to allow easy detection of differences in
% ascii coding.
% Upper-case    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
% Lower-case    a b c d e f g h i j k l m n o p q r s t u v w x y z
% Digits        0 1 2 3 4 5 6 7 8 9
% Exclamation   !           Double quote "          Hash (number) #
% Dollar        $           Percent      %          Ampersand     &
% Acute accent  '           Left paren   (          Right paren   )
% Asterisk      *           Plus         +          Comma         ,
% Minus         -           Point        .          Solidus       /
% Colon         :           Semicolon    ;          Less than     <
% Equals        =3D           Greater than >          Question mark ?
% At            @           Left bracket [          Backslash     \
% Right bracket ]           Circumflex   ^          Underscore    _
% Grave accent  `           Left brace   {          Vertical bar  |
% Right brace   }           Tilde        ~

\bibliographystyle{entcs}

% A couple of exemplary definitions:

\newcommand{\Nat}{{\mathbb N}}
\newcommand{\Real}{{\mathbb R}}
\def\lastname{Johann, Ghiorzi, and Jeffries}

\usepackage{amsmath}

\input{macros}




\begin{document}
\begin{frontmatter}
  \title{(Deep) Induction for GADTs}

  \author{Patricia Johann\thanksref{JohannEmail}}
  \author{Enrico Ghiorzi\thanksref{GhiorziEmail}}
  \author{Daniel Jeffries\thanksref{JeffriesEmail}}
  \thanks[JohannEmail]{Email: \href{mailto:johannp@appstate.edu} {\texttt{\normalshape johannp@appstate.edu}}}
  \thanks[GhiorziEmail]{Email: \href{mailto:ghiorzie@appstate.edu} {\texttt{\normalshape ghiorzie@appstate.edu}}}
  \thanks[JeffriesEmail]{Email: \href{mailto:jeffriesd@appstate.edu} {\texttt{\normalshape jeffriesd@appstate.edu}}}
  \address{Department of Computer Science\\ Appalachian State University}

\begin{abstract} 
  Abstract goes here.
\end{abstract}

\begin{keyword}
  Please list keywords from your paper here, separated by commas.
\end{keyword}

\end{frontmatter}



\section{Introduction}\label{sec:intro}

Introduction goes here.



\section{Deep induction for ADTs and nested types}

%\begin{itemize}
%\item Say what ADTs and nested types are (look~\cite{jp20,jgj21})
%\item Examples: $\mathsf{List}$ and $\mathsf{PTree}$ and $\mathsf{Bush}$
%\item Explain induction for $\mathsf{List}$ and $\mathsf{PTree}$ (refer paper Patricia Neil Clement 2010) notice it does not extend to truly nested types like $\mathsf{Bush}$
%\item To get induction rule for truly nested types such as $\mathsf{Bush}$ requires deep induction (refer to~\cite{jp20}) (explain various pieces of deep induction, including lifting, informally)
%\item Deep induction makes sense for other structures as well (not just truly nested types)
%\end{itemize}

\subsection{Syntax of ADTs and nested types}\label{ssec:syntax-adts}

\emph{(Polynomial) algebraic data types} (ADTs), both built-in and user-defined,
have long been at the core of functional languages such as Haskell, ML, Agda, Epigram, and Idris.
ADTs are used extensively in functional programming to structure computations,
to express invariants of the data over which computations are defined,
and to ensure the type safety of programs specifying those computations.
ADTs include unindexed types, such as the type of natural numbers,
and types indexed over other types, such as the quintessential example of an ADT,
the type of lists (here coded in Agda)
\begin{equation}\label{eq:list}
\begin{array}{l}
\mathsf{data\ List : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;nil\,\,\,\,\,\, :\, List\,A}\\
\mathsf{\;\;\;\;\;\;\;cons\, :\, A \to List\,A \to List\,A} 
\end{array}
\end{equation}
Notice that all occurrences of $\mathsf{List}$ in the above encoding are instantiated at the same index $\mathsf{A}$.
Thus, the instances of $\mathsf{List}$ at various indices are defined independently from one another.
That is a defining feature of ADTs:
an ADT defines a \emph{family of inductive types}, one for each index type.

Over time, there has been a notable trend toward data types
whose non-regular indexing can capture invariants and other sophisticated properties
that can be used for program verification and other applications.
A simple example of such a type is given by Bird and Meertensâ€™~\cite{bm98} prototypical \emph{nested type}
\begin{equation}\label{eq:ptree}
\begin{array}{l}
\mathsf{data\ PTree : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;pLeaf\,\,\, :\, A \to PTree\,A}\\
\mathsf{\;\;\;\;\;\;\;pNode\, :\, PTree\,(A \times A) \to PTree\,A} 
\end{array}
\end{equation}
of perfect trees, which can be thought of as constraining lists to have lengths that are powers of 2.
In the above code, the constructor $\mathsf{PNode}$ uses data of type $\mathsf{PNode\,(A \times A)}$ to construct data of type $\mathsf{PNode\,A}$.
Thus, it is clear that the instantiations of $\mathsf{PNode}$ at various indices cannot be defined independently, so that the entire family of types must actually be defined at once.
A nested type thus defines not a family of inductive types, but rather an \emph{inductive family of types}.

Nested types include simple nested types, like perfect trees,
none of whose recursive occurrences occur below another type constructor,
and \emph{truly} nested types, such as the nested type
\begin{equation}\label{eq:bush}
\begin{array}{l}
\mathsf{data\ Bush : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;bNil\,\,\,\,\,\, :\, Bush\,A}\\
\mathsf{\;\;\;\;\;\;bCons\, :\, A \to Bush\,(Bush\,A) \to Bush\,A} 
\end{array}
\end{equation}
of bushes, whose recursive occurrences appear below their own type constructors.
Note that, while the constructors of a nested type can contain occurrences of the type instantiated at any index,
the return types of its constructors still have to be the same type instance of the type being defined.
In other words, all constructors of $\mathsf{PTree\,A}$ have to return an element of type $\mathsf{PTree\,A}$,
and all constructors of $\mathsf{Bush\,A}$ have to return an element of type $\mathsf{Bush\,A}$.
%the return types of the constructors are still required to be instantiated at the same variable $\mathsf{a}$.}
%As previously noted, the return types of the constructors of a nested
%type have to be the same type instance of the type being defined.


\subsection{Induction principles for ADTs and nested types}\label{ssec:induction-nested}

An induction principle for a data type allows to prove
that a predicate holds for every element of that data type,
provided that it holds for every element inductively produced by the type's constructors.
In this paper, we are interested in induction principles for proof-relevant predicates.
A proof-relevant predicate on a type $\mathsf{A : Set}$ is a function $\mathsf{A \to Set}$
%(where $\mathsf{Set}$ is the type of sets)
mapping each $\mathsf{x : A}$ to the set of proofs that the predicate holds for $\mathsf{x}$.
For example, the induction principle for $\mathsf{List}$ is
\begin{equation*}
\mathsf{
\forall (A : Set) (P : List\,A \to Set)
\to P\,Nil
\to \big( \forall (a : A) (ls: List\,A)
\to P\,ls
\to P\,(Cons\,a\,ls)\big)
\to \forall (ls : List\,A)
\to P\, ls
}
\end{equation*}
Note that the data inside a structure of type $\mathsf{List}$ is treated monolithically (i.e., ignored) by this induction rule.
Indeed, the induction rule inducts over only the top-level structures of data types,
leaving any data internal to the top-level structure untouched.
Since this kind of induction principle is only concerned with the structure of the type,
and unconcerned with the contained data,
we will then refer to it as \emph{structural induction}.

We can extend such a structural induction principle to some nested types, such as $\mathsf{PTree}$.
The only difference from the induction principle for ADTs is that,
since a nested type is defined as a whole inductive family of types at once,
its induction rule has to necessary involve a polymorphic predicate.
Thus, the induction rule for $\mathsf{PTree}$ is
\[
\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to PTree\, A \to Set)
\to \big( \forall (A : Set) (a : A) \to P\,A\,(PLeaf\, a) \big)} \\
\quad\mathsf{\to \big( \forall (A : Set) (pt : PTree\,(A \times A)) \to P\,(A \times A)\,pt \to P\,a\,(PNode\,pt)\big)
\to \forall (A : Set) (pt : PTree\,A) \to P\,A\,pt }
\end{array}
\]

%This kind of induction principles, which we will call \emph{structural induction},
Structural induction principles cannot be extended to truly nested types, such as $\mathsf{Bush}$.
%To induce over a truly nested type, we need to use a \emph{deep induction} principle~\cite{jp20}.
Instead, for such data types it is necessary to use a \emph{deep induction} principle~\cite{jp20}.
Such a principle, unlike structural induction, inducts over all of the structured data present,
by traversing not just the outer structure with a predicate $\mathsf{P}$,
but also each data element contained in the data type with a custom predicate $\mathsf{Q}$.
This additional predicate is lifted to predicates on any internal structure containing these data, and the resulting predicates on these internal structures are lifted to predicates on any internal structures containing structures at the previous level, and so on, until the internal structures at all levels of the data type definition, including the top level, have been so processed.
Satisfaction of a predicate by the data at one level of a structure is then conditioned upon satisfaction of the appropriate predicates by all of the data at the preceding level.

For example, the deep induction rule for $\mathsf{Bush}$ is
\[
\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to (A \to Set) \to Bush\, A \to Set)
\to \big( \forall (A : Set) \to P\,A\,BNil \big)} \\
\quad\mathsf{\to \big( \forall (A : Set) (Q : A \to Set) (a : A) (bb : Bush\,(Bush\,A))
\to Q\,a \to P\,(Bush\,A)\,(Bush^{\wedge}\,A\,Q)\,bb \to P\,A\,Q\,(BCons\,a\,bb) \big)} \\
\quad\mathsf{\to \forall (A : Set) (Q : A \to Set) (b : Bush\,A) \to Bush^{\wedge}\,A\,Q\,b \to P\,A\,Q\,b }
\end{array}
\]
where $\mathsf{Bush^{\wedge} : \forall (A : Set) \to (A \to Set) \to Bush\,A \to Set}$ lifts a predicate $\mathsf{Q}$ on data of type $\mathsf{A}$ to a predicate on data of type $\mathsf{Bush\,A}$ asserting that $\mathsf{Q}$ holds for every element of type $\mathsf{A}$ contained in its argument bush.
It is defined as
\begin{align*}
\mathsf{Bush^{\wedge}\,A\,Q\,BNil} &= \mathsf{\top} \\
\mathsf{Bush^{\wedge}\,A\,Q\,(BCons\,a\,bb)} &= \mathsf{Q\,a \times Bush^{\wedge}\,(Bush\,A)\,(Bush^{\wedge}\,A\,Q)\,bb}
\end{align*}
where $\mathsf{Q : A \to Set}$ and $\mathsf{bb : Bush\,(Bush\,A)}$.

Despite deep induction being motivated by the need to produce an induction principle for truly nested types,
it can equally be applied to all other ADTs and nested types.
For example, the deep induction principle for $\mathsf{List}$ is
\[
\begin{array}{l}
\mathsf{\forall (A : Set) (P : List\, A \to Set) (Q : A \to Set)
\to P\,Nil \to \big( \forall (a : A) (ls: List\,A) \to Q\,a \to P\,ls \to P\,(Cons\,a\,ls)\big)} \\
\quad\mathsf{\to \forall (ls : List\,A) \to List^{\wedge}\,A\,Q\,ls \to P\,ls }
\end{array}
\]
where $\mathsf{List^{\wedge} : \forall (A : Set) \to (A \to Set) \to List\,A \to Set}$ lifts a predicate $\mathsf{Q}$ on data of type $\mathsf{A}$ to a predicate on data of type $\mathsf{List\,A}$ asserting that $\mathsf{Q}$ holds for every element of its argument list.

As a further example, the deep induction rule for $\mathsf{PTree}$ is
\[
\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to (A \to Set) \to PTree\,A \to Set)
  \to \big( \forall (A : Set) (Q : A \to Set) (a : A) \to Q\,a \to P\,A\,Q\,(PLeaf\, a) \big)} \\
\quad \mathsf{\to \big( \forall (A : Set) (Q : A \to Set) (a : PTree\,(A \times A)) \to P\,(A \times A)\,(Pair^{\wedge}\,A\,A\,Q\,Q)\,a \to P\,A\,Q\,(PNode\,a)\big)} \\
\quad \mathsf{\to \forall (A : Set) (Q : A \to Set) (a : PTree\,a) \to PTree^{\wedge}\,A\,Q\,a \to P\,A\,Q\,a }
\end{array}
\]
where $\mathsf{Pair^{\wedge} : \forall (A : Set) (B : Set) \to (A \to Set) \to (B \to Set) \to A \times B \to Set}$ lifts predicates $\mathsf{Q_A}$ on data of type $\mathsf{A}$ and $\mathsf{Q_B}$ on data of type $\mathsf{B}$ to a predicate on pairs of type $\mathsf{A \times B}$,
so that $\mathsf{Pair^{\wedge}\,A\,B\,Q_A\,Q_B\,(a,b) = Q_A\,a \times Q_B\,b}$,
and $\mathsf{PTree^{\wedge} : \forall (A : Set) \to (A \to Set) \to PTree\,A \to Set}$ lifts a predicate $\mathsf{Q}$ on data of type $\mathsf{A}$ to a predicate on data of type $\mathsf{PTree\,A}$ asserting that $\mathsf{Q}$ holds for every element of type $\mathsf{A}$ contained in its argument perfect tree.

Moreover, for types admitting both deep induction and structural induction, the former generalizes the latter.
Indeed, structural induction rules can be derived from deep induction rules by always choosing the constantly true predicate as the custom predicate traversing each data element contained in the data type.
That way, deep induction only inspects the structure of the data type and not its content, just like structural induction does.
A concrete example of such derivation is demonstrated in Section~\ref{sec:ind-equal}.



\section{Introducing GADTs}

%\begin{itemize}
%\item Say what GADTs are
%\item Example: $\mathsf{Equal}$
%\[\begin{array}{l}
%\mathsf{data\, Equal\,a\,b\,where}\\
%\mathsf{\;\;\;\;\;\;\;\;Refl ::\, Equal\,c\,c}
%\end{array}\]
%\item GADTs' encoding using $\mathsf{Equal}$
%\item Example (in Haskell syntax):
%%Haskell definition of $\mathsf{Seq}$ %(this encoding might have been introduced after the other one, see phantom types)
%\begin{equation}\label{eq:seq}
%\begin{array}{l}
%\mathsf{data\, Seq\,a\,where}\\
%\mathsf{\;\;\;\;\;\;\;\;Const ::\, a \to Seq\,a}\\
%\mathsf{\;\;\;\;\;\;\;\;SPair\,\, ::\, Seq \,a \to Seq\,b \to
%  Seq\,(a \times b)}
%\end{array}
%\end{equation}
%\item Traditionally GADTs are understood in terms of $\mathsf{Equal}$ data type (see Cheney Hinze or Tim Sheard)
%For example
%\begin{equation}\label{eq:eq_seq}
%\begin{array}{l}
%\mathsf{data\, Seq\,a\,where}\\
%\mathsf{\;\;\;\;\;\;\;\;Const ::\, a \to Seq\,a}\\
%\mathsf{\;\;\;\;\;\;\;\;SPair\,\, ::\, \exists (b : Set) (c : Set).\,Equal\,a\,(b \times c) \to Seq\,b \to Seq\,c \to
%  Seq\,a}\\ 
%\end{array}
%\end{equation}
%(This gives the kind of Church encoding that is in Bob's paper) (might omit)
%\item Add example for GADT with deep structure (Ask Daniel which one)
%\end{itemize}
%%Equality version of $\mathsf{Seq}$ (see Cheney Hinze or Tim Sheard)

As noted in Subsection~\ref{ssec:syntax-adts},
the return types of the constructors of a nested
type have to be the same type instance of the type being defined.
As a further generalization of ADTs and nested types,
\emph{generalized algebraic data types} (GADTs)~\cite{ch03,xcc03,sp04}
relax the restriction on the type instances appearing in a data
type definition by allowing their constructors both to take as
arguments \emph{and return as results} data whose types involve type
instances of the GADT other than the one being defined.

GADTs are used in precisely those situations in which different
behaviors at different instances of a data type are desired. This is
achieved by allowing the programmer to give the type signatures of the
GADT's data constructors independently, and then using pattern
matching to force the desired type refinement. Applications of GADTs
include generic programming, modeling programming languages via
higher-order abstract syntax, maintaining invariants in data
structures, and expressing constraints in embedded domain-specific
languages. GADTs have also been used, e.g., to implement tagless
interpreters~\cite{pl04,pr06,pvww06}, to improve memory
performance~\cite{min15}, and to design APIs~\cite{pen20}.

\begin{example}\label{example:equal}
As a first and notable example of GADT, we consider the the $\mathsf{Equal}$ type.
This GADT is parametrized by two type indices,
but it is only possible to construct a data element if the two indices are instantiated at the same type.
In Agda, we code it as
\begin{equation}\label{eq:equal}
\begin{array}{l}
\mathsf{data\ Equal : Set \to Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;\;\;\;\,refl :\, Equal\,A\,A}
\end{array}
\end{equation}
$\mathsf{Equal}$ has thus a single data element when its two type arguments
are the same and no data elements otherwise.
The importance of the $\mathsf{Equal}$ type lies in the fact that we can understand other GADTs in terms of equality,
as shown in the examples below.
\end{example}

\begin{example}\label{example:seq}
A more complex example of GADT is the type of sequences,
\begin{equation}\label{eq:eq-seq}
\begin{array}{l}
\mathsf{data\ Seq : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;const :\, A \to Seq\,A}\\
\mathsf{\;\;\;\;\;\;\;\;sPair\,\, :\, Seq\,A \to Seq\,B \to Seq\,(A \times B)}
\end{array}
\end{equation}
which comprises sequences of any type $\mathsf{a}$
and sequences obtained by pairing the data in two already existing sequences.
Such GADTs can be understood in terms of the $\mathsf{Equal}$ data type~\cite{ch03,sp04}.
For example, we can rewrite the $\mathsf{Seq}$ type as
\begin{equation}\label{eq:eq_seq}
\begin{array}{l}
\mathsf{data\ Seq : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;const :\, A \to Seq\,A}\\
\mathsf{\;\;\;\;\;\;\;\;sPair\,\, :\, \forall (B\,C : Set) \to Equal\,A\,(B \times C)
  \to Seq\,B \to Seq\,C \to Seq\,A}\\ 
\end{array}
\end{equation}
where the requirement that the $\mathsf{sPair}$ constructor produces an instance of $\mathsf{Seq}$ at a product type has been replaced with the requirement that the instance of $\mathsf{Seq}$ returned by $\mathsf{sPair}$ is \emph{equal} to some product type.
This encoding is particularly convenient when representing GADTs as Church encodings~\cite{vw10,atk12}.
\end{example}

%To determine the possible shapes of a GADT's container we must
%pattern-match on the type of the data to be contained.
%For this, it is essential that a GADT calculus support an equality type
%$\mathsf{Equal}$ that is a singleton set when its two type arguments
%are the same and is the empty set otherwise.
%That is, the type $\mathsf{Equal}$ must be the syntactic reflection
%of semantic equality function $\mathit{Equal}$.
%The type $\mathsf{Equal}$ can either be
%defined via GADT syntax, as in
%\[\begin{array}{l}
%\mathsf{data\, Equal\,a\,b\,where}\\
%\mathsf{\;\;\;\;\;\;\;\;Refl ::\, Equal\,c\,c}
%\end{array}\]

\begin{example}\label{example:lterm}
GADTs are expressive enough to represent, for example, the types and terms of the simply typed lambda calculus. 
We will use a variant of the simply typed lambda calculus including a base type of booleans,
and type constructors for arrow types and list types. 
We define a GADT $\mathsf{LType}$ to encode the set of permissible types for this calculus:
\begin{equation}\label{eq:eq_ltype}
\begin{array}{l}
\mathsf{data\ LType : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;tBool :\, \forall (B : Set) \to Equal\,A\,Bool \to LType\,A}\\
\mathsf{\;\;\;\;\;\;\;\;tArr\,\,\, :\, \forall (B\,C : Set) \to Equal\,A\,(B \to C) \to LType\,B \to LType\,C \to LType\,A}\\
  \mathsf{\;\;\;\;\;\;\;\;tList\,\, :\, \forall (B : Set) \to Equal\,A\,(\List\,B) \to LType\,B \to LType\,A}
\end{array}
\end{equation}
The type system includes a $\mathsf{tBool}$ constructor representing the type of booleans;
an arrow type constructor, $\mathsf{tArr}$ , which takes two types $\mathsf{B}$ and $\mathsf{C}$
and produces the arrow type $\mathsf{B \to C}$;
and a $\mathsf{tList}$ constructor which takes a type $\mathsf{B}$ and constructs
the type $\mathsf{List\,B}$.

%The $\mathsf{tBool}$ constructor represents the type of booleans in the calculus.
%%It is defined in terms of $\mathsf{KBool : Set \to Set}$,
%%which simply returns $\mathsf{Bool}$ on any input: $\mathsf{KBool \, A = Bool}$.
%%The lifting $\mathsf{KBool^{\wedge} : \forall (A : Set) \to (A \to Set) \to (KBool \, A) \to Set}$ lifts every predicate to the constantly true predicate: 
%%\[
%%  \mathsf{KBool^{\wedge}\, A\, Q\, b = \top}
%%\]
%% The $\mathsf{Bool}$ data type is defined as:
%% \begin{equation}\label{eq:bool}
%% \begin{array}{l}
%% \mathsf{data\, Bool\,: Set\,where}\\
%%   \mathsf{\;\;\;\;\;\;\;\;true :\, Bool} \\
%%   \mathsf{\;\;\;\;\;\;\;\;false:\, Bool} \\
%% \end{array}
%% \end{equation}
%The type system also includes an arrow type constructor, $\mathsf{tArr}$ , which takes two types $\mathsf{B}$ and $\mathsf{C}$
%and produces the arrow type $\mathsf{B \to C}$.
%Similarly, given a type $\mathsf{B}$, we can construct
%the type $\mathsf{List\,B}$ using the $\mathsf{tList}$ constructor.

The term calculus for this type system includes variables, abstraction, application, 
and also includes an introduction rule that takes a list of lambda terms of type $\mathsf{B}$ and produces a lambda term of type $\mathsf{List\,B}$.
\begin{equation}\label{eq:eq_lterm}
\begin{array}{l}
\mathsf{data\ LTerm : Set \to Set\ where}\\
\mathsf{\;\;\;\;\;\;\;\;var\,\,\,\,\,\,\,:\, String \to LType\,A \to LTerm\,A} \\
\mathsf{\;\;\;\;\;\;\;\;abs\,\,\,\,\,\, :\, \forall (B\,C : Set) \to Equal\,A\,(B \to C) \to String 
      \to LType\,B \to LTerm\,C \to LTerm\,A}\\
  \mathsf{\;\;\;\;\;\;\;\;app\,\,\,\,\, :\, \forall (B : Set) \to LTerm (B \to A) \to LTerm\,B \to LTerm\,A} \\
  \mathsf{\;\;\;\;\;\;\;\;listC\,\,\, :\, \forall (B : Set) \to Equal\,A\,(List\,B) \to List\,(LTerm\,B) \to LTerm\,A}
\end{array}
\end{equation}
The type parameter for $\mathsf{LTerm}$ tracks the types of simply typed lambda calculus terms.
So the type $\mathsf{LTerm\,A}$ contains lambda terms of type $\mathsf{A}$. 
Variables are represented as strings and are tagged with their type.
The $\mathsf{var}$ constructor takes a variable name and a type for the variable and produces
a term of the given type.
The $\mathsf{abs}$ constructor takes a variable name, a type $\mathsf{B}$ for the variable,
and a lambda term of type $\mathsf{C}$ for the body of the abstraction,
and it produces a term of type $\mathsf{B \to C}$.
The $\mathsf{app}$ constructor applies a lambda term of type $\mathsf{B \to A}$ to a lambda term of type $\mathsf{B}$,
producing a lambda term of type $\mathsf{A}$. 
The $\mathsf{listC}$ constructor takes a list of lambda terms of type $\mathsf{B}$ and produces a lambda term of type $\mathsf{List\,B}$.

Variables are tagged with their types in the $\mathsf{var}$ (variable introduction) and 
$\mathsf{abs}$ (abstraction) constructors.
The role of $\mathsf{LType}$ in the $\mathsf{var}$ and $\mathsf{abs}$ constructors
is to enforce that variables can only be tagged with a legal type, e.g., $\mathsf{Bool}$, 
$\mathsf{Bool \to Bool}$, $\mathsf{List\, (Bool \to Bool)}$, etc. 
Therefore the presence of $\mathsf{LType}$ in these constructors ensures that all lambda terms produced by 
$\mathsf{var}$, $\mathsf{abs}$, $\mathsf{app}$, and $\mathsf{listC}$ are well-typed. 
\end{example}



\section{(Deep) induction for GADTs}

%\begin{itemize}
%    \item Recall structural induction does not work for GADTs because it does not work for truly nested types.
%    \item Induction rules are traditionally derived using functoriality
%    \item This cannot be extended to GADTs in this setting because they have no functorial semantics
%    \item This paper nevertheless shows how to extend (deep) induction to GADTs.
%\end{itemize}

%As we have seen in Section~\ref{ssec:induction-nested},
%truly nested types do not support a structural induction rule,
%which is the reason why it was necessary to introduce a deep induction rule supporting them.
%Consequently, GADTs do not support a structural induction rule either,
%as they generalize nested types.
%Still, there is hope for GADTs to support a deep induction rule,
%like nested types do.

Reasoning about GADTs can generally be quite difficult,
even more so than for ADTs and nested types.
To help with that,
we want to extend the deep induction principle seen in Section~\ref{ssec:induction-nested} to GADTs.

Induction rules, and specifically deep induction rules for nested types,
are traditionally derived using the functorial semantics of data types
in the setting of a parametric model~\cite{jp19}.
In particular, relational parametricity is used to validate the induction principle because induction is, itself,
a form of unary parametricity, where binary relations have been replaced with predicates,
which are essentially unary relations.
{\color{blue} Is there a reference for this?}
%in the sense that induction involves predicates, which are unary relations,
%as opposed to the binary relations involved in relational parametricity.

Unfortunately, this approach cannot possibly be employed
to prove a deep induction rule for GADTs,
as these types do not allow for a functorial interpretation,
at least in a parametric model~\cite{Haskell-paper}.

Nevertheless, this paper shows how to extend deep induction to some GADTs.
We will first demonstrate how to derive the deep induction rule for some example cases,
and then provide a general principle that works for generic GADTs,
as long as these do not feature nesting in their definition.



\subsection{(Deep) induction for $\mathsf{Equal}$}\label{sec:ind-equal}

%\begin{itemize}
%\item Define $\mathsf{Equal}^{\wedge}$
%\[
%\mathsf{Equal^{\wedge} : \forall (a : Set) (b : Set) \to (a \to Set) \to (b \to Set) \to Equal\,a\,b \to Set}
%\]
%is defined by
%\[
%\mathsf{Equal^{\wedge}\,a\,a\,Q\,Q'\,Refl = \forall (x : a) \to Equal\,(Q\,x)(Q'\,x)}
%\]
%\item (Deep) induction rule for $\mathsf{Equal}$
%\item Prove deep induction for $\mathsf{Equal}$ (define term)
%\end{itemize}

As a first example, we derive the induction rule for the $\mathsf{Equal}$ type from example~\ref{example:equal}.
This will provide a simple case study that will inform the investigation of more complex GADTs.
Moreover, since we define GADTs using the $\mathsf{Equal}$ type,
as for example in Equation~\ref{eq:eq-seq},
this example will be instrumental in stating and deriving the induction rule of other GADTs.

To define an induction rule for a type $\mathsf{G}$ we first need a predicate-lifting operation
which takes predicates on a type $\mathsf{A}$ and lifts them to predicates on $\mathsf{G\,A}$.
the predicate-lifting function for $\mathsf{Equal}$ is the function
\[
\mathsf{Equal^{\wedge} : \forall (A\,B : Set) \to (A \to Set) \to (B \to Set) \to Equal\,A\,B \to Set}
\]
defined as
\[
\mathsf{Equal^{\wedge}\,A\,A\,Q\,Q'\,Refl = \forall (a : A) \to Equal\,(Q\,a)(Q'\,a)}
\]
i.e., the function that takes two predicates on the same type and tests them for extensional equality.

Next, we need to associate each constructor of the GADT under consideration
to the expression that a given predicate is preserved by such constructor.
Let $\mathsf{dIndRefl}$ be the following function associated to the $\mathsf{refl}$ constructor:
\[
\begin{array}{l}
\mathsf{\lambda (P : \forall (A\,B : Set) \to (A \to Set) \to (B \to Set) \to Equal\,A\,B \to Set)} \\
\quad\mathsf{\to \forall (C : Set) (Q\, Q' : C \to Set) \to Equal^{\wedge}\,C\,C\,Q\,Q'\,refl \to P\,C\,C\,Q\,Q'\,refl}
\end{array}
\]

The induction rule states that,
if a predicate is preserved by all of the constructors of the GADT under consideration,
then the predicate is satisfied by any element of the GADT.
The induction rule for $\mathsf{Equal}$ is thus the type
\[
\begin{array}{l}
\mathsf{\forall (P : \forall (A\,B : Set) \to (A \to Set) \to (B \to Set) \to Equal\,A\,B \to Set)} \\
\quad \mathsf{\to dIndRefl\,P \to \forall (A\,B : Set) (Q_A : A \to Set) (Q_B : B \to Set) (e: Equal\,A\,B)
  \to Equal^{\wedge}\,A\,B\,Q_A\,Q_B\,e \to P\,A\,B\,Q_A\,Q_B\,e}
\end{array}
\]
To validate the induction rule we need to provide it with a witness, i.e.,
we need to show that the associated type is inhabited.
We thus need to define a term $\mathsf{dIndEqual}$ of the above type,
i.e., we need to define
\[
\mathsf{dIndEqual\,P\,crefl\,A\,B\,Q_A\,Q_B\,e\,liftE : P\,A\,B\,Q_A\,Q_B\,e}
\]
for $\mathsf{crefl : dIndRefl\,P}$,
$\mathsf{Q_A : A \to Set}$, $\mathsf{Q_B : B \to Set}$,
$\mathsf{e : Equal\,A\,B}$
and $\mathsf{liftE : Equal^{\wedge}\,A\,B\,Q_A\,Q_B\,e}$.
By pattern-matching, we only need to consider the case where $\mathsf{A = B}$ and $\mathsf{e = refl}$,
and define
\[
\mathsf{dIndEqual\,P\,crefl\,A\,A\,Q_A\,Q_A'\,refl\,liftE = crefl\,A\,Q_A\,Q_A'\,liftE}
\]
%where
%$\mathsf{Q_A : A \to Set}$, $\mathsf{Q_A' : A \to Set}$
%and $\mathsf{L_E : Equal^{\wedge}\,A\,A\,Q_A\,Q_A'\,Refl}$.
Having provided a well-defined term for it,
we have shown that the induction rule for $\mathsf{Equal}$ is sound.

The type $\mathsf{Equal}$ also has a standard structural induction rule $\mathsf{indEqual}$,
\[
\mathsf{\forall (Q : \forall (A\,B : Set) \to Equal\,A\,B \to Set)
  \to \big( \forall (C : Set) \to P\,C\,C\,refl \big)
  \to \forall (A\,B : Set) (e: Equal\,A\,B) \to P\,A\,B\,e}
\]
As is the case for ADTs and nested types,
the structural induction rule for $\mathsf{Equal}$ is a consequence of the deep induction rule.
Indeed, we can define $\mathsf{indEqual}$ as
\[
\mathsf{indEqual\,Q\,srefl\,A\,B\,e = dIndEqual\,P\,srefl\,A\,B\,K^A_\top\,K^B_\top\,e\,liftE}
\]
where
$\mathsf{Q : \forall (A\,B : Set) \to Equal\,A\,B \to Set}$,
$\mathsf{srefl: \forall (C : Set) \to P\,C\,C\,refl}$
and $\mathsf{e : Equal\,A\,B}$, and
\begin{itemize}
\item $\mathsf{P : \forall (A\,B : Set) \to (A \to Set) \to (B \to Set) \to Equal\,A\,B \to Set}$ is defined as
$\mathsf{P\,A\,B\,Q_A\,Q_B\,e = Q\,A\,B\,e}$;
\item $\mathsf{K^A_\top}$ and $\mathsf{K^B_\top}$ are the constantly $\mathsf{\top}$-valued predicates on, respectively, $\mathsf{A}$ and $\mathsf{B}$;
%\item $\mathsf{K^b_1}$ is the constantly $\mathsf{1}$-valued predicate on $\mathsf{b}$;
\item $\mathsf{liftE : Equal^{\wedge}\,A\,B\,K^A_\top\,K^B_\top\,e}$ is defined by pattern matching,
i.e., in case $\mathsf{A = B}$ and $\mathsf{e = refl}$,
it is defined as $\mathsf{liftE\,a = refl : Equal\,A\,A}$ for every $\mathsf{a : A}$.
\end{itemize}
That the structural induction rule is a consequence of the deep induction one is also true for all the examples below,
even though we will not remark it every time.



\subsection{(Deep) induction for $\mathsf{Seq}$}

Next, we shall provide an induction rule for the $\mathsf{Seq}$ type defined in Example~\ref{example:seq}.
Again, the first step in deriving the induction rule for $\mathsf{Seq}$ consists in defining the predicate-lifting function over it, 
\[
\mathsf{Seq^{\wedge} : \forall (A : Set) \to (A \to Set) \to Seq\,A \to Set}
\]
which is given by pattern-matching as
\[
\mathsf{Seq^{\wedge}\,A\,Q_A\,(const\,a) = Q_A\,a}
\]
where $\mathsf{Q_A : A \to Set}$ and $\mathsf{a : A}$,
and
\[
\begin{array}{l}
\mathsf{Seq^{\wedge}\,A\,Q_A\,(sPair\,B\,C\,e\,s_B\,s_C)} \\
\quad\mathsf{=
\sum [Q_B : B \to Set] [Q_C : C \to Set]\;
Equal^{\wedge}\,A\, (B \times C)\, Q_A\, (Q_B \times Q_C) \, e \times Seq^{\wedge}\,B\,Q_B\,s_B \times Seq^{\wedge}\,C\,Q_C\,s_C
}
\end{array}
\]
where $\mathsf{e : Equal\,A\,(B \times C)}$,
$\mathsf{s_B : Seq\,B}$ and $\mathsf{s_C : Seq\,C}$.
%We also need to define the lifting of predicates over the polymorphic type of pairs,
%$\mathsf{Pair = \forall (B\,C : Set) \to B \times C}$, which is 
%\[
%\mathsf{Pair^{\wedge} : \forall (b\,c : Set) \to (b \to Set) \to (c \to Set) \to Pair\,b\,c \to Set}
%\]
%and it is defined as
%\[
%\mathsf{Pair^{\wedge}\,b\,c\,Q_b\,Q_c\,(y, z) = Q_b\,y \times Q_c\,z}
%\]
%where $\mathsf{Q_b : b \to Set}$, $\mathsf{Q_c : c \to Set}$, $\mathsf{y : b}$ and $\mathsf{z : c}$.

Finally, let $\mathsf{dIndConst}$ be the function
\[
\mathsf{
\lambda (P : \forall (A : Set) \to (A \to Set) \to Seq\,A \to Set)
\to \forall (A : Set) (Q_A : A \to Set) (a : A)
\to Q_A\,x \to P\,A\,Q_A\,(Const\,a)
}
\]
associated to the $\mathsf{const}$ constructor,
and let $\mathsf{dIndSPair}$ be the function
\[
\begin{array}{l}
\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to Seq\,A \to Set)} \\
\quad \mathsf{\to \forall (A\,B\,C : Set) (Q_A : A \to Set) (Q_B : B \to Set) (Q_C : C \to Set)(s_B : Seq\,B) (s_C : Seq\,C) (e : Equal\,A\,(B \times C))} \\
\quad \mathsf{\to Equal^{\wedge} A\, (B \times C)\, Q_A\, (Pair^{\wedge}\,B\,C\,Q_B\,Q_C)\, e
	\to P\,B\,Q_B\,s_B \to P\,C\,Q_C\,s_C
	\to P A Q_A ( SPair\,B\,C\,e\,s_B\,s_C )}
\end{array}
\]
associated to the $\mathsf{sPair}$ constructor.

With these tools we can formulate an induction rule for $\mathsf{Seq}$,
\[
\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to (A \to Set) \to Seq\,A \to Set)}
\mathsf{\to CConst\,P \to CSPair\,P} \\
\quad \mathsf{\to \forall (A : Set)(Q_A : A \to Set)(s_A : Seq\,A) \to Seq^{\wedge}\,A\,Q_A\,s_A \to P\,A\,Q_A\,s_A}
\end{array}
\]
To validate the induction rule, we define a term $\mathsf{dIndSeq}$ for the above type.
We have to define
\[
\mathsf{dIndSeq\,P\,cconst\,cspair\,A\,Q_A\,s_A\,liftA : P\,A\,Q_A\,s_A}
\]
where
$\mathsf{P : \forall (A : Set) \to (A \to Set) \to Seq\,A \to Set}$,
$\mathsf{cconst : cConst\,P}$,
$\mathsf{cspair : cSPair\,P}$,
$\mathsf{Q_A : A \to Set}$, $\mathsf{s_A : Seq\,A}$
and $\mathsf{liftA : Seq^{\wedge}\,A\,Q\,s_A}$,
and we proceed by pattern-matching on $\mathsf{s_A}$.
Let $\mathsf{s_A = const\,a}$ for $\mathsf{a : A}$, and define
\[
\mathsf{dIndSeq\,P\,cconst\,cspair\,A\,Q_A\,(const\,a)\,liftA = cconst\,A\,Q_A\,a\,liftA}
\]
Notice that $\mathsf{Seq^{\wedge}\,A\,Q_A\,(const\,a) = Q_A\,a}$, and thus $\mathsf{liftA : Q_A\,a}$,
making the right-hand-side in the above expression type-check.
Now, let $\mathsf{s_A = sPair\,B\,C\,e\,s_B\,s_C}$
for $\mathsf{e : Equal\,A\,(B \times C)}$, $\mathsf{s_B : Seq\,B}$ and $\mathsf{s_C : Seq\,C}$,
and define
\[
\mathsf{dIndSeq\,P\,cconst\,cspair\,A\,Q_A\,(sPair\,B\,C\,e\,s_B\,s_C)\,(Q_B, Q_C, liftE, liftB, liftC)
	= cspair\,A\,B\,C\,Q_A\,Q_B\,Q_C\,s_B\,s_C\,e\,liftE\,p_B\,p_C}
\]
where $\mathsf{(Q_B, Q_C, liftE, liftB, liftC) : Seq^{\wedge}\,A\,Q\,(sPair\,B\,C\,e\,s_B\,s_C)}$, i.e.,
\begin{itemize}
\item $\mathsf{Q_B : B \to Set}$ and $\mathsf{Q_C : C \to Set}$;
\item $\mathsf{liftE : Equal^{\wedge}\,A\, (B \times C)\, Q_A\, (Q_B \times Q_C) \, e}$;
\item $\mathsf{liftB : Seq^{\wedge}\,B\,Q_B\,s_B}$ and $\mathsf{liftC : Seq^{\wedge}\,C\,Q_C\,s_C}$;
\end{itemize}
and $\mathsf{p_B}$ and $\mathsf{p_C}$ are defined as follows:
\begin{align*}
\mathsf{p_B} &=\mathsf{DISeq\,P\,cconst\,cspair\,B\,Q_B\,s_B\,liftB : P\,B\,Q_B\,s_B} \\
\mathsf{p_C} &=\mathsf{DISeq\,P\,cconst\,cspair\,C\,Q_C\,s_C\,liftC : P\,C\,Q_C\,s_C}
\end{align*}



\subsection{(Deep) induction for $\mathsf{LTerm}$ }

%Same structure as previous two.
%Runs through the paper.
%Still to decide?

%{\color{blue} Some notational conventions: I am using uppercase letters for elements of LType and 
%lowercase letters for elements of LTerm. For example, $\mathsf{(T_b : LType \, b)}$ or $\mathsf{(t_c : LTerm \,c)}$.}

We now present an induction rule for the $\mathsf{LTerm}$ type defined in Example~\ref{example:lterm}.
For that, we need liftings for both $\mathsf{LType}$ and
$\mathsf{LTerm}$. We will also need a lifting of predicates for arrow types, since arrow types appear in 
$\mathsf{LType}$ and $\mathsf{LTerm}$. The lifting for arrow types 
\[
  \mathsf{Arr^{\wedge} : \forall (A\, B : Set) \to (A \to Set) \to (B \to Set) \to (A \to B) \to Set}
\]
is defined as
\[
  \mathsf{Arr^{\wedge}\, A\, B\, Q_A\, Q_B\, f = \forall (a : A) \to Q_A\,a \to Q_B\, (f\,a)}
\]
Now we can define the lifting for $\mathsf{LType}$, which has type 
\[
\mathsf{LType^{\wedge} : \forall (A : Set) \to (A \to Set) \to LType\,A \to Set}
\]
and is defined by pattern-matching as
\[
  \mathsf{LType^{\wedge}\,A\,Q_A\,(tBool\,B\,e)
  = \sum [Q_B : B \to Set]\, Equal^{\wedge}\, A\, B\, Q_A\, K^{Bool}_{\top} \,e}
\]
where $\mathsf{Q_A : A \to Set}$,
$\mathsf{K^{Bool}_{\top}}$ is the constantly $\mathsf{\top}$-valued predicate on $\mathsf{Bool}$,
$\mathsf{e : Equal\,A\,Bool}$,
and
\[
\begin{array}{l}
\mathsf{LType^{\wedge}\,A\,Q_A\,(tArr\, B\, C\, e\, T_B\, T_C)} \\
\quad
\mathsf{= \sum [Q_B : B \to Set] [Q_C : C \to Set]\,
  Equal^{\wedge}\,A\, (B \to C)\, Q_A\, (Arr^{\wedge} \, B\, C\, Q_B \, Q_C) \, e
  \times \, LType^{\wedge}\,B\,Q_B\,T_B \times LType^{\wedge}\,C\,Q_C\,T_C
}
\end{array}
\]
where $\mathsf{Q_A : A \to Set}$, $\mathsf{e : Equal\, A\, (B \to C)}$, $\mathsf{T_B : LType \,B}$, and 
$\mathsf{T_C : LType \,C}$,
and 
\[
\mathsf{LType^{\wedge}\,A\,Q_A\,(tList\, B\, e\, T_B)
=
\sum [Q_B : B \to Set]\, 
  Equal^{\wedge}\,A\, (List\, B)\, Q_A\, (List^{\wedge} \, B\, Q_B) \, e 
  \times LType^{\wedge}\,B\,Q_B\,T_B
}
\]
where $\mathsf{Q_A : A \to Set}$, $\mathsf{e : Equal\, A\, (List\, B)}$, and $\mathsf{T_B : LType \,B}$.


Given the lifting for $\mathsf{LType}$, we can define the lifting for $\mathsf{LTerm}$. Again, 
the lifting 
\[
\mathsf{LTerm^{\wedge} : \forall (A : Set) \to (A \to Set) \to LTerm\,A \to Set}
\]
is defined by pattern-matching as
\[
  \mathsf{LTerm^{\wedge}\,A\,Q_A\,(var\,s\,T_A) = LType^{\wedge}\, A\, Q_A\, T_A}
\]
where $\mathsf{s : String}$ and $\mathsf{T_A : LType\, A}$, and
\[
\begin{array}{l}
\mathsf{LTerm^{\wedge}\,A\,Q_A\, (abs \,B \,C \,e \,s \,T_B \,t_C)} \\ 
\quad \mathsf{
  = \sum [Q_B : B \to Set] [Q_C : C \to Set]\,
      Equal^{\wedge} \, A\, (B \to C)\, Q_A\, (Arr^{\wedge} \, B\, C\, Q_B \, Q_C)\, e
      \times \, LType^{\wedge}\, B\, Q_B\, T_B
      \times \, LTerm^{\wedge}\, C\, Q_C\, t_C }
\end{array}
\]
where $\mathsf{e : Equal \, A \, (B \to C)}$,
$\mathsf{s : String}$,
$\mathsf{T_B : LType\,B}$,
and $\mathsf{t_C : LTerm \, C}$,
and
\[
\mathsf{LTerm^{\wedge}\,A\,Q_A\, (app\, B\, t_{BA}\, t_B)
=
\sum [Q_B : B \to Set]\, 
  LTerm^{\wedge}\, (B \to A)\, (Arr^{\wedge} \, B\, A\, Q_B \, Q_A)\, t_{BA}
  \times LTerm^{\wedge}\, B\, Q_B\, t_B}
\]
where $\mathsf{t_{BA} : LTerm \, (B \to A)}$ and $\mathsf{t_B : LTerm \, B}$, and
\[
\mathsf{LTerm^{\wedge}\,A\,Q_A\, (listC\, B\, e\, ts)
=
\sum [Q_B : B \to Set]\,
 Equal^{\wedge} \, A\, (List\,B)\, Q_A\, (List^{\wedge} \, B\, Q_B) \, e
 \times List^{\wedge}\, (LTerm\,B) \, (LTerm^{\wedge} \, B\, Q_B) \, ts}
\]
where $\mathsf{e : Equal\, A\, (List \,B)}$ and $\mathsf{ts : List\, (LTerm B)}$. 
Notice we use the lifting for $\mathsf{List}$ in the case for the $\mathsf{listC}$ constructor. 

With these liftings, we can define the deep induction principle for $\mathsf{LTerm}$.
% Var case 
Let $\mathsf{dIndVar}$ be the function 
\begin{multline*}
\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A \to Set)} \\
\mathsf{\to 
  \forall (A : Set) (Q_A : A \to Set) (s : String) (T_A : LType\, A) 
  \to LType^{\wedge} \, A\, Q_A\, T_A
  \to P \, A\, Q_A\, (var \, s\, T_A)
  }
\end{multline*}
associated to the $\mathsf{var}$ constructor. 
% Abs case 
Let $\mathsf{dIndAbs}$ be the function 
\begin{align*}
  &\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A \to Set)} \\
  &\quad\mathsf{\to 
  \forall (A\,B\,C: Set) (Q_A : A \to Set)  (Q_B : B \to Set) (Q_C : C \to Set)
  (e : Equal\, A\, (B \to C)) (s : String) } \\ 
  &\quad\mathsf{ \to (T_B : LType\, B) \to (t_C : LTerm\, C)
  \to Equal^{\wedge}\,A\,(B \to C)\, Q_A \, (Arr^{\wedge} \, B\, C\, Q_B \, Q_C) \, e
  } \\
  &\quad\mathsf{
  \to LType^{\wedge}\, B\, Q_B\, T_B
  \to P\, C\, Q_C\, t_C\, 
  \to P \, A\, Q_A\, (abs \,B \,C \, e \,s \,T_B \, t_C)
  }
\end{align*}
associated to the $\mathsf{abs}$ constructor. 
% App case 
Let $\mathsf{dIndApp}$ be the function 
\begin{align*}
  &\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A \to Set)} \\
  &\quad \mathsf{\to 
  \forall (A \,B : Set) (Q_A : A \to Set)  (Q_B : B \to Set) 
   (t_{BA} : LTerm\, (B \to A)) (t_B : LTerm\, B)} \\
  &\quad \mathsf{
  \to P\, (B \to A)\, (Arr^{\wedge} \, B\, A\, Q_B \, Q_A) \, t_{BA} \, 
  \to P\, B\, Q_B\, t_B\, 
  \to P \, A\, Q_A\, (app \,B \,t_{BA} \, t_B) }
\end{align*}
associated to the $\mathsf{app}$ constructor. 
% ListC case 
Let $\mathsf{dIndListC}$ be the type 
\begin{align*}
  &\mathsf{\lambda (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A \to Set)} \\
  &\quad \mathsf{\to 
  \forall (A \,B : Set) (Q_A : A \to Set)  (Q_B : B \to Set) 
    (e : Equal\, A\, (List\, B)) (ts : List\, (LTerm\, B))} \\ 
  &\quad \mathsf{
    \to Equal^{\wedge}\, A\, (List\,B)\, Q_A\, (List^{\wedge}\, B\, Q_B)\, e 
  \to List^{\wedge}\, (LTerm\,B) (P\, B\, Q_B)\, ts
  \to P \, A\, Q_A\, (listC \,B \,e \, ts) }
\end{align*}
associated to the $\mathsf{listC}$ constructor.

The type of the deep induction principle for $\mathsf{LTerm}$ is
\[
\begin{array}{l}
\mathsf{\forall (P : \forall (A : Set) \to (A \to Set) \to LTerm\,A \to Set)
  \to dIndVar\,P \to dIndAbs\,P \to dIndApp\,P \to dIndListC\,P} \\
\quad \mathsf{\to \forall (A : Set)(Q_A : A \to Set)(t_A : LTerm\,A) \to LTerm^{\wedge}\,A\,Q_A\,t_A \to P\,A\,Q_A\,t_A}
\end{array}
\]
To prove the induction principle, we define a term $\mathsf{dIndLTerm}$ for it.
We have to define 
\[ 
\mathsf{dIndLTerm \, P\, cvar \, cabs\, capp\, clistc \, A\, Q_A\, t_A\, liftA : P\, A\, Q_A\, t_A}
\]
where $\mathsf{cvar: dIndVar}$, $\mathsf{cabs: dIndAbs}$, $\mathsf{capp : dIndApp}$, $\mathsf{clistc : dIndListC}$,
$\mathsf{Q_A : A \to Set}$, $\mathsf{t_A : LTerm\,A}$, and $\mathsf{liftA : LTerm^{\wedge}\,A\,Q_A\,t_A}$.
% where $\mathsf{P : \forall (a : Set) \to (a \to Set) \to LTerm\,a \to Set}$, 
As before, we prove the induction principle by pattern matching on $\mathsf{t_A}$. 
For the $\mathsf{var}$ constructor case, let $\mathsf{t_A = var\, s\, T_A}$ and define
\[
  \mathsf{dIndLTerm \, P\, cvar \, cabs\, capp\, clistc \, A\, Q_A\, (var\,s\,T_A) \, liftA = cvar \, A\, Q_A\, s\, T_A\, liftA }
\]
for $\mathsf{s : String}$ and $\mathsf{T_A : LType\,A}$.
% where $\mathsf{L_a : LTerm^{\wedge}\, a\, Q_a\, (Var\,s\,T_a)}$, i.e., $\mathsf{L_a : LType^{\wedge}\,a\,Q_a\,T_a}$ 
Notice that $\mathsf{LTerm^{\wedge}\, A\, Q_A\, (var\,s\,T_A) = LType^{\wedge}\,A\,Q_A\,T_A}$, so 
$\mathsf{liftA : LType^{\wedge}\,A\,Q_A\,T_A}$.
%
% Abs case 
For the $\mathsf{abs}$ case, let $\mathsf{t_A = abs \,B \,C \, e \,s \,T_B \, t_C)} $ and define
\[
\begin{array}{l}
\mathsf{dIndLTerm \, P\, cvar \, cabs\, capp\, clistc \, A\, Q_A\, (abs \,B \,C \,e \,s \,T_B \, t_C) \, (Q_B , Q_C , liftE, lift_{T_B}, lift_{t_C})} \\
\quad \mathsf{= cabs\,A\,B\,C\, Q_A\, Q_B\, Q_C\, e\, s\, T_B\, t_C\, liftE\, lift_{T_B}\, p_C}
\end{array}
\]
where $\mathsf{(Q_B , Q_C , liftE, lift_{T_B}, lift_{t_C}) : LTerm^{\wedge}\, A\, Q_A\, (abs \,B \,C \, e \,s \,T_B \, t_C)}$, i.e.,
\begin{itemize}
  \item $\mathsf{Q_B : B \to Set}$;
  \item $\mathsf{Q_C : C \to Set}$;
  \item $\mathsf{liftE : Equal^{\wedge} \, A\, (B \to C)\, Q_A\, (Arr^{\wedge} \, B\, C\, Q_B \, Q_C) \, e}$;
  \item $\mathsf{lift_{T_B}: LType^{\wedge} \, B\, Q_B\, T_B}$;
  \item $\mathsf{lift_{t_C}: LTerm^{\wedge} \, C\, Q_C\, T_C}$;
\end{itemize}
and $\mathsf{p_C}$ is defined as:
\[
  \mathsf{p_C =  dIndLTerm\,P\,cvar\,cabs \,capp \,clistc\, C\, Q_C\, t_C\, lift_{t_C}  : P \, C\, Q_C \, t_C }
\]
% App case - (App \,b \,t_{ba} \, t_b)
For the $\mathsf{app}$ case, let $\mathsf{t_A = app \,B \,\,t_{BA} \, t_B} $ and define
\[
  \mathsf{dIndLTerm \, P\, cvar \, cabs\, capp\, clistc \, A\, Q_A\,  (app \,B \,\,t_{BA} \, t_B)\, (Q_B , list_{t_{BA}}, list_{t_B})} \\
  \mathsf{= capp\,A\,B\,Q_A\, Q_B\, t_{BA}\, t_B\, p_{BA} \, p_B}
\]
where $\mathsf{(Q_B , lift_{t_{BA}}, list_{t_B}) : LTerm^{\wedge}\, A\, Q_A\, (app \,B \,t_{BA} \, t_B)}$
\begin{itemize}
  \item $\mathsf{Q_B : B \to Set}$;
  \item $\mathsf{lift_{t_{BA}}: LTerm^{\wedge} \, (B \to A)\, (Arr^{\wedge} \, B\, A\, Q_B \, Q_A)\, t_{BA}}$;
  \item $\mathsf{lift_{t_B}: LTerm^{\wedge} \, B\, Q_B\, t_B}$;
\end{itemize}
and $\mathsf{p_{BA}}$ and $\mathsf{p_B}$
and are defined as:
\begin{align*}
  \mathsf{p_{BA}} &= \mathsf{dIndLTerm\,P\,cvar\,cabs \,capp \,clistc\, (B \to A)\,(Arr^{\wedge} \, B\, A\, Q_B \, Q_A) \, t_{BA}\, lift_{t_{BA}}
  : P \, (B \to A)\, (Arr^{\wedge} \, B\, A\, Q_B \, Q_A) \, t_{BA} } \\
  \mathsf{p_B} &= \mathsf{dIndLTerm\,P\,cvar\,cabs \,capp \,clistc\, B\, Q_B\, t_B\, lift_{t_B}  : P \, B\, Q_B \, t_B } 
\end{align*}
% ListC case - (ListC \,b \,e \, ts)
Finally, for the $\mathsf{listC}$ case, let $\mathsf{t_A = listC \,B \,e \, ts}$ and define
\begin{multline*}
  \mathsf{dIndLTerm \, P\, cvar \, cabs\, capp\, clistc \, A\, Q_A\, (listC \,B \,e \, ts) \, (Q_B , liftE, lift_{List})
  = clistc \,A\,B\,Q_A\, Q_B\, e\, ts\, liftE\, p_{List} }
\end{multline*}
where $\mathsf{(Q_B , liftE, lift_{List}): LTerm^{\wedge}\, A\, Q_A\, (listC \,B \,e \, ts)}$, i.e.,
\begin{itemize}
  \item $\mathsf{Q_B : B \to Set}$;
  \item $\mathsf{listE : Equal^{\wedge}\, A\, (List\,B)\, Q_A\, (List^{\wedge}\, B\, Q_B)\, e}$;
  \item $\mathsf{lift_{List}: List^{\wedge} \, (LTerm\, B) \, (LTerm^{\wedge}\, B\, Q_B) \, ts}$;
\end{itemize}
and $\mathsf{p_{List}}$ is defined as:
\[
  \mathsf{p_{List} = liftListMap \, (LTerm\, B) \, (LTerm^{\wedge} \, B \, Q_B)\, 
    (P\,B\,Q_B)\, p_{ts} \, ts\, lift_{List}  : List^{\wedge}\, (LTerm\,B) \, (P\,B\,Q_B) \, ts}
\]
and $\mathsf{p_{ts}}$ is defined as:
\[
\mathsf{
  p_{ts} = dIndLTerm\, P\, cvar\, cabs\, capp\, clistc\, B\, Q_B :  PredMap \,(LTerm^{\wedge}\, B\, Q_B) \, (P\,B\,Q_B)
  }
\]
where 
\[
\mathsf{liftListMap : \forall\, (A : Set) \to (Q_A \, Q'_A : A \to Set) 
  \to PredMap\,Q_A\,Q'_A \to PredMap \,(List^{\wedge}\, A\, Q_A)\, (List^{\wedge}\, A\, Q'_A)}
\]
takes a morphism of predicates and produces a morphism of lifted predicates. 
$\mathsf{PredMap}$ gives the type of morphisms of predicates and is defined as: 
\begin{align*}
  &\mathsf{PredMap : \forall\, \{A : Set\} \to (A \to Set) \to (A \to Set) \to Set } \\
  &\mathsf{PredMap \, Q_A\,Q'_A\, = \forall\, (a : A) \to Q_A\,a \to Q'_A\,a}
\end{align*}



\subsection{General case}

%We restrict our scope to GADTs not featuring nesting,
%in the sense that their constructors contain no nested calls of the recursive variable,
%as truly nested types do.
%This way we can avoid the issue described in Section~\ref{sec:GADT-nested}.
%The reason for this restriction will be discussed in Section~\ref{sec:GADT-nested}.

Finally, we generalize the approach taken in the previous examples
and provide a general framework to derive induction rules for arbitrary GADTs.
%Since, as seen in Section~\ref{sec:GADT-nested},
%GADTs featuring nesting do not admit an induction rule,
%we restrict our scope to GADTs not featuring nesting.
For that, we need to give a grammar for the types we will be considering.
A generic GADT
\begin{equation*}
\begin{array}{l}
\mathsf{data\, G\,(\ol{a : Set}) : Set\,where}\\
\mathsf{\;\;\;\;\;\;\;\;C_i\, :\, F_i\,G\,\ol{b} \to G (\ol{K_i\,\ol{b}})}
\end{array}
\end{equation*}
is defined by a finite number of constructors $\mathsf{C_i}$.
In the definition above, $\mathsf{F_i}$ is a type constructor with signature $\mathsf{(Set^{\alpha} \to Set) \to Set^{\beta} \to Set}$
and each $\mathsf{K_i}$ is a type constructor with signature $\mathsf{Set^{\beta} \to Set}$
(i.e. a type constructor of arity $\mathsf{\beta}$).
The overline notation denotes a finite list:
$\mathsf{\ol{a}}$ is a list of types of length $\mathsf{\alpha}$,
so that it can be applied to the type constructor $\mathsf{G}$ of arity $\mathsf{\alpha}$.
%and the vertical bars notation denotes the length of a list:
%$\mathsf{G}$ depends on a finite list of types $\mathsf{\ol{a}}$ of length $\mathsf{\alpha}$,
Each of the $\mathsf{\alpha}$-many $\mathsf{K_i}$ is a type constructor of arity $\mathsf{\beta}$
so that it can be applied to the list of types $\mathsf{\ol{b}}$ of length $\mathsf{\beta}$.
%depends on a finite list of types $\mathsf{\ol{b}}$ of length $\mathsf{\beta}$,
Moreover, notice that the arity of $\mathsf{G}$ matches the number of type constructors $\mathsf{\ol{K_i}}$.
We allow each $\mathsf{F_i}$ to be inductively built in the following ways (and with the following restrictions):
\begin{itemize}
\item $\mathsf{F_i = F_i' \times F_i''}$ where $\mathsf{F_i'}$ and $\mathsf{F_i''}$ have the same signature as $\mathsf{F_i}$ and are built recursively from the same induction rules.
\item $\mathsf{F_i = F_i' + F_i''}$ where $\mathsf{F_i'}$ and $\mathsf{F_i''}$ have the same signature as $\mathsf{F_i}$ and are built recursively from the same induction rules.
\item $\mathsf{F_i = F_i' \to F_i''}$
where $\mathsf{F_i'}$ does not contain the recursive variable,
i.e., $\mathsf{F_i' : Set^\beta \to Set}$ is a type constructor of arity $\mathsf{\beta}$,
and $\mathsf{F_i''}$ has the same signature as $\mathsf{F_i}$ and is built recursively from the same induction rules.
\item $\mathsf{F_i\,G\,\ol{b} = G(\ol{F_a\,\ol{b}})}$
where none of the $\mathsf{F_a}$ contains the recursive variable,
i.e., $\mathsf{F_a : Set^\beta \to Set}$
is a type constructor of arity $\mathsf{\beta}$
for each $\mathsf{a}$.
Such restriction is necessary to prevent nesting,
as that would break the induction rule as discussed in Section~\ref{sec:GADT-nested}.
\item $\mathsf{F_i\,G\,\ol{b} = H\,\ol{b}}$
where $\mathsf{H}$ is a type constructor of arity $\mathsf{\beta}$ not containing the recursive variable,
i.e., $\mathsf{H : Set^\beta \to Set}$.
Notice that this covers the case in which $\mathsf{F_i}$ is a closed type,
so, in particular, the unit and empty types, $\mathsf{1}$ and $\mathsf{0}$.
%The only requirement on $\mathsf{H}$ is that it needs to have a predicate-lifting function
%(and any type made of constant types, sums, products, arrow types and other GADTs satisfies this condition).
\item $\mathsf{F_i\,G\,\ol{b} = H (\ol{F_c\,G\,\ol{b}})}$
where $\mathsf{H}$ is a $\mathsf{\gamma}$-ary type constructor not containing the recursive variable,
i.e., $\mathsf{H : Set^\gamma \to Set}$,
and $\mathsf{F_c}$ has the same signature as $\mathsf{F_i}$  and is built recursively from the same induction rules, for every $\mathsf{c = 1 \dots \gamma}$.
Moreover, we require that $\mathsf{H}$ is not a GADT itself (but we allow it to be an ADT or even a nested type).
This way $\mathsf{H}$ admits functorial semantics~\cite{jp20}, and thus we have a map function for $\mathsf{H^{\wedge}}$,
\[
\mathsf{HLMap : \forall (\ol{c : Set}) (\ol{Q_c\;Q_c' : c \to Set})
	\to \ol{PredMap\,c\,Q_c\,Q_c'}
	\to PredMap\,(H\,\ol{c})\,(H^{\wedge}\,\ol{c}\,\ol{Q_c})\,(H^{\wedge}\,\ol{c}\,\ol{Q_c'})}
\]
where $\mathsf{PredMap : \forall (c : Set) \to (c \to Set) \to (c \to Set) \to Set}$
is defined as
\[
\mathsf{PredMap\,c\,Q_c\,Q_c' = \forall (x : c) \to Q_c\,x \to Q_c'\,x}
\]
and represents the type of morphisms between predicates.
A concrete way to define $\mathsf{HLMap}$ is to proceed by induction on the structure of the type $\mathsf{H}$,
and give an inductive definition when $\mathsf{H}$ is an ADT or a nested type.
Such details are not essential to the present discussion, and thus we omit them.
\end{itemize}
We can summarize the above inductive definition with the following grammar
(but beware that the above restrictions and requirements still apply):
\[
\mathsf{F_i\,G\,\ol{b} :=
F_i'\,G\,\ol{b} \times F_i''\,G\,\ol{b}
\ \vert\ F_i'\,G\,\ol{b} + F_i''\,G\,\ol{b}
\ \vert\ F_i'\,\ol{b} \to F_i''\,G\,\ol{b}
\ \vert\ G(\ol{F_a\,\ol{b}})
\ \vert\ H\,\ol{b}
\ \vert\ H (\ol{F_c\,G\,\ol{b}})
}
\]
A further requirement that applies to all of the types appearing above,
including the types $\mathsf{K_i}$,
is that every type needs to have a predicate-lifting function.
This is not an overly restrictive condition, though:
all types made by sums, products, arrow types and type application do, and so do GADTs as defined above.
A concrete way to define the predicate-lifting function for a type is to proceed by induction on the structure of the type,
and we have seen in the previous sections examples of how to do so for products and type application.
We do not give here the general definition of lifting,
as that would require to first present a full type calculus,
and that is beyond the scope of the paper.

%Before proceeding with the derivation of the induction rule for a generic GADT,
%we need to define the type
%\[
%\mathsf{PredMap\,a\,Q_a\,Q_a' = \forall (x : a) \to Q_a\,x \to Q_a'\,x}
%\]
%where $\mathsf{Q_a}$ and  $\mathsf{Q_a'}$ are predicates on  $\mathsf{a : Set}$,
%which represents the type of morphisms between predicates $\mathsf{Q_a}$ and  $\mathsf{Q_a'}$.
%Moreover, if $\mathsf{H}$ is a type constructor having an associated predicate-lifting function $\mathsf{H^{\wedge}}$,
%we define a map function $\mathsf{HLMap}$ for the lifting $\mathsf{H^{\wedge}}$ as
%\[
%\mathsf{HLMap : \forall (a : Set) (Q_a\;Q_a' : a \to Set) \to PredMap\,a\,Q_a\,Q_a' \to PredMap\,(G\,a)\,(G^{\wedge}\,a\,Q_a)\,(G^{\wedge}\,a\,Q_a')}
%\]

Consider a generic GADT as defined above,
\begin{equation}\label{eq:gadt}
\begin{array}{l}
\mathsf{data\, G\,(a : Set) : Set\,where}\\
\mathsf{\;\;\;\;\;\;\;\;C\, :\, F\,G\,\ol{b} \to G (K\,\ol{b})}
\end{array}
\end{equation}
which, for ease of notation,
we assume to be a unary type constructor (i.e. it depends on a single type parameter $\mathsf{a}$)
and to have only one constructor $\mathsf{C}$.
Extending the argument to GADTs of arbitrary arity and with multiple constructors presents no difficulty
other than heavier notation.
In the definition above, $\mathsf{F}$ has signature $\mathsf{(Set \to Set) \to Set^{\beta} \to Set}$
and each $\mathsf{K}$ has signature $\mathsf{Set^{\beta} \to Set}$.
The constructor $\mathsf{C}$ can be rewritten using the $\mathsf{Equal}$ type as
\[
\mathsf{C : \exists (\ol{b : Set}) \to Equal\,a\,(K\,\ol{b}) \to F\,G\,\ol{b} \to G\,a}
\]
which is the form we shall use from now on.

In order to state the induction rule for $\mathsf{G}$,
we first need to define $\mathsf{G}$'s associated predicate-lifting function 
\[
\mathsf{G^{\wedge} : \forall (a : Set) \to (a \to Set) \to G\,a \to Set}
\]
as
\[
\mathsf{G^{\wedge}\,a\,Q_a\,(C\,\ol{b}\,e\,x)
= \exists (\ol{Q_b : b \to Set})
\to Equal^{\wedge}\,a\,(K\,\ol{b})\,Q_a\,(K^{\wedge}\,\ol{b}\,\ol{Q_b})\,e
\times F^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,{\ol{Q_b}}\,x}
\]
where $\mathsf{Q_a : a \to Set}$
and $\mathsf{C\,\ol{b}\,e\,x : G\,a}$,
i.e., $\mathsf{e : Equal\,a\,(K\,\ol{b})}$ and $\mathsf{x : F\,G\,\ol{b}}$.
As already mentioned before, we also assume to have liftings for $\mathsf{F}$,
\begin{multline*}
\mathsf{F^{\wedge} : \forall (G : Set^{\alpha} \to Set) (\ol{b : Set})
\to (\forall (a : Set) \to (a \to Set) \to G\,a \to Set)} \\
\mathsf{\to (\ol{b \to Set})
\to F\,G\,\ol{b} \to Set}
\end{multline*}
and for  $\mathsf{K}$,
\[
\mathsf{K^{\wedge} : \forall (\ol{b : Set}) \to (\ol{b \to Set}) \to K\,\ol{b} \to Set}
\]
Finally, associate the function
\begin{multline*}
\mathsf{CC = \lambda (P : \forall (a : Set) \to (a \to Set) \to G\,a \to Set)} \\
\mathsf{\to \forall (a : Set) (\ol{b : Set}) (Q_a : a \to Set) (\ol{Q_b : b \to Set}) (e : Equal\,a\,(K\,\ol{b})) (x : F\,G\,\ol{b})} \\
\mathsf{\to Equal^{\wedge}\,a\,(K\,\ol{b})\,Q_a\,(K^{\wedge}\,\ol{b}\,\ol{Q_b})\,e
	\to F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,x
	\to P\,a\,Q_a\,(C\,\ol{b}\,e\,x)}
\end{multline*}
to the constructor $\mathsf{C}$.

%We can now define the induction rule for $\mathsf{G}$
The induction rule for $\mathsf{G}$ is
\begin{multline*}
\mathsf{\forall (P : \forall (a : Set) \to (a \to Set) \to G\,a \to Set) \to CC\,P} \\
%\mathsf{\to \Big(
%\forall (\ol{a : Set}) (\ol{b : Set}) (\ol{Q_a : a \to Set}) (\ol{Q_b : b \to Set}) (\ol{e_a : Equal\,a\,(K\,\ol{b})}) (x : F\,G\,\ol{b})} \\
%\mathsf{\to \ol{Equal^{\wedge}\,a\,(K\,\ol{b})\,Q_a\,(K^{\wedge}\,\ol{b}\,\ol{Q_b})\,e_a}
%	\to F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,x
%	\to P\,\ol{a}\,\ol{Q_a}\,(C\,\ol{b}\,\ol{e_a}\,x)
%\Big)} \\
\mathsf{\to \forall (a : Set)(Q_a : a \to Set)(y : G\,a) \to G^{\wedge}\,a\,Q_a\,y \to P\,a\,Q_a\,y}
\end{multline*}
As we already did in the previous examples,
we validate the induction rule by providing a term $\mathsf{DIG}$ for the type above.
Define
\[
\mathsf{DIG\,P\,cc\,a\,Q_a\,(C\,\ol{b}\,e\,x)\,(\ol{Q_b}, L_E, L_F)
= cc\,a\,\ol{b}\,Q_a\,\ol{Q_b}\,e\,x\,L_E\,(p\,x\,L_F)}
\]
where $\mathsf{cc : CC\,P}$ and
\begin{itemize}
\item $\mathsf{C\,\ol{b}\,e\,x : G\,a}$,
i.e., $\mathsf{e : Equal\,a\,(K\,\ol{b})}$,
and $\mathsf{x : F\,G\,\ol{b}}$;
\item $\mathsf{(\ol{Q_b}, L_E, L_F) : G^{\wedge}\,a\,Q_a (C\,\ol{b}\,e\,x)}$,
i.e.,
$\mathsf{Q_b : b \to Set}$ for each $\mathsf{b}$,
$\mathsf{L_E : Equal^{\wedge}\,a\,(K\,\ol{b})\,Q_a\,(K^{\wedge}\,\ol{b}\,\ol{Q_b})\,e}$,
and $\mathsf{L_F : F^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,{\ol{Q_b}}\,x}$.
\end{itemize}
Finally, the morphism of predicates
\[
\mathsf{p : PredMap\,(F\,G\,\ol{b})\,(F^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}) (F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b})}
\]
is defined by structural induction on $\mathsf{F}$ as follows:
\begin{itemize}
\item Case $\mathsf{F = F_1 \times F_2}$ where $\mathsf{F_1}$ and $\mathsf{F_2}$ have the same signature as $\mathsf{F}$.
We have that
\[
\mathsf{F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}
= Pair^{\wedge}(F_1\,G\,\ol{b})(F_2\,G\,\ol{b})(F_1^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}) (F_2^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b})}
\]
By inductive hypothesis, there exist morphisms of predicates
\begin{gather*}
\mathsf{p_1 : PredMap\,(F_1\,G\,\ol{b})\,((F_1)^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}) ((F_1)^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b})} \\
\mathsf{p_2 : PredMap\,(F_2\,G\,\ol{b})\,((F_2)^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}) ((F_2)^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b})}
\end{gather*}
Thus, we define $\mathsf{p (x_1, x_2) (L_1, L_2) = (p_1\,x_1\,L_1, p_2\,x_2\,L_2)}$ 
for 
$\mathsf{x_1 : F_1\,G\,\ol{b}}$,
$\mathsf{L_1 : F_1^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}\,x_1}$,
$\mathsf{x_2 : F_2\,G\,\ol{b}}$
and $\mathsf{L_2 : F_2^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}\,x_2}$.
%%%
\item Case $\mathsf{F = F_1 + F_2}$ where $\mathsf{F_1}$ and $\mathsf{F_2}$ have the same signature as $\mathsf{F}$.
Analogous to case $\mathsf{F = F_1 \times F_2}$.
%%%
\item Case $\mathsf{F = F_1 \to F_2}$
where $\mathsf{F_1}$ does not contain the recursive variable,
i.e., $\mathsf{F_1 : Set^\beta \to Set}$,
and $\mathsf{F_2}$ has the same signature as $\mathsf{F}$.
We have that
\[
\mathsf{F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,x = \forall (z : F_1\,\ol{b}) \to F_1^{\wedge}\,\ol{b}\,\ol{Q_b}\,z \to F_2^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,(x\,z)}
\]
where $\mathsf{x : F\,G\,\ol{b} = F_1\,\ol{b} \to F_2\,G\,\ol{b}}$.
By inductive hypothesis, there exist a morphism of predicates
\[
\mathsf{p_2 : PredMap\,(F_2\,G\,\ol{b}) (F_2^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}) (F_2^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b})}
\]
Thus, we define $\mathsf{p\,x\,L_F : F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,x}$
for $\mathsf{L_F : F^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}\,x}$
as $\mathsf{p\,x\,L_F\,z\,L_1 = p_2 (x\,z) (L_F\,z\,L_1)}$
for $\mathsf{z : F_1\,\ol{b}}$
and $\mathsf{L_1 : F_1^{\wedge}\,\ol{b}\,\ol{Q_b}\,z}$.
Notice that $\mathsf{F_1}$ not containing the recursive variable
is a necessary restriction, as the proof relies on
$\mathsf{F^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}\,x}$
and $\mathsf{F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}\,x}$
having the same domain $\mathsf{F_1^{\wedge}\,\ol{b}\,\ol{Q_b}\,z}$.
%%%
\item Case $\mathsf{F\,G\,\ol{b} = G(F'\,\ol{b})}$
where $\mathsf{F'}$ does not contain the recursive variable,
i.e., $\mathsf{F' : Set^\beta \to Set}$.
Thus, $\mathsf{F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b} = P (F'\,\ol{b}) (F'^{\wedge}\,\ol{b}\,\ol{Q_b})}$.
So, $\mathsf{p}$ is defined as
\[
\mathsf{p = DIG\,P\,cc\,(F'\,\ol{b})\,(F'^{\wedge}\,\ol{b}\,\ol{Q_b})}
\]
%for $\mathsf{L_F : F^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}\,x}$.
%Note that the fact that the type constructor $\mathsf{F'}$ does not contain the recursive variable
%means that $\mathsf{G}$ does not feature nesting.
%As explained and exemplified in Section~\ref{sec:GADT-nested},
%that assumption is required to make induction work.
%%%
\item Case $\mathsf{F\,G\,\ol{b} = H\,\ol{b}}$
where $\mathsf{H}$ is a $\mathsf{\beta}$-ary type constructor not containing the recursive variable,
i.e., $\mathsf{H : Set^\beta \to Set}$.
In such case, $\mathsf{p : PredMap (H\,\ol{b}) (H^{\wedge}\,\ol{b}\,\ol{Q_b}) (H^{\wedge}\,\ol{b}\,\ol{Q_b})}$
is just the identity morphism of predicates.
%%%
\item Case $\mathsf{F\,G\,\ol{b} = H (\ol{F_c\,G\,\ol{b}})}$
where $\mathsf{H}$ is a $\mathsf{\gamma}$-ary type constructor not containing the recursive variable,
i.e., $\mathsf{H : Set^\gamma \to Set}$,
and $\mathsf{F_c}$ has the same signature as $\mathsf{F}$, for every $\mathsf{c = 1 \dots \gamma}$.
Moreover, we assume that $\mathsf{H}$ has an associated predicate-lifting function,
\[
\mathsf{H^{\wedge} : \forall (\ol{c : Set}) \to (\ol{c \to Set}) \to H\,\ol{c} \to Set}
\]
and that this predicate-lifting function has a map function $\mathsf{HLMap}$ of type
\[
\mathsf{\forall (\ol{c : Set}) (\ol{Q_c\;Q_c' : c \to Set}) \to PredMap\,\ol{c}\,\ol{Q_c}\,\ol{Q_c'}
\to PredMap\,(H\,\ol{c})\,(H^{\wedge}\,\ol{c}\,\ol{Q_c})\,(H^{\wedge}\,\ol{c}\,\ol{Q_c'})}
\]
That means that $\mathsf{H}$ cannot be a GADT,
as GADTs have no functorial semantics~\cite{HaskellPaper}
and incur in the issue exposed in Section~\ref{sec:GADT-nested},
but it can be an ADT or even a nested type as those types have functorial semantics~\cite{jp19,jgj21}.
Thus,
\[
\mathsf{F^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b} = H^{\wedge} (\ol{F_c\,G\,\ol{b}}) (\ol{F_c^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}})}
\]
By induction hypothesis, there is a morphism of predicates
\[
\mathsf{p_c : PredMap\,(F_c\,G\,\ol{b}) (F_c^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}) (F_c^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b})}
\]
for every $\mathsf{c = 1 \dots \gamma}$.
So, $\mathsf{p}$ is defined as
\[
\mathsf{p
= HLMap\,(\ol{F_c\,G\,\ol{b}}) (\ol{F_c^{\wedge}\,G\,\ol{b}\,G^{\wedge}\,\ol{Q_b}}) (\ol{F_c^{\wedge}\,G\,\ol{b}\,P\,\ol{Q_b}})\,\ol{p_c}}
\]
\end{itemize}
%Notice that, by proceeding by structural induction as above,
%we have implicitly defined a grammar for GADTs admitting an induction rule.
%In particular, we allow $\mathsf{F}$ to feature sums, products, arrow types and (limited) type application.



\section{Induction for GADTs with nesting}\label{sec:GADT-nested}

%%% Change title: something about the inherent limitations of the method
%%% we might want to extend previous result
%%% but we cannot so we already have the best possible result

In the previous sections,
we derive induction rules for examples of GADTs that do not feature nesting,
in the sense that their constructors contain no nested calls of the recursive variable,
as truly nested types (such as $\mathsf{Bush}$, Equation~\ref{eq:bush}) do.
Since both nested types
and GADTs without nesting admit induction rules,
as seen in the previous sections,
it is just natural to expect that GADTs with nesting would as well.
Surprisingly, that is not the case:
indeed, the induction principle generally relies on (unary) parametricity of the semantic interpretation,
and in the case of nested types it also relies on functorial semantics~\cite{jp20},
but GADTs cannot admit both functorial and parametric semantics at the same time~\cite{HaskellPaper}.
In this section we show how induction for GADTs featuring nesting goes wrong
by analyzing the following concrete example of such a type.
\begin{equation}\label{gadt-nested}
\begin{array}{l}
\mathsf{data\, G\,(a : Set) : Set\,where}\\
\mathsf{\;\;\;\;\;\;C :\, G(G\,a) \to G(a \times a)}
\end{array}
\end{equation}
The constructor $\mathsf{C}$ can be rewritten as
\[
\mathsf{C : \exists (b : Set) \to Equal\,a\,(b \times b) \to G(G\,b) \to G\,a}
\]
which is the form we shall use from now on.
The predicate-lifting function of $\mathsf{G}$,
\[
\mathsf{G^{\wedge} : \forall (a : Set) \to (a \to Set) \to G\,\ol{a} \to Set}
\]
is defined as
\[
\mathsf{G^{\wedge}\,a\,Q_a\,(C\,b\,e\,x)
= \exists (Q_b : b \to Set)
\to Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e
\times G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x}
\]
where $\mathsf{Q_a : a \to Set}$, $\mathsf{e : Equal\,a\,(b \times b)}$ and $\mathsf{x : G(G\,b)}$.
Finally, let $\mathsf{CC}$ be the function
\begin{multline*}
\mathsf{\lambda (P : \forall (a : Set) \to (a \to Set) \to G\,a \to Set)} \\
\mathsf{\to \forall (a\;b : Set) (Q_a : a \to Set) (Q_b : b \to Set) (e : Equal\,a\,(b \times b)) (x : G\,(G\,b))} \\
\mathsf{\to Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e
	\to P\,(G\,b)\,(P\,b\,Q_b)\,x
	\to P\,a\,Q_a\,(C\,b\,e\,x)}
\end{multline*}
associated to the $\mathsf{C}$ constructor.

The induction rule for $\mathsf{G}$ is
\begin{multline*}
\mathsf{\forall (P : \forall (a : Set) \to (a \to Set) \to G\,a \to Set) \to CC\,P} \\
\mathsf{\to \forall (a : Set)(Q_a : a \to Set)(y : G\,a) \to G^{\wedge}\,a\,Q_a\,y \to P\,a\,Q_a\,y}
\end{multline*}
Consistently with the previous examples,
to validate the induction rule
we try to define a term of the above type, $\mathsf{DIG}$, as
\[
\mathsf{DIG\,P\,cc\,a\,Q_a\,(C\,b\,e\,x)\,(Q_b, L_E, L_G)
= cc\,a\,b\,Q_a\,Q_b\,e\,x\,L_E\,p}
\]
where $\mathsf{cc : CC\,P}$ and
\begin{itemize}
\item $\mathsf{C\,b\,e\,x : G\,a}$,
i.e., $\mathsf{e : Equal\,a\,(b \times b)}$ and $\mathsf{x : G(G\,b)}$;
\item $\mathsf{(Q_b, L_E, L_G) : G^{\wedge}\,a\,Q_a\,(C\,b\,e\,x)}$,
i.e., $\mathsf{Q_b : b \to Set}$, $\mathsf{L_E : Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e}$,
and $\mathsf{L_G : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x}$.
\end{itemize}
We still need to define $\mathsf{p : P\,(G\,b)\,(P\,b\,Q_b)\,x}$.
We do so by using the induction rule and letting
\[
\mathsf{p = DIG\,P\,cc\,(G\,b)\,(P\,b\,Q_b)\,x\,q}
\]
where we still need to provide $\mathsf{q : G^{\wedge}\,(G\,b)\,(P\,b\,Q_b)\,x}$.
If we had the map function of $\mathsf{G^{\wedge}}$,
\[
\mathsf{GLMap : \forall (a : Set) (Q_a\;Q_a' : a \to Set) \to PredMap\,a\,Q_a\,Q_a' \to PredMap\,(G\,a)\,(G^{\wedge}\,a\,Q_a)\,(G^{\wedge}\,a\,Q_a')}
\]
then we would be able to define
\[
\mathsf{q = GLMap\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,(P\,b\,Q_b)\,(DIG\,P\,cc\,b\,Q_b)\,x\,L_G}
\]
Unfortunately, we cannot define such a $\mathsf{GLMap}$.
Indeed, its definition would have to be
\[
\mathsf{GLMap\,a\,Q_a\,Q_a'\,M\,(C\,b\,e\,x)\,(Q_b, L_E, L_G) = (Q_b', L_E', L_G')}
\]
where $\mathsf{Q_a : a \to Set}$, $\mathsf{Q_a' : a \to Set}$,
$\mathsf{M : PredMap\,a\,Q_a\,Q_a'}$,
$\mathsf{C\,b\,e\,x : G\,a}$, i.e.,
\begin{itemize}
\item $\mathsf{e : Equal\,a\,(b \times b)}$;
\item $\mathsf{x : G\,(G\,b)}$;
\end{itemize}
$\mathsf{(Q_b, L_E, L_G) :G^{\wedge}\,a\,Q_a\,(C\,b\,e\,x)}$, i.e.,
\begin{itemize}
\item $\mathsf{Q_b : b \to Set}$;
\item $\mathsf{L_E : Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e}$;
\item $\mathsf{L_G : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x}$;
\end{itemize}
and $\mathsf{(Q_b', L_E', L_G') : G^{\wedge}\,a\,Q_a'\,(C\,b\,e\,x)}$, i.e.,
\begin{itemize}
\item $\mathsf{Q_b' : b \to Set}$;
\item $\mathsf{L_E' : Equal^{\wedge}\,a\,(b \times b)\,Q_a'\,(Pair^{\wedge}\,b\,b\,Q'_b\,Q'_b)\,e}$;
\item $\mathsf{L_G' : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b')\,x}$;
\end{itemize}
%\begin{gather*}
%\mathsf{Q_a\;Q_a' : a \to Set} \\
%\mathsf{Q_b\;Q_b' : b \to Set} \\
%%\mathsf{M : PredMap\,b\,Q_a\,Q_a'} \\
%\mathsf{L_E : Equal^{\wedge}\,a\,(b \times b)\,Q_a\,(Pair^{\wedge}\,b\,b\,Q_b\,Q_b)\,e} \\
%\mathsf{L_G\ : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b)\,x} \\
%\mathsf{L_E' : Equal^{\wedge}\,a\,(b \times b)\,Q_a'\,(Pair^{\wedge}\,b\,b\,Q'_b\,Q'_b)\,e} \\
%\mathsf{L_G' : G^{\wedge}\,(G\,b)\,(G^{\wedge}\,b\,Q_b')\,x}
%\end{gather*}
In other words, we have a proof $\mathsf{L_E}$ of the (extensional) equality
of the predicates $\mathsf{Q_a}$ and $\mathsf{Pair^{\wedge}\,b\,b\,Q_b\,Q_b}$
and a morphism of predicates $\mathsf{M}$ from $\mathsf{Q_a}$ to $\mathsf{Q_a'}$,
and we need to use those to deduce a proof of the (extensional) equality
of the predicates $\mathsf{Q_a'}$ and $\mathsf{Pair^{\wedge}\,b\,b\,Q_b'\,Q_b'}$,
for some  for some predicate $\mathsf{Q_b'}$ on $\mathsf{b}$.
But that is not generally possible:
the facts that $\mathsf{Q_a}$ is equal to $\mathsf{Pair^{\wedge}\,b\,b\,Q_b\,Q_b}$
and that there is a morphism of predicates $\mathsf{M}$ from $\mathsf{Q_a}$ to $\mathsf{Q_a'}$
do not guarantee that $\mathsf{Q_a'}$ is equal to $\mathsf{Pair^{\wedge}\,bb\,Q_b'\,Q_b'}$ for some $\mathsf{Q_b'}$.

At a deeper level, the fundamental issue is that
the $\mathsf{Equal}$ type does not have functorial semantics,
so that having morphisms $\mathsf{A \to A'}$ and $\mathsf{B \to B'}$
and a proof that $\mathsf{A}$ is equal to $\mathsf{A'}$
does not provide a proof that $\mathsf{B}$ is equal to $\mathsf{B'}$.
This is because GADTs can either have a syntax-only semantics or a functorial-completion semantics.
Since we are interested in induction rules, we considered the syntax-only semantics,
which is parametric but not functorial.
Had we considered the functorial-completion semantics, which is functorial,
we would have forfeited parametricity instead.
In both cases, thus, we cannot derive an induction rule for GADTs featuring nesting.
Unlike nestes types, indeed, GADTs do not admit a semantic interpretation that is both parametric and functorial~\cite{HaskellPaper}.



\section{Applications}

{\color{red} Can get rid of Maybe using non-empty lists and postulates}

In this section we use deep induction for the $\mathsf{LTerm}$ GADT to 
extract the type from a lambda term. 
We have a predicate 
\begin{align*}
  &\mathsf{getType : \forall \, (a : Set) \to (t : LTerm\,a) \to Set} \\
  &\mathsf{getType \,a \,t = Maybe \, (LType \, a)}
\end{align*}
that takes a lambda term and produces its type (using $\mathsf{Maybe}$ to represent
potential failure).
We want to show this predicate is satisfied for every element of $\mathsf{LTerm\,a}$.
Because of the $\mathsf{ListC}$ constructor, this cannot be achieved without 
deep induction. In particular, deep induction is required to apply the induction to the 
individual terms in a list of terms. 

So, using deep induction, we want to prove: 
\[
  \mathsf{getTypeProof : \forall \, (a : Set) \to (t : LTerm\,a) \to getType \,a \,t} \\
\]
which we prove by 
\[
  \mathsf{getTypeProof \,a \,t = 
    DILTerm\, (\lambda \, b\, Q_b\, t\, \to getType \,b\, t) \,
    gtVar\,  gtABs\,  gtApp\,  gtListC\,  a\,\, K1\,\, t\, (LTerm^{\wedge}K1\, a\, t)
    }
\]
where $\mathsf{K1 : a \to Set}$ is the constantly true predicate:
\[
  \mathsf{K1 \, x = \top}
\]
and $\mathsf{LTerm^{\wedge}K1\, a\, t : LTerm^{\wedge}\, a\, K1\, t}$.
Notice that there is no space in $\mathsf{LTerm^{\wedge}K1}$, because
\[
  \mathsf{LTerm^{\wedge}K1 : \forall (a : Set) (t : LTerm A) \to LTerm^{\wedge}\, a\, K1\,t}
\]
is a function that we will define. In addition to defining $\mathsf{LTerm^{\wedge}K1}$,
we also have to give a proof for each constructor $\mathsf{Var, Abs, App, ListC}$:
\begin{multline*}
  \mathsf{gtVar : \forall (a : Set) (Q_a : a \to Set) (s : String) (T_a : LType\, a) 
      \to LType^{\wedge} \, a\, Q_a\, T_a\, \to Maybe\, (LType\, a)}
\end{multline*}

% abs 
\begin{multline*}
    \mathsf{gtAbs : \forall (a \, b\, c: Set) (Q_a : a \to Set) (Q_b : b \to Set) (Q_c : c \to Set) 
      (e : Equal\, a\, (b \to c)) (s : String)} \\ 
    %
    \mathsf{ (T_b : LType\, b) (t_c : LTerm \, c)
      \to Equal^{\wedge}\, a\, (b \to c)\, Q_a\, (Arr^{\wedge}\, b\, c\, Q_b\, Q_c)\, e
      \to LType^{\wedge} \, b\, Q_b\, T_b} \\ 
    %
    \mathsf{
      \to Maybe\, (LType\,c) \to Maybe\, (LType\, a)}
\end{multline*}

% app 
\begin{multline*}
    \mathsf{gtApp : \forall (a \, b : Set) (Q_a : a \to Set) (Q_b : b \to Set) 
      (t_{ba} : LTerm\, (b \to a)) (t_b : LTerm\, b)} \\ 
    \mathsf{
      \to Maybe\, (LType\, (b \to a))
      \to Maybe\, (LType\, b)
      \to Maybe\, (LType\, a)
    }
\end{multline*}


% list 
\begin{multline*}
    % abs
    \mathsf{gtListC : \forall (a \, b : Set) (Q_a : a \to Set) (Q_b : b \to Set) 
      (e : Equal\, a\, (List\, b)) (ts : List\, (LTerm\, b))} \\ 
    \mathsf{
      \to Equal^{\wedge}\, a\, (List\,b) \, Q_a\, (List^{\wedge}\, b\, Q_b)\, e
      \to List^{\wedge}\, (LTerm\, b)\, (getType\, b)\, ts
      \to Maybe\, (LType\, a)
    }
\end{multline*}


For variables we simply return the type $\mathsf{T_a}$, 
and the cases for abstraction and application are similar.
The interesting case is $\mathsf{gtListC}$, in which we have to use 
the results of ($\mathsf{List^{\wedge}\, (LTerm\, b)\, (getType\, b)\, ts}$)
in order to extract the type of one of the terms in the list. 
To define $\mathsf{gtListC}$ we pattern-match on the list of terms $\mathsf{ts}$.  

If $\mathsf{ts}$ is the empty list (denoted by $\mathsf{[]}$), we cannot extract a type, 
so we return $\mathsf{nothing}$. \\
{\color{red} Maybe handle this case differently, by using non-empty lists, for example}
\[
  \mathsf{gtListC\, a\, b\, Q_a\, Q_b\, e\, [] \, L_e L_{ts} = nothing}
\]
If $\mathsf{ts}$ is a non-empty list, we pattern match on $\mathsf{L_{ts}}$ and use the result
to construct the type we need:
\begin{align*}
  &\mathsf{gtListC\, a\, b\, Q_a\, Q_b\, e\, (t :: ts) \, L_e (nothing , L_{ts}) = nothing} \\
  &\mathsf{gtListC\, a\, b\, Q_a\, Q_b\, e\, (t :: ts) \, L_e (just\, T_b , L_{ts}) = just \, (TList\, b\, e\, T_b)}
\end{align*}
where $\mathsf{e : Equal\, a\, (List\,b)}$ and $\mathsf{T_b : LType\, b}$. 

\subsection{Defining $\mathsf{LTerm^{\wedge}K1}$}

{\color{red} Maybe this section can be deleted by assuming $\mathsf{LTerm^{\wedge}\, a\, K1\,t = K1}$.
Maybe we can say this derives from parametricity.
Currently we say that $\mathsf{K1 \times K1 = K1}$ based on the fact that products are a built-in type and so this seems to be obviously true.}

The last piece of infrastructure we need to define $\mathsf{getTypeProof}$ is a function 
\[
  \mathsf{LTerm^{\wedge}K1 : \forall (a : Set) \to (t : LTerm A) \to LTerm^{\wedge}\, a\, K1\,t}
\]
that provides a 
proof of $\mathsf{LTerm^{\wedge}\,a\,K1\,t}$ for any term $\mathsf{t : LTerm\, a}$. 
Because $\mathsf{LTerm^{\wedge}}$ is defined in terms of $\mathsf{LType^{\wedge}}$, $\mathsf{Arr^{\wedge}}$, 
and $\mathsf{List^{\wedge}}$, we will need analogous functions for these liftings as well. 
We only give the definition of $\mathsf{LTerm^{\wedge}K1}$, but the definitions for 
$\mathsf{LType^{\wedge}}$, $\mathsf{Arr^{\wedge}}$, and $\mathsf{List^{\wedge}}$ are analogous. 

$\mathsf{LTerm^{\wedge}K1}$ is defined by pattern matching on the lambda term $\mathsf{t}$. 
For the $\mathsf{Var}$ case, let $\mathsf{t = (Var\, s\, T_a)}$ and define
\[
  \mathsf{LTerm^{\wedge}K1\,a\,(Var\,s\,T_a) = LType^{\wedge}K1\,a\,T_a}
\]
For the $\mathsf{Abs}$ case, let $\mathsf{t = (Abs \,b \,c \, e \,s \,T_b \, t_c)} $ and recall the 
definition of $\mathsf{LTerm^{\wedge}}$ for the $\mathsf{Abs}$ constructor, 
instantiating the predicate $\mathsf{Q_a}$ to $\mathsf{K1}$: 
% \,a\,Q_a\, (Abs \,b \,c \,e \,s \,T_b \,t_c)}$, :
\begin{multline*}
  \mathsf{LTerm^{\wedge}\,a\,K1\,
  (Abs \,b \,c \,e \,s \,T_b \,t_c)} \\ 
\mathsf{
  = \exists (Q_b : b \to Set) (Q_c : c \to Set) \to
      Equal^{\wedge} \, a\, (b \to c)\, K1\, (Arr^{\wedge} \, b\, c\, Q_b \, Q_c)\, e} \\ 
\mathsf{
      \times \, LType^{\wedge}\, b\, Q_b\, T_b
      \times \, LTerm^{\wedge}\, c\, Q_c\, t_c }
\end{multline*}
so to define the $\mathsf{Abs}$ case of $\mathsf{LTerm^{\wedge}K1}$, we need a proof of 
\[
  \mathsf{Equal^{\wedge} \, a\, (b \to c)\, K1\, (Arr^{\wedge} \, b\, c\, Q_b \, Q_c)\, e}
\]
i.e., that $\mathsf{K1}$ is (extensionally) equal to the lifting $\mathsf{(Arr^{\wedge} \, b\, c\, Q_b \, Q_c)}$
for some predicates $\mathsf{Q_b, Q_c}$. The only reasonable choice for $\mathsf{Q_b}$ and $\mathsf{Q_c}$ 
is to let both be $\mathsf{K1}$, which means we need a proof of:
\[
  \mathsf{Equal^{\wedge} \, a\, (b \to c)\, K1\, (Arr^{\wedge} \, b\, c\, K1 \, K1)\, e}
\]
Since we are working with proof-relevant predicates (i.e., functions into $\mathsf{Set}$ rather than 
functions into $\mathsf{Bool}$), 
the lifting $\mathsf{(Arr^{\wedge} \, b\, c\, K1 \, K1)}$ of $\mathsf{K1}$ to arrow types
is not identical to $\mathsf{K1}$ on arrow types, but the predicates are (extensionally) isomorphic. 
We discuss this issue in more detail at the end of the section. 
For now, we assume a proof 
\[
  \mathsf{Equal^{\wedge}ArrK1 : Equal^{\wedge} \, a\, (b \to c)\, K1\, (Arr^{\wedge} \, b\, c\, K1 \, K1)\, e}
\]
and define the $\mathsf{Abs}$ case of $\mathsf{LTerm^{\wedge}K1}$ as 
\[
  \mathsf{LTerm^{\wedge}K1\,a\, (Abs \,b \,c \, e \,s \,T_b \, t_c) = 
    (K1 , K1 , Equal^{\wedge}ArrK1 , LType^{\wedge}K1 \,b\,T_b\, , LTerm^{\wedge}K1\,c\,t_c)
  }
\]
For the $\mathsf{App}$ case, let $\mathsf{t = (App \,b \,\,t_{ba} \, t_b)}$ and just as we did for the $\mathsf{Abs}$ case, 
recall the definition of $\mathsf{LTerm^{\wedge}\,a\,(App \,b \,\,t_{ba} \, t_b)}$ with all of the predicates
instantiated with $\mathsf{K1}$: 
\[
\mathsf{
      LTerm^{\wedge}\, (b \to a)\, (Arr^{\wedge} \, b\, a\, K1 \, K1)\, t_{ba}
      \times LTerm^{\wedge}\, b\, K1\, t_b }
\]
The second component can be given using $\mathsf{LTerm^{\wedge}K1}$, and we can 
define the first component using a proof of
\[
\mathsf{LTerm^{\wedge}\, (b \to a)\, K1\,\, t_{ba}}
\]
and a map-like function 
\begin{multline*}
  \mathsf{LTerm^{\wedge}EqualMap : \forall\, \{a : Set\} \to (Q_a\,Q'_a : a \to Set) 
    \to (Equal^{\wedge}\,a\,a\,Q_a\,Q'_a\,rfl)} \\
    \mathsf{
    \to PredMap\, (LTerm^{\wedge}\,a\,Q_a)\,(LTerm^{\wedge}\,a\,Q'_a)}
\end{multline*}
that takes two (extensionally) equal predicates with the same carrier 
and produces a morphism of predicates between their liftings. The definition is 
straightforward enough, so we omit the details. 
But it is worth noting that while a true $\mathsf{HLMap}$ function, 
which takes a \emph{morphism} of predicates instead of a proof of equality, cannot be defined 
for GADTs in general, an analogue of $\mathsf{LTerm^{\wedge}EqualMap}$ should be definable 
for every GADT. These analogues of $\mathsf{LTerm^{\wedge}EqualMap}$ will be required to define 
$\mathsf{G^{\wedge}K1}$ whenever $\mathsf{G}$ has a constructor of the form
  ($\mathsf{c : G \, (F\, b) \to G\,(K\,b)}$).

Using $\mathsf{LTerm^{\wedge}EqualMap}$, we can define the $\mathsf{App}$ case of $\mathsf{LTerm^{\wedge}K1}$ as 
\[
  \mathsf{LTerm^{\wedge}K1\,a\, (App \,b \,\,t_{ba} \, t_b) = 
    (K1 , L_{Arr^{\wedge}\,K1} , LTerm^{\wedge}K1\,b\,t_b)}
\]
where $\mathsf{ L_{Arr^{\wedge}\,K1} : LTerm^{\wedge}\, (b \to a)\, (Arr^{\wedge} \, b\, a\, K1 \, K1)\, t_{ba}}$ is defined as
\[
  \mathsf{L_{Arr^{\wedge}\,K1} =  LTerm^{\wedge}EqualMap\,K1\,(Arr^{\wedge}\,b\,a\,K1\,K1)\,\, Equal^{\wedge}ArrK1\, \,\,t_{ba}\, \,L_{K1}}
\]
where $\mathsf{L_{K1} = LTerm^{\wedge}K1\, (b \to a)\, t_{ba} : LTerm^{\wedge}\, (b \to a) \, K1\, t_{ba}}$.

Finally, we define the $\mathsf{ListC}$ case for $\mathsf{LTerm^{\wedge}K1}$. 
Let $\mathsf{t = (ListC\, b\, e\, ts)}$ and recall the definition of $\mathsf{LTerm^{\wedge}\,a\,(ListC\, b\, e\, ts)}$ with
all of the predicates instantiated to $\mathsf{K1}$: 
\[
\mathsf{ Equal^{\wedge} \, a\, (List\,b)\, K1\, (List^{\wedge} \, b\, K1) \, e
      \times List^{\wedge}\, (LTerm\,b) \, (LTerm^{\wedge} \, b\, K1) \, ts }
\]
We can give the first component by assuming a proof \,
$\mathsf{Equal^{\wedge}ListK1 : Equal^{\wedge} \, a\, (List\,b)\, K1\, (List^{\wedge} \, b\, K1) \, e}$, 
but for the second component we again have multiple liftings nested together. In this case, we can 
get a proof of
\[
\mathsf{ List^{\wedge}\, (LTerm\,b) \, (LTerm^{\wedge} \, b\, K1) \, ts }
\]
using 
\[\mathsf{List^{\wedge}map : \forall\, (a : Set) \to (Q_a \, Q'_a : a \to Set) 
  \to PredMap\,Q_a\,Q'_a \to PredMap \,(List^{\wedge}\, a\, Q_a)\, (List^{\wedge}\, a\, Q'_a)}\]
to map a morphism of predicates 
\[
  \mathsf{PredMap \, (K1)\, (LTerm^{\wedge}\,b\,K1)}
\]
to a morphism of lifted predicates
\[
  \mathsf{PredMap \,(List^{\wedge}\,(LTerm\,b)\,K1) \, (List^{\wedge}\,(LTerm\,b)\, (LTerm^{\wedge}\,b\,K1))}
\]

We define the $\mathsf{ListC}$ case of $\mathsf{LTerm^{\wedge}K1}$ as 
\[
  \mathsf{LTerm^{\wedge}K1\,a\, (ListC\, b\, e\, ts) =
    (K1 , \, Equal^{\wedge}ListK1 , \,  L_{List^{\wedge}LTerm^{\wedge}K1} ) }
\]
where
 $\mathsf{L_{List^{\wedge}LTerm^{\wedge}K1} : List^{\wedge}\, (LTerm\,b) \, (LTerm^{\wedge} \, b\, K1) \, ts}$
\[
  \mathsf{ 
 L_{List^{\wedge}LTerm^{\wedge}K1} =
  List^{\wedge}map \, (LTerm\,b) \, K1 \, (LTerm^{\wedge}\, b\, K1) \, m_{K1} \, ts \, (List^{\wedge}K1\, (LTerm\, b)\, ts)
    }
\]
and 
 $\mathsf{m_{K1} : PredMap \, (K1)\, (LTerm^{\wedge}\,b\,K1)}$
\[
  \mathsf{m_{K1} \, t\, \ast\, = LTerm^{\wedge}K1\, b\, t}
\]
where $\mathsf{\ast}$ is the single element of $\mathsf{(K1\, t)}$. 
The use of $\mathsf{List^{\wedge}map}$ is required in the $\mathsf{ListC}$ case because 
$\mathsf{ListC}$ takes an argument of type $\mathsf{List\, (LTerm\, b)}$. 
The same technique can be used to define $\mathsf{G^{\wedge}K1}$ whenever $\mathsf{G}$ has 
a constructor of the form ($\mathsf{c : F \, (G\, a) \to G\, (K\,b)}$). 
We only allow constructors of this form when 
$\mathsf{F}$ is a nested type or ADT, so we are guaranteed to have a $\mathsf{F^{\wedge}map}$ function. 


\subsection{Liftings of $\mathsf{K1}$}
To provide a proof of $\mathsf{G^{\wedge}\, a\, K1 \, t}$ for every term $\mathsf{t : G\, a}$, 
we need to know that the lifting of $\mathsf{K1}$ by a type $\mathsf{H}$ is extensionally equal to $\mathsf{K1}$ on $\mathsf{H}$. 
For example, we might need a proof that $\mathsf{Pair^{\wedge}\,a\,b\,K1\,K1}$ is equal to the predicate $\mathsf{K1}$ on pairs. 
Given a pair $\mathsf{(x , y) : a \times b}$, we have 

\begin{align*}
  &\mathsf{Pair^{\wedge}\,a\,b\,K1\,K1 (x, y)}  \\
  = \, \, &\mathsf{K1 \, x \times K1\, y} \\ 
  = \, \, &\mathsf{\top \times \top}
\end{align*}
while 
\begin{align*}
 \mathsf{K1\, (x, y) = \top}
\end{align*}
and while these types are not equal they are clearly isomorphic. So for simplicity of presentation, we 
assume ($\mathsf{F^{\wedge}\,a\,K1}$) is equal to $\mathsf{K1}$ for every nested type and ADT $\mathsf{F}$. 

%\section{Primitive representation for GADTs}




\section{Conclusion/Related work}

Mention Patricia/Neil2008 paper

No induction with primitive representation (reference Haskell Symposium paper and~\cite{jp19} and paper Patricia Neil Clement 2010)


\section{TODO}

\begin{itemize}
\item find correct entcsmacro file (current one is for 2018). Maybe ask Ana Sokolova (anas@cs.uni-salzburg.at).
\item reference (correctly) Haskell Symposium paper
\item reference inspiration for STLC GADT : https://www.seas.upenn.edu/~cis194/spring15/lectures/11-stlc.html
\end{itemize}

%%% Added to bibliography:

%@inproceedings{jp20,
%  author = {P. Johann and A. Polonsky},
%  title = {Deep Induction: Induction Rules for (Truly) Nested Types},
%  year = {2020},
%  booktitle = {Foundations of Software Science and Computation Structures},
%  pages = {339-358}
%}
%
%@inproceedings{jgj21,
%  author = {P. Johann and E. Ghiorzi and D. Jeffries},
%  title = {Parametricity for Primitive Nested Types},
%  year = {2021},
%  booktitle = {Foundations of Software Science and Computation Structures},
%  pages = {324-343}
%}
%
%@inproceedings{bm98,
% title={Nested datatypes},
% author={R. Bird, and L. Meertens},
% booktitle={Mathematics of Program Construction},
% year={1998}
% pages = {52â€“67}
%}


\bibliography{gadt-story-references}


\end{document}
