% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2020}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations
%\citestyle{acmnumeric}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\usepackage[utf8]{inputenc}
\usepackage{ccicons}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amscd}
%\usepackage{MnSymbol}
\usepackage{xcolor}

\usepackage{bbold}
\usepackage{url}
\usepackage{upgreek}
%\usepackage{stmaryrd}

\usepackage{lipsum}
\usepackage{tikz-cd}
\usetikzlibrary{cd}
\usetikzlibrary{calc}
\usetikzlibrary{arrows}

\usepackage{bussproofs}
\EnableBpAbbreviations

\input{macros}
\input{mytheorem}

\theoremstyle{definition}
\newtheorem{exmpl}{Example}

\renewcommand{\greyout}[1]{} %{{\color{gray} {#1}}} -- toggle to remove greyed text

\newcommand{\emptyfun}{{[]}}
\newcommand{\cal}{\mathcal}
%\newcommand{\fold}{\mathit{fold}}
\newcommand{\F}{\mathcal{F}}
\renewcommand{\G}{\mathcal{G}}
\newcommand{\N}{\mathcal{N}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\B}{\mathcal{B}}
\renewcommand{\P}{\mathcal{A}}
\newcommand{\pred}{\mathsf{Fam}}
\newcommand{\env}{\mathsf{Env}}
\newcommand{\set}{\mathsf{Set}}
\renewcommand{\S}{\mathcal S}
\renewcommand{\C}{\mathcal{C}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\A}{\mathcal{A}}
\renewcommand{\id}{\mathit{id}}
\newcommand{\map}{\mathsf{map}}
\DeclareMathOperator{\build}{build}
\DeclareMathOperator{\nil}{nil}
\DeclareMathOperator{\cons}{cons}
\newcommand{\pid}{\underline{\mathit{id}}}
\newcommand{\pcirc}{\,\underline{\circ}\,}
\newcommand{\pzero}{\underline{0}}
\newcommand{\pone}{\underline{1}}
\newcommand{\psum}{\,\underline{+}\,}
%\newcommand{\inl}{\mathit{inL}\,}
%\newcommand{\inr}{\mathit{inR}\,}
\newcommand{\pinl}{\underline{\mathit{inL}}\,}
\newcommand{\pinr}{\underline{\mathit{inR}}\,}
\newcommand{\ptimes}{\,\underline{\times}\,}
\newcommand{\ppi}{\underline{\pi_1}}
\newcommand{\pppi}{\underline{\pi_2}}
\newcommand{\pmu}{\underline{\mu}}

\title[Free Theorems for Nested Types]{Free Theorems for 
Nested Types} %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Patricia Johann and Andrew Polonsky}
%\authornote{with author1 note}          %% \authornote is optional;
%                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position1}
%  \department{Department1}              %% \department is recommended
  \institution{Appalachian State University}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
%  \country{Country1}                    %% \country is recommended
}
\email{johannp@appstate.edu, andrew.polonsky@gmail.com}          %% \email is recommended


\begin{document}

\begin{abstract}
\end{abstract}

%\begin{CCSXML}
%<ccs2012>
%<concept>
%<concept_id>10011007.10011006.10011008</concept_id>
%<concept_desc>Software and its engineering~General programming languages</concept_desc>
%<concept_significance>500</concept_significance>
%</concept>
%<concept>
%<concept_id>10003456.10003457.10003521.10003525</concept_id>
%<concept_desc>Social and professional topics~History of programming languages</concept_desc>
%<concept_significance>300</concept_significance>
%</concept>
%</ccs2012>
%\end{CCSXML}
%
%\ccsdesc[500]{Software and its engineering~General programming languages}
%\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
%\keywords{keyword1, keyword2, keyword3}  %% \keywords is optional



\maketitle

\section{Short Cut Fusion for Arbitrary Nested Types}

\vspace*{0.2in}

{\color{red} Can take $\emptyset;\alpha \vdash c$ with
  $\setsem{\emptyset;\alpha \vdash c}\rho = C$ for all $\rho$, i.e.,
  can take $c$ to denote a constant $C$. We then get a free theorem
  whose conclusion is $\textit{fold}_{H}\, B \; \circ \; G\; \mu H \;
  in_{H} = G \,\setsem{\emptyset;\alpha \vdash K}\, B$.}

\begin{thm}
Let $\emptyset;\phi,\alpha \vdash F : \F$, let $\emptyset; \alpha
\vdash K : \F$, and let $\phi ;\emptyset\,|\,\emptyset\vdash g :
\Nat^\emptyset\,(\Nat^\alpha\,F\,(\phi\alpha)) \,
(\Nat^\alpha\,\onet \, (\phi\alpha))$. If we let $H :
    [\set,\set] \to [\set,\set]$ be defined by
\[\begin{array}{lll}
H\,f\,x & = & \setsem{\emptyset; \phi, \alpha \vdash F}[\phi :=
  f][\alpha := x]\\
\end{array}\]
and let
\[G = \setsem{\phi;\emptyset\,|\,\emptyset \vdash g :
\Nat^\emptyset\,(\Nat^\alpha\,F\,(\phi\alpha))\,(\Nat^\alpha\,\onet 
\, (\phi\alpha))}\] 
then we have that, for every $B \in H
\setsem{\emptyset;\alpha \vdash K} \rightarrow \setsem{\emptyset;
  \alpha \vdash K}$, 
\[\textit{fold}_{H}\, B \, (G\; \mu H \; in_{H}) = G
\,\setsem{\emptyset;\alpha \vdash K}\, B \]
\end{thm}

\vspace*{0.2in}

\begin{proof}
We first note that the type of $g$ is well-formed since
$\emptyset;\phi,\alpha \vdash F : \F$ so our promotion theorem gives
that $\phi,\alpha \vdash F : \F$, and $\phi;\alpha \vdash \phi\alpha :
\F$, so that $\phi;\emptyset \vdash \Nat^\alpha F\,(\phi\alpha) : \T$
and $\phi;\emptyset \vdash \Nat^\alpha \onet \,(\phi\alpha) : \T$.
Then $\phi;\emptyset \vdash \Nat^\alpha F\,(\phi\alpha) : \F$ and
$\phi;\emptyset \vdash \Nat^\alpha \onet \,(\phi\alpha) : \F$ also
hold, and, finally, 
$\phi ;\emptyset\vdash 
\Nat^\emptyset\,(\Nat^\alpha\,F\,(\phi\alpha)) \,
(\Nat^\alpha\,\onet \, (\phi\alpha)) : \T$
  
Theorem~\ref{thm:abstraction} gives that, for any relation environment
$\rho$ and any $(a, b) \in \relsem{\phi,\alpha;\emptyset \vdash
  \emptyset}\rho = 1$, eliding the only possible instantiations
of $a$ and $b$ gives that
\[\begin{array}{lll}
(G \,(\pi_1 \rho), G\, (\pi_2 \rho))
& \in & \relsem{\phi;\emptyset\vdash \Nat^{\emptyset} (\Nat^\alpha
  F\, (\phi\alpha))\, (\Nat^\alpha\,\onet \, (\phi\alpha))}
\rho\\ 
& = & \relsem{\phi;\emptyset\vdash \Nat^\alpha F\,
  (\phi\alpha)}\rho \to \relsem{\phi;\emptyset\vdash
  \Nat^\alpha\,\onet \, (\phi\alpha)}\rho\\ 
& = & \relsem{\phi;\emptyset\vdash \Nat^\alpha F\,
  (\phi\alpha)}\rho \to (\,\lambda A. 1 \Rightarrow \lambda A.\,(\rho
\phi) A\,)\\   
& = & \relsem{\phi;\emptyset\vdash \Nat^\alpha F\,
  (\phi\alpha)}\rho \to (1 \Rightarrow \rho \phi)\\ 
& = & \relsem{\phi;\emptyset\vdash \Nat^\alpha F\,
  (\phi\alpha)}\rho \to \rho \phi
\end{array}\]
\noindent
where $H^\rel : [\rel,\rel] \to [\rel,\rel]$ is defined by
$H^\rel\,f\,x = \relsem{\emptyset; \phi, \alpha \vdash F}[\phi :=
  f][\alpha := x]$. So if $(A, B) \in \relsem{\phi;\emptyset\vdash
  \Nat^\alpha F\, (\phi\alpha)}\rho$ then
\[\begin{array}{lll}
(G \,(\pi_1 \rho)\, A, G\, (\pi_2 \rho)\, B) & \in & \rho \phi
\end{array}\]
Now note that
\[\setsem{\vdash \fold_F^K :
  \Nat^{\emptyset}\, (\Nat^\alpha F[\phi := K]\,K)\, (\Nat^\alpha ((\mu
  \phi.\lambda\alpha.F)\alpha)\,K)} = \textit{fold}_H\]
and consider the instantiation 
\[\begin{array}{lll}
A &=& \mathit{in}_H :  H (\mu H) \Rightarrow \mu H\\
B & : & H\setsem{\emptyset;\alpha\vdash K} \Rightarrow
\setsem{\emptyset;\alpha \vdash K}\\
\rho \beta &=& \graph{\textit{fold}_H\, B} \hspace*{0.2in} {
  \color{red} \mbox{a graph of a natural transformation, defined in
    Enrico's notes}} 
\end{array}\]
(Note that all the types here are well-formed.) This gives
\[\begin{array}{lll}
\pi_1 \rho \beta &=& \mu H\\
\pi_2 \rho \beta &=& \setsem{\emptyset;\alpha\vdash K}\\
\rho \beta &:& \rel(\pi_1 \rho \beta, \pi_2 \rho \beta)\\
A & : & \setsem{\phi; \emptyset \vdash \Nat^\alpha
  F \, (\phi \alpha)} (\pi_1 \rho)\\
B & : & \setsem{\phi; \emptyset \vdash \Nat^\alpha
  F \, (\phi \alpha)} (\pi_2 \rho)\\
\end{array}\]
since
\[\begin{array}{lll}
A \; = \; \mathit{in}_H & : & H(\mu H) \Rightarrow \mu H\\
& = & \setsem{\emptyset; \phi, \alpha \vdash F}[\phi := \mu
  \setsem{\emptyset; \phi, \alpha \vdash F}] \Rightarrow \mu
  \setsem{\emptyset; \phi, \alpha \vdash F}\\  
& = & \setsem{\emptyset; \phi, \alpha \vdash F}(\pi_1\rho)
  \Rightarrow \setsem{\emptyset; \phi,\alpha \vdash \phi\alpha}(\pi_1 \rho)\\
& = & \setsem{\phi; \alpha \vdash F}(\pi_1\rho)
  \Rightarrow \setsem{\phi;\alpha \vdash \phi\alpha}(\pi_1
  \rho) \hspace*{0.25in} {\color{red} \mbox{Daniel's trick; now a theorem}}\\
& = & \setsem{\phi;\emptyset \vdash \Nat^\alpha F
    \,(\phi\alpha)}(\pi_1\rho) 
\end{array}\]
We also have
\[\begin{array}{lll}
(A,B) \,=\, (\mathit{in}_H,B) & \in & \relsem{\phi;\emptyset\vdash
  \Nat^\alpha F\, (\phi\alpha)}\rho\\
 & = & \lambda A. \relsem{\phi;\alpha\vdash F}\rho[\alpha := A]
\Rightarrow \lambda A. (\rho\phi) A\\
& = & \lambda A. \relsem{\phi;\alpha\vdash F}[\phi :=
  \graph{\textit{fold}_H\, B}][\alpha := A] \Rightarrow 
\graph{\textit{fold}_H\, B} \\ 
& = & \lambda A. \relsem{\emptyset;\phi,\alpha\vdash F}[\phi :=
  \graph{\textit{fold}_H\, B}][\alpha := A] \Rightarrow 
\graph{\textit{fold}_H\, B}  \hspace*{0.25in} {\color{red}
  \mbox{Daniel's trick; now a theorem}}\\  
& = & \relsem{\emptyset;\phi,\alpha\vdash F}
  \graph{\textit{fold}_H\, B} \Rightarrow \graph{\textit{fold}_H\,
    B}\\
  & = & \graph{\setsem{\emptyset;\phi,\alpha\vdash F}
    \,(\mathit{fold}_H\,B)} \Rightarrow \graph{\textit{fold}_H\, B}
\hspace*{0.25in} {\color{red} \mbox{Graph Lemma}}\\
  & = & \graph{\mathit{map}_H \,(\mathit{fold}_H\,B)} \Rightarrow
\graph{\textit{fold}_H\, B}\\
\end{array}\]
since if $(x,y) \in \graph{\mathit{map}_H \,(\mathit{fold}_H\,B)}$,
i.e., if $\mathit{map}_H \,(\mathit{fold}_H\,B) \, x = y$, then
$\textit{fold}_H\, B\, (\mathit{in}_H\,x) = B\,y = B\, (\mathit{map}_H
\,(\mathit{fold}_H\,B) \, x)$ by the definition of $\mathit{fold}_H$
as a (indeed, the unique) morphism from $\mathit{in}_H$ to $B$. Thus,
\[(G \,(\pi_1 \rho)\, A, G\, (\pi_2 \rho)\, B) \in
\graph{\textit{fold}_H\, B}\] 
i.e.,
\[\textit{fold}_H \, B \, (G\, (\pi_1 \rho) \, \mathit{in}_H) =
G\,(\pi_2 \rho)\,B\] 

\vspace*{0.1in}

\noindent
Since $\beta$ is the only free variable in $G$, this simplifies to
\[\textit{fold}_H\, B \, (G\, \mu H\, \mathit{in}_H) =
G\,\setsem{\emptyset;\alpha\vdash K}\,B\]  
\end{proof}


\end{document}
