% double-blind review submission, w/o CCS and ACM Reference (max
% submission space)
\documentclass[acmsmall,review]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2020}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations
%\citestyle{acmnumeric}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\usepackage[utf8]{inputenc}
\usepackage{ccicons}
\usepackage{verbatim}


\usepackage{adjustbox}
\usepackage{marvosym}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amscd}
%\usepackage{MnSymbol}
\usepackage{xcolor}

\usepackage{bbold}
\usepackage{url}
\usepackage{upgreek}
%\usepackage{stmaryrd}

\usepackage{lipsum}
\usepackage{tikz-cd}
\usetikzlibrary{cd}
\usetikzlibrary{calc}
\usetikzlibrary{arrows}

\usepackage{bussproofs}
\EnableBpAbbreviations

\input{macros}
\input{mytheorem}

\theoremstyle{definition}
\newtheorem{exmpl}{Example}

\renewcommand{\greyout}[1]{} %{{\color{gray} {#1}}} -- toggle to remove greyed text

\newcommand{\ininv}[2]{(\tin^{-1}_{\onet +
  \beta \times \phi (\phi\beta)})_{#1}\, #2}
\newcommand{\emptyfun}{{[]}}
\newcommand{\cal}{\mathcal}
%\newcommand{\fold}{\mathit{fold}}
\newcommand{\F}{\mathcal{F}}
\renewcommand{\G}{\mathcal{G}}
\newcommand{\N}{\mathcal{N}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\B}{\mathcal{B}}
\renewcommand{\P}{\mathcal{A}}
\newcommand{\pred}{\mathsf{Fam}}
\newcommand{\env}{\mathsf{Env}}
\newcommand{\set}{\mathsf{Set}}
\renewcommand{\S}{\mathcal S}
\renewcommand{\C}{\mathcal{C}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\A}{\mathcal{A}}
\renewcommand{\id}{\mathit{id}}
\newcommand{\map}{\mathsf{map}}
\newcommand{\pid}{\underline{\mathit{id}}}
\newcommand{\pcirc}{\,\underline{\circ}\,}
\newcommand{\pzero}{\underline{0}}
\newcommand{\pone}{\underline{1}}
\newcommand{\psum}{\,\underline{+}\,}
\newcommand{\pinl}{\underline{\mathit{inL}}\,}
\newcommand{\pinr}{\underline{\mathit{inR}}\,}
\newcommand{\ptimes}{\,\underline{\times}\,}
\newcommand{\ppi}{\underline{\pi_1}}
\newcommand{\pppi}{\underline{\pi_2}}
\newcommand{\pmu}{\underline{\mu}}
\newcommand{\semmap}{\mathit{map}}
\newcommand{\subst}{\mathit{subst}}

\newcommand{\tb}[1]{~~ \mbox{#1} ~~}
\newcommand{\listt}[1]{(\mu \phi. \lambda \beta . \onet + \beta \times
  \phi \beta) #1} 
\newcommand{\filtype}{\Nat^\emptyset 
 (\Nat^\emptyset \, \alpha \, \mathit{Bool})\, (\Nat^\emptyset 
  (List \, \alpha) \, (List \, \alpha))} 
\newcommand{\filtypeGRose}{\Nat^\emptyset 
 (\Nat^\emptyset \, \alpha \, \mathit{Bool})\, (\Nat^\emptyset 
  (\mathit{GRose}\,\psi \, \alpha) \, (\mathit{GRose}\,\psi \, (\alpha
  + \onet)))} 
\newcommand{\maplist}{\mathit{map}_{\lambda A. \setsem{\emptyset; \alpha
      \vdash \mathit{List} \, \alpha} \rho[\alpha := A]}} 
\newcommand{\PLeaves}{\mathsf{PLeaves}}
\newcommand{\swap}{\mathsf{swap}}
\newcommand{\reverse}{\mathsf{reverse}}
\newcommand{\Bcons}{\mathit{Bcons}}
\newcommand{\Bnil}{\mathit{Bnil}}

\title[Paramrtricity for Primitive Nested Types and
  GADTs]{Parametricity for Primitive
  Nested Types and GADTs} %% [Short Title] is optional; when present,
                         %% will be used in header instead of Full
                         %% Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Patricia Johann, Enrico Ghiorzi, and Daniel Jeffries}
%\authornote{with author1 note}          %% \authornote is optional;
%                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position1}
%  \department{Department1}              %% \department is recommended
  \institution{Appalachian State University}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
%  \country{Country1}                    %% \country is recommended
}
\email{johannp@appstate.edu, ghiorzie@appstate.edu, jeffriesd@appstate.edu}          %% \email is recommended

\begin{document}

\begin{abstract}
This paper considers parametricity and its consequent free theorems
for nested data types. Rather than representing nested types via their
Church encodings in a higher-kinded or dependently typed extension of
System F, we adopt a functional programming perspective and design a
Hindley-Milner-style calculus with primitives for constructing nested
types directly as fixpoints. Our calculus can express all nested types
appearing in the literature, including truly nested types. At the
level of terms, it supports primitive pattern matching, map functions,
and fold combinators for nested types. Our main contribution is the
construction of a parametric model for our calculus. This is both
delicate and challenging. In particular, to ensure the existence of
semantic fixpoints interpreting nested types, and thus to establish a
suitable Identity Extension Lemma for our calculus, our type system
must explicitly track functoriality of types, and cocontinuity
conditions on the functors interpreting them must be appropriately
threaded throughout the model construction. We also prove that our
model satisfies an appropriate Abstraction Theorem, as well as that it
verifies all standard consequences of parametricity in the presence of
primitive nested types. In particular, we give several examples
illustrating how how our model can be used to derive useful free
theorems for programs over nested types.
\end{abstract}


\maketitle

\section{Introduction}\label{sec:intro}

{\em Algebraic data types} (ADTs), both built-in and user-defined,
have long been at the core of functional languages such as Haskell,
ML, Agda, Epigram, and Idris. ADTs, such as that of natural numbers,
can be unindexed. But they can also be indexed over other types. For
example, the ADT of lists (here coded in Agda)

{\small
\[\begin{array}{l}
\mathtt{data\; List \;(A : Set)\;:\;Set\;where}\\
\hspace*{0.4in}\mathtt{nil\;:\; List\;A}\\
\hspace*{0.4in}\mathtt{cons\;:\;A \rightarrow List\;A \rightarrow List\;A}
\end{array}\]}

\noindent
is indexed over its element type $\mathtt{A}$.  The instance of
$\mathtt{List}$ at index $\mathtt{A}$ depends only on itself, and so is
independent of $\mathtt{List\,B}$ for any other index $\mathtt{B}$.
That is, $\mathtt{List}$, like all other ADTs, defines a {\em family
  of inductive types}, one for each index type.

Over time, there has been a notable trend toward data types whose
non-regular indexing can capture invariants and other sophisticated
properties that can be used for program verification and other
applications.  A simple example of such a type is given by Bird and
Meertens'~\cite{bm98} prototypical nested type
\[\begin{array}{l}
\mathtt{data\; PTree\;(A : Set)\;:\;Set\;where}\\
\hspace*{0.4in}\mathtt{pleaf\;:\;A \rightarrow PTree\;A}\\
\hspace*{0.4in}\mathtt{pnode\;:\;PTree\;(A \times A) \rightarrow PTree\;A}
\end{array}\]
\noindent
of perfect trees, which can be thought of as constraining lists to
have lengths that are powers of 2.  The above code makes clear that
perfect trees at index type $\mathtt{A}$ are defined in terms of
perfect trees at index type $\mathtt{A \times A}$. This is typical of
nested types, one type instance of which can depend on others, so that
the entire family of types must actually be defined at once. A nested
type thus defines not a family of inductive types, but rather an {\em
  inductive family of types}.  Nested types include simple nested
types, like perfect trees, none of whose recursive occurrences occur
below another type constructor; ``deep'' nested types~\cite{jp20},
such as the nested type {\small
\[\begin{array}{l}
\mathtt{data\; PForest\;(A : Set)\;:\;Set\;where}\\
\hspace*{0.4in}\mathtt{fempty\;:\;PForest\;A}\\
\hspace*{0.4in}\mathtt{fnode\;:\; A \rightarrow PTree\;(PForest\;A) \to
PForest\;A}
\end{array}\]}
\hspace{-0.04in}of perfect forests, whose recursive occurrences appear
below type constructors for other nested types; and truly nested
types,
%\footnote{Nested types that are defined over themselves are known
%  as {\em truly nested types}.}
such as the nested type {\small
\[\begin{array}{l}
\mathtt{data\; Bush\;(A : Set)\;:\;Set\;where}\\
\hspace*{0.4in}\mathtt{bnil\;:\; Bush\;A}\\
\hspace*{0.4in}\mathtt{bcons\;:\;A \rightarrow Bush\;(Bush \; A)
  \rightarrow Bush\;A} 
\end{array}\]}
\hspace{-0.04in}of bushes, whose recursive occurrences appear below
their own type constructors.

{\em Relational parametricity} encodes a powerful notion of
type-uniformity, or representation independence, for data types in
polymorphic languages. It formalizes the intuition that a polymorphic
program must act uniformly on all of its possible type instantiations
by requiring that every such program preserves all relations between
pairs of types at which it is instantiated. Parametricity was
originally put forth by Reynolds~\cite{rey83} for System
F~\cite{gir72}, the calculus at the core of all polymorphic functional
languages. It was later popularized as Wadler's ``theorems for
free''~\cite{wad89}, so called because it can deduce properties of
programs in such languages solely from their types, i.e., with no
knowledge whatsoever of the text of the programs involved.  Most of
Wadler's free theorems are consequences of naturality for polymorphic
list-processing functions. However, parametricity can also derive
results that go beyond just naturality, such as correctness for ADTs
of the program optimization known as {\em short cut
  fusion}~\cite{glp93,joh02}.

But what about nested types? Does parametricity still hold if such
types are added to polymorphic calculi? More practically, can we
justifiably reason type-independently about (functions over) nested
types in functional languages?

Type-independent reasoning about ADTs in functional languages is
usually justified by first representing ADTs by their Church
encodings, and then reasoning type-independently about these
encodings. This is typically justified by constructing a parametric
model --- i.e, a model in which polymorphic functions preserve
relations {\em \'a la} Reynolds --- for a suitable fragment of System
F, demonstrating that an initial algebra exists for the positive type
constructor corresponding to the functor underlying an ADT of
interest, and showing that each such initial algebra is suitably
isomorphic to its corresponding Church encoding. In fact, this
isomorphism of initial algebras and their Church encodings is one of
the ``litmus tests'' for the goodness of a parametric model.

This approach works well for ADTs, which are always fixpoints of {\em
  first-order} functors, and whose Church encodings, which involve
quantification over only type variables, are always expressible in
System F. For example, $\mathtt{List\,A}$ is the fixpoint of the
first-order functor $F\,X = 1 + A \times X$ and has Church encoding
$\forall \alpha. \, \alpha \to (\mathtt{A} \to \alpha \to \alpha) \to
\alpha$. But despite Cardelli's~\cite{car97} claim that ``virtually
any basic type of interest can be encoded within F$_2$'' --- i.e.,
within System F --- non-ADT nested types cannot.  Not even our
prototypical nested type of perfect trees has a Church encoding
expressible in System F!  Indeed, $\mathtt{PTree\,A}$ cannot be
represented as the fixpoint of any {\em first-order} functor. However,
it can be seen as the instance at index $\mathtt{A}$ of the fixpoint
of the {\em higher-order} functor $H\,F\,A\,=\, (A \to F\,A) \to (F
\,(A \times A) \to F\,A) \to F\,A$. It thus has Church encoding
$\forall f.\, (\forall \alpha.\,\alpha \to f\alpha) \to (\forall
\alpha. \,f (\alpha \times \alpha) \to f\alpha) \to \forall \alpha.\,
f\alpha$, which requires quantification at the higher kind $* \to *$
for $f$. A similar situation obtains for any (non-ADT) nested
type. Unfortunately, higher-kinded quantification is not available in
System F, so if we want to reason type-independently about nested
types in a language based on it we have only two options: {\em
  i})\,move to an extension of System F, such as the higher-kinded
calculus F$_\omega$ or a dependent type theory, and reason via their
Church encodings in a known parametric model for that extension, or
{\em ii})\, add nested types to System F as primitives --- i.e., as
primitive type-level fixpoints --- and construct a parametric model
for the result.

Since the type systems of F$_\omega$ and dependent type theories are
designed to extend System F with far more than non-ADT data types, it
seems like serious overkill to pass to their parametric models to
reason about nested types in System F. Indeed, such calculi support
fundamentally new features that add complexity to their models that is
entirely unnecessary for reasoning about nested types. This paper
therefore pursues the second option above.  We first design a
Hindley-Milner-style calculus supporting primitive nested types,
together with primitive types of natural transformations representing
morphisms between them. Our calculus can express all nested types
appearing in the literature, including truly nested types.  At the
term-level, it supports primitive pattern matching, map functions, and
fold combinators for nested types.\footnote{We leave incorporating
  general term-level recursion to future work because, as
  Pitts~\cite{pit00} reminds us, ``it is hard to construct models of
  both impredicative polymorphism and fixpoint recursion''. In fact,
  as the development in this paper shows, constructing a parametric
  model even for our predicative calculus with primitive nested types
  --- and even without term-level fixpoints --- is already rather
  involved.
%  in part because, as
%  Pitts~\cite{pit00} reminds us, ``it is hard to construct models of
%  both impredicative polymorphism and fixpoint recursion'', and in
%  part because constructing a parametric model even for a predicative
%  calculus with primitive nested types is already rather involved.
  On
  the other hand, our calculus is strongly normalizing, so it perhaps
  edges us toward the kind of provably total practical programming
  language proposed in~\cite{wad89}.}  Our main contribution is the
construction of a parametric model for our calculus. This is both
delicate and challenging. To ensure the existence of semantic
fixpoints interpreting nested types, and thus to establish a suitable
Identity Extension Lemma, our type system must explicitly track
functoriality of types, and cocontinuity conditions on the functors
interpreting them must be appropriately threaded throughout the model
construction. Our model validates all standard consequences of
parametricity in the presence of primitive nested types, including the
isomorphism of primitive ADTs and their Church encodings, and
correctness of short cut fusion for nested types. The relationship
between naturality and parametricity has long been of interest, and
our inclusion of a primitive type of natural transformations allows us
to clearly delineate those consequences of parametricity that follow
from naturality, from those, such as short cut fusion for nested
types, that require the full power of parametricity.

\vspace*{0.1in}

\noindent
{\bf Structure of this Paper}\/ We introduce our calculus in
Section~\ref{sec:calculus}.  Its type system is based on the
level-2-truncation of the higher-kinded grammar from~\cite{jp19},
augmented with a primitive type of natural
transformations. (Since~\cite{jp19} contains no term calculus, the
issue of parametricity could not even be raised there.)  In
Section~\ref{sec:type-interp} we give set and relational
interpretations of our types. Set interpretations are possible
precisely because our calculus is predicative --- as ensured by our
primitive natural transformation types --- and~\cite{jp19} guarantees
that local finite presentability of $\set$ makes it suitable for
interpreting nested types.  As is standard in categorical models,
types are interpreted as functors from environments interpreting their
type variable contexts to sets or relations, as appropriate. To ensure
that these functors satisfy the cocontinuity properties needed for the
semantic fixpoints interpreting nested types to exist, set environments
must map $k$-ary type constructor variables to appropriately
cocontinuous $k$-ary functors on sets, relation environments must map
$k$-ary type constructor variables to appropriately cocontinuous
$k$-ary relation transformers, and these cocontinuity conditions must
be threaded through our type interpretations in such a way that an
Identity Extension Lemma (Theorem~\ref{thm:iel}) can be
proved. Properly propagating the cocontinuity conditions requires
considerable care, and Section~\ref{sec:iel}, where it is done, is
(apart from tracking functoriality in the calculus so that it is
actually possible) where the bulk of the work in constructing our
model lies.

In Section~\ref{sec:term-interp}, we give set and relational
interpretations for the terms of our calculus. As usual in categorical
models, terms are interpreted as natural transformations from
interpretations of their term contexts to interpretations of their
types, and these must cohere in what is essentially a fibred way.  In
Section~\ref{sec:Nat-type-terms} we prove a scheme deriving free
theorems that are consequences of naturality of polymorphic functions
over nested types. This scheme is very general, and is parameterized
over both the data type and the type of the polymorphic function at
hand. It has, for example, analogues for nested types of Wadler's
map-rearrangement free theorems as instances. In
Section~\ref{sec:thms} we prove that our model satisfies an
Abstraction Theorem (Theorem~\ref{thm:abstraction}), which we use to
derive other parametricity results that go beyond naturality. We
conclude in Section~\ref{sec:conclusion}.

\vspace*{0.05in}

\noindent
{\bf Related Work}\/ There is a long line of work on categorical
models of parametricity for System F; see,
e.g.,~\cite{bfss90,bm05,dr04,gjfor15,has94,jac99,mr92,rr94}.  To our
knowledge, all such models treat ADTs via their Church encodings,
verifying in the just-constructed parametric model that each Church
encoding is isomorphic to the data type it encodes.  The present paper
draws on this rich tradition of categorical models of parametricity
for System F, but modifies them to treat nested types (and therefore
ADTs) as primitive data types.

The only other extensions we know of System F with primitive data
types are those in~\cite{mat11,mg01,pit98,pit00,wad89}.
Wadler~\cite{wad89} treats full System F, and sketches parametricity
for its extension with lists. Martin and Gibbons~\cite{mg01} outline a
semantics for a grammar of primitive nested types similar to that
in~\cite{jp19}, but treat only polynomial nested types, i.e., nested
types that are fixpoints of polynomial higher-order
functors. Unfortunately, the model suggested in~\cite{mg01} is not
entirely correct (see~\cite{jp19}), and parametricity is nowhere
mentioned.  Matthes~\cite{mat11} treats System F with non-polynomial
ADTs and nested types, but his focus is on expressivity of generalized
Mendler iteration for them. He gives no semantics.

In~\cite{pit00}, Pitts adds list ADTs to full System F with a
term-level fixpoint primitive. Other ADTs are included
in~\cite{pit98}, but nested types are not expressible in either
syntax. Pitts constructs parametric models for his calculi based on
operational, rather than categorical, semantics. A benefit of using
operational semantics to build parametric models is that it avoids
needing to work in a suitable metatheory to accommodate System F's
impredicativity. It is well-known that there are no set-based
parametric models of System F~\cite{rey84}, so parametric models for
it and its extensions are often constructed in a syntactic metatheory
such as the impredicative Calculus of Inductive Constructions (iCIC).
By adding primitive nested types to a Hindley-Milner-style calculus
and working in a categorical setting we side-step such metatheoretic
distractions. It is important to note that different consequences of
parametricity are available in syntactic and semantic
metatheories. Consequences of parametricity are possible for both
closed and open System F terms in a syntactic metatheory --- although
not all that can be formulated can be always proved; see, e.g., the
end of Section~7 of~\cite{bm98}. By contrast, in a categorical
metatheory consequences of parametricity are expressible only for {\em
  closed} terms. For this reason, validating the standard consequences
of parametricity for closed terms is --- going all the way back to
Reynolds~\cite{rey83} --- all that is required for a model of
parametricity to be considered good.

Atkey~\cite{atk12} treats parametricity for arbitrary higher kinds,
constructing a parametric model for System F$_\omega$ within iCIC,
rather than in a semantic category. His construction is in some ways
similar to ours, but he represents (now higher-kinded) data types
using Church encodings rather than as primitives. Moreover, the
$\mathit{fmap}$ functions associated to Atkey's functors must be {\em
  given}, presumably by the programmer, together with their underlying
type constructors. This absolves him of imposing cocontinuity
conditions on his model to ensure that fixpoints of his functors
exist, but, unfortunately, he does not indicate which type
constructors support $\mathit{fmap}$ functions. We suspect explicitly
spelling out which types can be interpreted as strictly positive
functors would result in a full higher-kinded extension of a calculus
akin to that presented here.

{\color{red} Say extended version of FoSSaCS paper. Say what's
  new/different. GADTs, implementation.

  Send to LMCS? Editor?

Can bind variables of arity > 0 in Nat-types? Improves expressibilty?
Worth it?}   

\section{The Calculus}\label{sec:calculus}

\subsection{Types}
For each $k \ge 0$, we assume countable sets $\tvars^k$ of \emph{type
  constructor variables of arity $k$} and $\fvars^k$ of
\emph{functorial variables of arity $k$}, all mutually disjoint.  The
sets of all type constructor variables and functorial variables are
$\tvars = \bigcup_{k \ge 0} \tvars^k$ and $\fvars = \bigcup_{k \ge 0}
\fvars^k$, respectively, and a \emph{type variable} is any element of
$\tvars \cup \fvars$.  We use lower case Greek letters for type
variables, writing $\phi^k$ to indicate that $\phi \in \tvars^k \cup
\fvars^k$, and omitting the arity indicator $k$ when convenient,
unimportant, or clear from context. Letters from the beginning of the
alphabet denote type variables of arity $0$, i.e., elements of
$\tvars^0 \cup \fvars^0$. We write $\overline{\phi}$ for either a set
$\{\phi_1,...,\phi_n\}$ of type constructor variables or a set of
functorial variables when the cardinality $n$ of the set is
unimportant or clear from context. If $V$ is a set of type variables
we write $V, \overline{\phi}$ for $V \cup \overline{\phi}$ when $V
\cap \overline{\phi} = \emptyset$.  We omit the vector notation for a
singleton set, thus writing $\phi$, instead of $\overline{\phi}$, for
$\{\phi\}$.

If $\Gamma$ is a finite subset of\, $\tvars$, $\Phi$ is a finite
subset of\, $\fvars$, $\overline{\alpha}$ is a finite subset of\,
$\fvars^0$ disjoint from $\Phi$, and $\phi^k \in \fvars^k \setminus
\Phi$, then the set $\mcF^\Pos(V)$ of {\em functorial expressions}
over $\Gamma$ and $\Phi$ are given in
Definition~\ref{def:wftypes}. The notation there entails that an
application $F F_1...F_k$ is allowed only when $F$ is a type variable
of arity $k$, or $F$ is a subexpression of the form $\mu
\phi^{k}.\lambda \alpha_1...\alpha_k.F'$. Moreover, if $F$ has arity
$k$ then $F$ must be applied to exactly $k$ arguments.  Accordingly,
an overbar indicates a sequence of subexpressions whose length matches
the arity of the type applied to it.  Requiring that types are always
in such \emph{$\eta$-long normal form} avoids having to consider
$\beta$-conversion at the level of types. In a subexpression
$\Nat^{\ol{\alpha}}F\,G$, the $\Nat$ operator binds all occurrences of
the variables in $\ol{\alpha}$ in $F$ and $G$; intuitively,
$\Nat^{\ol{\alpha}}F\,G$ represents the type of a natural
transformation in $\ol{\alpha}$ from the functor $F$ to the functor
$G$.  In a subexpression $\mu \phi^k.\lambda \ol{\alpha}.F$, the $\mu$
operator binds all occurrences of the variable $\phi$, and the
$\lambda$ operator binds all occurrences of the variables in
$\ol{\alpha}$, in the body $F$.

A {\em type constructor context}, or {\em non-functorial context}, is
a finite set $\Gamma$ of type constructor variables, and a {\em
  functorial context} is a finite set $\Phi$ of functorial
variables. In Definition~\ref{def:wftypes}, a judgment of the form
$\Gamma;\Phi \vdash F$ indicates that the type $F$ is intended to be
functorial in the variables in $\Phi$ but not necessarily in those in
$\Gamma$.

\begin{dfn}\label{def:wftypes}
The formation rules for the set $\F$ of\, {\em well-formed types
  {\color{red} over $\Gamma$ and $\Phi$?}} are

\vspace*{-0.2in}

\[\begin{array}{cc}
\AXC{\phantom{$\Gamma,\Phi$}}
\UIC{$\Gamma;\Phi \vdash \zerot$}
\DisplayProof
&
\AXC{\phantom{$\Gamma,\Phi$}}
\UIC{$\Gamma;\Phi \vdash \onet$}
\DisplayProof
\end{array}\]
\[\begin{array}{c}
\AXC{$\Gamma;\ol{\alpha^0} \vdash F$}
\AXC{$\Gamma;\ol{\alpha^0}  \vdash G$}
\BIC{$\Gamma;\emptyset \vdash \Nat^{\ol{\alpha^0}}F \,G$}
\DisplayProof
\\[3ex]
\AXC{$\phi^k \in \Gamma \cup \Phi$}
\AXC{$\quad\quad\ol{\Gamma;\Phi \vdash F}$}
\BIC{$\Gamma;\Phi \vdash \phi^k \ol{F}$}
\DisplayProof
\\[3ex]
\AXC{$\Gamma;\ol{\gamma^0},\ol{\alpha^0},\phi^k \vdash F$}
\AXC{$\quad\quad\ol{\Gamma;\Phi \vdash G}$}
\AXC{$\quad\quad\ol{\Gamma;\Phi \vdash H}$}
\TIC{$\Gamma;\Phi \vdash (\mu \phi^k.\lambda
  \ol{\alpha^0}. \,F[\ol{\gamma := H}])\,\ol{G}$}  
\DisplayProof
\end{array}\]

\vspace*{0.04in}

\[\begin{array}{cc}
\AXC{$\Gamma;\Phi \vdash F$}
\AXC{$\Gamma;\Phi \vdash G$}
\BIC{$\Gamma; \Phi \vdash F + G$}
\DisplayProof
&
\AXC{$\Gamma;\Phi \vdash F$}
\AXC{$\Gamma;\Phi \vdash G$}
\BIC{$\Gamma; \Phi \vdash F \times G$}
\DisplayProof
\end{array}\]
\end{dfn}

We write $\vdash F$ for $\emptyset;\emptyset \vdash F$.
Definition~\ref{def:wftypes} ensures that the expected weakening rules
for well-formed types hold, although weakening does not change the
contexts in which types can be formed. If $\Gamma;\emptyset \vdash F$
and $\Gamma;\emptyset \vdash G$, then our rules allow formation of the
types $\Gamma;\emptyset \vdash \Nat^\emptyset F \,G$ and $\Gamma;
\emptyset \vdash \Nat^{\ol\alpha} \,\onet \,F$, which represent the
System F types $\Gamma \vdash F \to G$ and $\forall$-type $\Gamma;
\emptyset \vdash \forall \ol\alpha . F$, respectively. However, some
System F types, such as $\forall \alpha. (\alpha \to \alpha) \to
\alpha$, are not representable in our calculus.

Definition~\ref{def:wftypes} allows the formation of all of the
(closed) nested types from the introduction:
\[\begin{array}{lll}
\mathit{List}\, \alpha & = & \mu \beta. \,\onet + \alpha \times
\beta\; = \; (\mu \phi. \lambda \beta.\,\onet + \beta \times \phi
\beta)\,\alpha\\ 
\mathit{PTree}\,\alpha & = & (\mu \phi. \lambda \beta.\,\beta +
\phi\,(\beta \times \beta))\,\alpha\\
\mathit{Forest}\,\alpha & = & (\mu \phi. \lambda \beta. \,\onet +
\beta \times \mathit{PTree}\,(\phi \beta))\,\alpha\\ 
\mathit{Bush}\,\alpha & = & (\mu \phi.\lambda \beta. \,\onet + \beta
\times \phi\,(\phi\beta))\,\alpha 
\end{array}\]
Each of these types can be considered either functorial in $\alpha$ or
not, according to whether $\alpha$ is in the functorial or
non-functorial context in which it is formed. In particular, if
$\emptyset;\alpha \vdash \mathit{List} \,\alpha$, then $\vdash
\Nat^\alpha \onet\, (\mathit{List}\,\alpha)$ is well-formed; if
$\alpha;\emptyset \vdash \List \,\alpha$, then it is not.  Similarly,
if $\mathit{Tree}\,\alpha\,\gamma = \mu \,\beta.\, \alpha + \beta
\times \gamma \times \beta$, then $\gamma;\emptyset \vdash \Nat^\alpha
(\mathit{List}\, \alpha) \, (\mathit{Tree} \, \alpha\, \gamma)$ is
well-formed, but $\emptyset;\gamma \vdash \Nat^\alpha (\mathit{List}\,
\alpha) \, (\mathit{Tree} \, \alpha\, \gamma)$ is not. Although types
can be functorial in variables of arity greater than $0$, the body $F$
of a type $(\mu \phi.\lambda \ol\alpha.F)\ol G$ cannot. For example,
the type $\mathit{GRose}\, \phi \, \alpha = \mu\beta . \alpha \times
\phi \beta$ can be functorial or not in $\alpha$, but cannot be
functorial in $\phi$. Moreover, $\mathit{GRose}\,\phi\,\alpha$ cannot
be the (co)domain of a $\Nat$-type representing a natural
transformation functorial in $\phi$, and the type $\mu \phi. \lambda
\alpha. \mathit{GRose}\,\phi\,\alpha$ is not well-formed in our
system. These restrictions ensure that the set and relational
interpretations of types in Section~\ref{sec:type-interp} are
functors. In Section~\ref{sec:conclusion} we discuss how
more expressive types might be accommodated.

Definition~\ref{def:wftypes} allows well-formed types to be 
functorial in no variables
Functorial variables
%in a well-formed type $\tau$
can also be demoted to non-functorial status: if\,$F[\phi :== \psi]$
is the textual replacement of $\phi$ in $F$, then $\Gamma, \psi^k;
\Phi \vdash F[\phi^k :== \psi^k]$ is derivable whenever $\Gamma; \Phi,
\phi^k \vdash F$ is. The proof is by induction on the structure of
$F$. In addition to textual replacement, we also have a
substitution operation on types.

If $\Gamma; \Phi \vdash F$ is a type, if $\Gamma$ and $\Phi$ contain
only type variables of arity $0$, and if $k=0$ for every occurrence of
$\phi^k$ bound by $\mu$ in $F$, then we say that $F$ is {\em
  first-order}; otherwise we say that $F$ is {\em
  second-order}. Substitution for first-order types is the usual
capture-avoiding textual substitution. We write $F[\alpha := \sigma]$
for the result of substituting $\sigma$ for $\alpha$ in $F$, and
$F[\alpha_1 := F_1,...,\alpha_k := F_k]$, or $F[\ol{\alpha := F}]$
when convenient, for $F[\alpha_1 := F_1][\alpha_2 := F_2,...,\alpha_k
  := F_k]$. The operation of {\em second-order type substitution along
  $\ol\alpha$} is given in Definition~\ref{def:second-order-subst},
where we adopt a similar notational convention for vectors of types.
Of course, $(\cdot)[\phi^0 :=_\emptyset F]$ coincides with first-order
substitution. We omit $\ol\alpha$ when convenient, but note that it
is not correct to substitute along non-functorial variables.

{\color{red} Check no change needed for new $\mu$-rule in next def.}
\begin{dfn}\label{def:second-order-subst}
If \,$\Gamma; \Phi,\phi^k \vdash H$ and $\Gamma;\Phi, \ol{\alpha}
\vdash F$ with $|\ol\alpha| = k$, then the operation $H[\phi :=_{\ol
    \alpha} F]$ of {\em second-order type substitution along
  $\ol\alpha$} is defined by induction on $H$ as follows:
\[\begin{array}{lll}
\zerot[\phi :=_{\ol{\alpha}} F] & = & \zerot\\[0.5ex]
\onet[\phi :=_{\ol{\alpha}} F] & = & \onet\\[0.25ex]
(\Nat^{\ol\beta} G \,K)[\phi :=_{\ol{\alpha}} F]
& = & \Nat^{\ol\beta}\, (G[\phi :=_{\ol{\alpha}} F]) \,(K[\phi
  :=_{\ol{\alpha}} F])\\
(\psi\ol{G})[\phi :=_{\ol{\alpha}} F] & = &
\left\{\begin{array}{ll}
\psi \,\ol{G[\phi :=_{\ol{\alpha}} F]} & \mbox{if } \psi \not = \phi\\
  F[\ol{\alpha  := G[\phi :=_{\ol{\alpha}} F]}] 
  & \mbox{if } \psi = \phi
\end{array}\right.\\[2.8ex]
(G + K)[\phi :=_{\ol{\alpha}} F] & = & G[\phi
  :=_{\ol{\alpha}} F] + K[\phi :=_{\ol{\alpha}} F]\\[0.5ex] 
(G \times K)[\phi :=_{\ol{\alpha}} F] & = &
G[\phi :=_{\ol{\alpha}} F] \times K[\phi
  :=_{\ol{\alpha}} F]\\[0.5ex]   
((\mu \psi. \lambda \ol{\beta}. G)\ol{K})[\phi :=_{\ol{\alpha}}
  F] & = & (\mu \psi. \lambda \ol{\beta}. \,G[\phi :=_{\ol{\alpha}}
  F])\, \ol{K[\phi :=_{\ol{\alpha}} F]}
\end{array}\]
\end{dfn}
\noindent
It is not hard to see that $\Gamma;\Phi \vdash H[\phi :=_{\ol{\alpha}}
  F]$. In addition, if \,$\Gamma, \phi^k; \Phi \vdash H$,\, $\Gamma;
\ol\psi,\ol{\alpha} \vdash F$, $|\ol\alpha| = k$, and $\Phi \cap
\ol\psi = \emptyset$, then $\Gamma,\ol\psi';\Phi \vdash H[\phi
  :=_{\ol{\alpha}} F[\ol{\psi :== \psi'}]]$.

\subsection{Terms}\label{sec:terms}

\begin{figure*}

  \begin{adjustbox}{varwidth=5.4in, max width=5in, fbox, center}
       \[\begin{array}{ccc}
       \AXC{$\Gamma;\Phi \vdash F$}
       \UIC{$\Gamma;\Phi \,|\, \Delta,x :F \vdash x : F$}
       \hspace*{0.2in}\DisplayProof\hspace*{0.05in}
       &
       \AXC{$\Gamma;\Phi \,|\, \Delta \vdash t : \zerot$}
       \AXC{$\Gamma;\Phi \vdash F$}
       \BIC{$\Gamma;\Phi \,|\, \Delta \vdash \bot_F t  : F$}
       \DisplayProof\hspace*{0.05in}
       &
       \AXC{$\phantom{\Gamma;\Phi}$}
       \UIC{$\Gamma;\Phi \,|\, \Delta \vdash \top : \onet$}
       \DisplayProof\\\\
       \end{array}\]
       
       \vspace*{-0.15in}
       
       \[\begin{array}{cc}
       \AXC{$\Gamma;\Phi \,|\, \Delta \vdash s: F$}
       \UIC{$\Gamma;\Phi \,|\, \Delta \vdash \inl \,s: F + G$}
       \hspace*{0.8in}\DisplayProof\hspace*{0.05in}
       &
       \AXC{$\Gamma;\Phi \,|\, \Delta \vdash t : G$}
       \UIC{$\Gamma;\Phi \,|\, \Delta \vdash \inr \,t: F + G$}
       \DisplayProof\\\\
       \end{array}\]
       
       \vspace*{-0.1in}
       
       \[\begin{array}{c}
       \AXC{$\Gamma; \Phi \vdash F,G$}
       \AXC{$\Gamma;\Phi \,|\, \Delta \vdash t : F+G$}
       \AXC{$\Gamma;\Phi \,|\, \Delta, x : F \vdash l : K \hspace{0.2in} \Gamma;\Phi \,|\, \Delta, y : G \vdash r : K$}
       \TIC{$\Gamma;\Phi~|~\Delta \vdash \cse{t}{x \mapsto l}{y \mapsto r} : K$}
       \hspace*{-0.2in}\DisplayProof
       \end{array}\]

       \vspace*{0.05in}
       
       \[\begin{array}{lll}
       \AXC{$\Gamma;\Phi \,|\, \Delta \vdash s: F$}
       \AXC{$\Gamma;\Phi \,|\, \Delta \vdash t : G$}
       \BIC{$\Gamma;\Phi \,|\, \Delta \vdash (s,t) : F \times G$}
       \DisplayProof\hspace*{0.05in}
       &
       \AXC{$\Gamma;\Phi \,|\, \Delta \vdash t : F \times G$}
       \UIC{$\Gamma;\Phi \,|\, \Delta \vdash \pi_1 t : F$}
       \DisplayProof\hspace*{0.05in}
       &
       \AXC{$\Gamma;\Phi \,|\, \Delta \vdash t : F \times G$}
       \UIC{$\Gamma;\Phi \,|\, \Delta \vdash \pi_2 t : G$}
       \DisplayProof
       \end{array}\]

       \[\begin{array}{c}
       \AXC{$\Gamma; \ol{\alpha} \vdash F$}
       \AXC{$\Gamma; \ol{\alpha} \vdash G$}
       \AXC{$\Gamma; \ol{\alpha} \,|\, \Delta, x : F \vdash t: G$} 
       \TIC{$\Gamma; \emptyset
         \,|\, \Delta \vdash L_{\ol{\alpha}} x.t : \Nat^{\ol{\alpha}} \,F \,G$}
       \DisplayProof\vspace*{-0.05in}
       \\\\
       \AXC{$\ol{\Gamma;\Phi \vdash K}$}
       \AXC{$\Gamma; \emptyset
         \,|\, \Delta \vdash t : \Nat^{\ol{\alpha}} \,F \,G$}
       \AXC{$\Gamma;\Phi \,|\, \Delta \vdash s: F[\overline{\alpha := K}]$}
       \TIC{$\Gamma;\Phi\,|\, \Delta \vdash t_{\ol K} s:
         G[\overline{\alpha := K}]$}
       \DisplayProof\vspace*{-0.1in}
       \\\\
       \AXC{$\Gamma; \ol{\phi}, \ol{\gamma} \vdash H$}
       \AXC{$\ol{\Gamma; \ol{\beta},\ol{\gamma} \vdash F}$}
       \AXC{$\ol{\Gamma; \ol{\beta},\ol{\gamma} \vdash
           G}$}
       \TIC{$\Gamma; \emptyset
         ~|~\emptyset
         \vdash \map^{\ol{F},\ol{G}}_H :
         \Nat^\emptyset\;(\ol{\Nat^{\ol{\beta},\ol{\gamma}}\,F\,G})\;
         (\Nat^{\ol{\gamma}}\,H[\ol{\phi :=_{\ol{\beta}} F}]\;H[\ol{\phi
             :=_{\ol{\beta}} G}])$} 
       \DisplayProof\vspace*{-0.1in}
       \\\\
       \AXC{$\Gamma; \phi, \ol{\alpha},\ol{\gamma} \vdash H$}
       \UIC{$\Gamma; \emptyset  \,|\, \emptyset \vdash \tin_H :
         \Nat^{\ol{\beta},\ol{\gamma}} H[\phi :=_{\ol{\beta}} (\mu
           \phi.\lambda \ol{\alpha}.H)\ol{\beta}][\ol{\alpha := \beta}]\,(\mu
         \phi.\lambda \ol{\alpha}.H)\ol{\beta}$}
       \hspace*{0.2in}\DisplayProof\vspace*{-0.1in}
       \\\\
       \AXC{$\Gamma; \phi,\ol{\alpha}, \ol{\gamma} \vdash H$}
       \AXC{$\Gamma; \ol{\beta}, \ol{\gamma} \vdash F$}
       \BIC{$\Gamma; \emptyset  \,|\, \emptyset \vdash \fold^F_H :
         \Nat^\emptyset\; (\Nat^{\ol{\beta}, \ol{\gamma}}\,H[\phi
           :=_{\ol{\beta}} F][\ol{\alpha := \beta}]\,F)\; (\Nat^{\ol{\beta},
           \ol{\gamma}}\,(\mu \phi.\lambda \ol{\alpha}.H)\ol{\beta}\,F)$}
       \hspace*{0.2in}\DisplayProof\vspace*{-0.1in}
       \end{array}\]

       \vspace*{0.05in}

       \caption{Well-formed terms {\color{red} Change last three
           judgements for new $\mu$ rule???}}\label{fig:terms} \vspace*{-0.00in}
\end{adjustbox}
       \vspace*{-0.25in}
\end{figure*}

To define our term calculus we assume an infinite set $\cal V$ of term
variables disjoint from $\tvars$ and $\fvars$. If $\Gamma$ is a type
constructor context and $\Phi$ is a functorial context, then a {\em
  term context for $\Gamma$ and $\Phi$} is a finite set of bindings of
the form $x : F$, where $x \in {\cal V}$ and $\Gamma; \Phi \vdash
F$. We adopt the above conventions for denoting disjoint unions and
vectors in term contexts. If $\Delta$ is a term context for $\Gamma$
and $\Phi$, then the formation rules for the set of {\em well-formed
  terms over $\Delta$} are as in Figure~\ref{fig:terms}. In the rule
there for $L_{\ol{\alpha}}x.t$, the $L$ operator binds all occurrences
of the type variables in $\ol{\alpha}$ in the types of $x$ and $t$, as
well as all occurrences of $x$ in $t$. In the rule for $t_{\ol K} s$
there is one functorial expression in $\ol K$ for every functorial
variable in $\ol \alpha$. In the rule for $\map^{\ol{F},\ol{G}}_H$
there is one functorial expression $F$ and one functorial expression
$G$ for each functorial variable in $\ol\phi$. Moreover, for each
$\phi^k$ in $\ol\phi$ the number of functorial variables in $\ol\beta$
in the judgments for its corresponding functorial expresssions $F$ and
$G$ is $k$. In the rules for $\tin_H$ and $\fold^F_H$, the functorial
variables in $\ol{\beta}$ are fresh with respect to $H$, and there is
one $\beta$ for every $\alpha$. Substitution for terms is the obvious
extension of the usual capture-avoiding textual substitution, and the
rules of Figure~\ref{fig:terms} ensure that weakening is respected.

{\color{red} Change the rest of the section to agree with new term
  formation rules.}  The ``extra'' functorial variables $\ol{\gamma}$
in the rules for $\map^{\ol{F},\ol{G}}_H$, $\tin_H$, and $\fold^F_H$
(i.e., those variables not affected by the substitution of $\phi$)
deserve comment. They allow us to map or fold polymorphic functions
over nested types. Suppose, for example, we want to map the
polymorphic function $\mathit{flatten} : \Nat^\beta
(\mathit{PTree}\,\beta)\,(\mathit{List}\,\beta)$ over a list.  Even in
the absence of extra variables the instance of $\map$ required to map
each non-functorial monomorphic instantiation of $\mathit{flatten}$
over a list of perfect trees is well-typed:
\[\begin{array}{l}
\AXC{$\Gamma;\alpha \vdash \mathit{List} \, \alpha$}
\AXC{$\Gamma;\emptyset \vdash \mathit{PTree}\,F$}
\AXC{$\Gamma;\emptyset \vdash \mathit{List}\,G$}
\TIC{$\Gamma;\emptyset \,|\, \emptyset \vdash \map^{\mathit{PTree}\,F,
    \,\mathit{List}\,G}_{\mathit{List}\,\alpha} :
  \Nat^\emptyset (\Nat^\emptyset\,(\mathit{PTree}\, F)\,(\mathit{List}\, G))\,
  (\Nat^\emptyset\,(\mathit{List}\, (\mathit{PTree}\,
  F))\,(\mathit{List}\, (\mathit{List}\, G)))$} \DisplayProof
\end{array}\]
But in the absence of $\ol \gamma$, the instance
\[\Gamma;\emptyset~|~\emptyset \vdash
\map^{\mathit{PTree}\,\beta,\mathit{List}\,\beta}_{\mathit{List}\,\alpha}
: \Nat^\emptyset ( \Nat^\beta(\mathit{PTree}\,
\beta)\,(\mathit{List}\, \beta))\, (\Nat^\beta\,(\mathit{List}\,
(\mathit{PTree}\, \beta))\,(\mathit{List}\, (\mathit{List}\,
\beta)))\] required to map the {\em polymorphic} $\mathit{flatten}$
function over a list of perfect trees is not: indeed, the functorial
contexts for $F$ and $G$ in the rule for $\map^{F,G}_H$ would have to
be empty, but because the polymorphic $\mathit{flatten}$ function is
natural in some variable, say $\delta$, it cannot possibly have a type
of the form $\Nat^\emptyset F\, G$ as would be required for it to be
the function input to $\map$. Untypeability of this instance of $\map$
is unsatisfactory in a polymorphic calculus, where we naturally expect
to be able to manipulate entire polymorphic functions rather than just
their monomorphic instances, but the ``extra'' variables $\ol \gamma$
remedy the situation, ensuring that the instance of $\map$ needed to
map the polymorphic $\mathit{flatten}$ function is typeable as
follows:

\vspace*{0.1in}

\begin{adjustbox}{varwidth=6.4in, max width=\linewidth, center}
\[\begin{array}{l}
\AXC{$\Gamma;\alpha,\gamma \vdash \mathit{List} \, \alpha$}
\AXC{$\Gamma;\gamma \vdash \mathit{PTree}\,\gamma \hspace*{0.3in}
  \Gamma;\gamma \vdash \mathit{List}\,\gamma$}
\BIC{$\Gamma;\emptyset~|~\emptyset \vdash
  \map^{\mathit{PTree}\,\gamma,\mathit{List}\,\gamma}_{\mathit{List}\,\alpha}  : \Nat^\emptyset
  (\Nat^\gamma(\mathit{PTree}\, 
  \gamma)\,(\mathit{List}\, \gamma))\,
 (\Nat^\gamma\,(\mathit{List}\,
  (\mathit{PTree}\, \gamma))\,(\mathit{List}\, (\mathit{List}\,
  \gamma)))$}
\DisplayProof
  \end{array}\]
\end{adjustbox}

\vspace*{0.1in}

\noindent
Similar remarks justify the appearance of $\ol \gamma$ in the typing
rules for $\tin$ and $\mathsf{fold}$.

Our calculus is expressive enough to define a function
$\mathit{reversePTree :
  \Nat^\alpha\,(\mathit{PTree}\,\alpha)\,(\mathit{PTree}\,\alpha)}$
that reverses the order of the leaves in a perfect tree. This function
maps, e.g., the perfect tree $((1,2),(3,4))$ to $((4,3),(2,1))$, and
can be defined as
\[\vdash (\fold_{\beta + \phi(\beta \times \beta)}^{\mathit{PTree}\,
  \alpha})_\emptyset \, s : \Nat^{\alpha}
(\mathit{PTree}\,\alpha)\,(\mathit{PTree}\,\alpha)\] where
\[\begin{array}{lll}
\fold_{\beta + \phi(\beta \times \beta)}^{\mathit{PTree}\,\alpha} & :
& \Nat^{\emptyset} (\Nat^{\alpha} (\alpha + \mathit{PTree}\,(\alpha
\times \alpha)) \; (\mathit{PTree}\,\alpha))\; (\Nat^{\alpha}
(\mathit{PTree}\,\alpha) \; (\mathit{PTree}\,\alpha))\\
\tin_{\beta + \phi(\beta \times \beta)} & : & \Nat^{\alpha} (\alpha +
\mathit{PTree}\,(\alpha \times \alpha)) \; (\mathit{PTree}\, \alpha)\\
\map_{\mathit{PTree}\,\alpha}^{\alpha \times \alpha, \alpha \times
  \alpha} & : & \Nat^\emptyset
(\Nat^{\alpha} (\alpha \times \alpha)\, (\alpha \times
\alpha))\,
(\Nat^{\alpha} (\mathit{PTree}\,(\alpha \times
\alpha))\, (\mathit{PTree}\,(\alpha \times \alpha)))
\end{array}\]
and 
$\mathit{pleaf}$,$\mathit{pnode}$, $\mathit{swap}$, and $s$ are the terms
\[\begin{array}{l}
\vdash \tin_{\beta + \phi (\beta \times \beta)} \circ (
L_{\alpha} x.\, \inl\, x) \; : \; \Nat^{\alpha}\, \alpha\,
(\mathit{PTree}\,\alpha)\\ 
\vdash \tin_{\beta + \phi (\beta \times \beta)} \circ (
L_{\alpha} x.\, \inr\, x) \; : \; \Nat^{\alpha}\, \mathit{PTree}
(\alpha \times \alpha)\,(\mathit{PTree}\,\alpha)\\ 
\vdash L_{\alpha} p.\, (\pi_2 p, \pi_1 p) :
\Nat^{\alpha} (\alpha \times \alpha)\, (\alpha \times \alpha)\\
\vdash L_{\alpha} t. \,\cse{t}{b \mapsto
 \mathit{pleaf}\, b}{t' \mapsto \mathit{pnode}\, 
    (((\map_{\mathit{PTree}\,\alpha}^{\alpha \times \alpha, \alpha \times
      \alpha})_\emptyset\, \mathit{swap})_\alpha\, t')}
:  \Nat^{\alpha} (\alpha + \mathit{PTree}\,(\alpha \times
\alpha))\; \mathit{PTree}\,\alpha
\end{array}\]
respectively. Our calculus can similarly define a
$\mathtt{reverseBush}$ function that reverses the data in a bush. This
function maps, e.g., {\color{red} the bush $?$ to $??$}, and can be
defined as
\[\vdash (\fold^{\mathit{Bush}\,\alpha}_{\onet + \beta \times \phi (\phi \beta)})_\emptyset\, balg
: \Nat^\alpha (\mathit{Bush}\,\alpha)\,(\mathit{Bush}\,\alpha)\]
where
\[\begin{array}{lll}
\vdash \fold_{\onet + \beta \times \phi
  (\phi\beta)}^{\mathit{Bush}\,\alpha} : \Nat^{\emptyset}\, (\Nat^{\alpha}\, 
(\onet + \alpha \times \mathit{Bush}\, (\mathit{Bush}\, \alpha))) \;
(\mathit{Bush}\,\alpha))\; (\Nat^{\alpha} \,(\mathit{Bush}\,\alpha) \;
(\mathit{Bush}\,\alpha))\\
\end{array}\]
and $\mathit{bnil}$, $\mathit{bcons}$, $\tin^{-1}_{\onet + \beta
  \times \phi (\phi\beta)}$, $\mathit{balg}$, and $\mathit{consalg}$
are the terms
\[\begin{array}{l}
\vdash \tin_{\onet + \beta \times \phi (\phi\beta)} \circ (
L_{\alpha}\, x.\, \inl\, x) \; : \; \Nat^{\alpha}\, \onet\;
(\mathit{Bush}\,\alpha)\\ 
\vdash \tin_{\onet + \beta \times \phi (\phi\beta)} \circ (
L_{\alpha}\, x.\, \inr\, x ) \; : \; \Nat^{\alpha}\, (\alpha \times
\mathit{Bush}\,(\mathit{Bush}\,\alpha))\; (\mathit{Bush}\,\alpha)\\[0.05in]
\vdash (\fold_{\onet + \beta \times \phi (\phi\beta)}^{(\onet + \beta
  \times \phi (\phi\beta))[\phi := \mathit{Bush}\,\alpha]})_\emptyset\,
((\map_{\onet + \beta \times \phi (\phi\beta)}^{(\onet + \beta \times
  \phi (\phi\beta))[\phi := \mathit{Bush}\,\alpha][\beta := \alpha],
  \mathit{Bush}\,\alpha})_\emptyset\, \tin_{\onet + \beta \times \phi
  (\phi\beta)})\\[0.05in]
\hspace*{0.2in} : \Nat^{\alpha}\, (\mathit{Bush}\,\alpha)\; (\onet +
\alpha \times \mathit{Bush}\,(\mathit{Bush}\,\alpha))\\ 
  \vdash L_{\alpha} \, s. 
  \cse{s}{* \mapsto \mathit{bnil}_\alpha *}{(a, bba) \mapsto consalg_\alpha (a, bba)}
  : \Nat^\alpha \, (\onet + \alpha \times \mathit{Bush} (\mathit{Bush} \,\alpha)) \, (\mathit{Bush}\,\alpha) \\
  \vdash L_{\alpha} \, (a, bba).  
  \mathsf{case}\, (\ininv{\mathit{Bush}\,\alpha}{bba})\, \mathsf{of}\,\{
  \\
  \hspace{8em}\, * \mapsto \mathit{bcons}_{\alpha} (a,\mathit{bnil}_{\mathit{Bush}\,\alpha} *);  \\
  \hspace{8em} (ba, bbba) \mapsto \mathsf{case}\, (\ininv{\alpha}{ba})
  \, \mathsf{of}\,\{  \\ 
  \hspace{16em}* \mapsto \mathit{bcons}_\alpha (a, \mathit{bcons}_{\mathit{Bush}\,\alpha} 
        (\mathit{bnil}_\alpha *, bbba)) ;  \\ 
  \hspace{16em}(a', bba') \mapsto \mathit{bcons}_\alpha (a', \mathit{bcons}_{\mathit{Bush}\,\alpha}
  (\mathit{bcons}_\alpha (a, bba'), bbba)) \} \! \}\\    
\hspace*{0.2in} : \Nat^\alpha \, (\alpha \times \mathit{Bush} (\mathit{Bush} \,\alpha)) \, (\mathit{Bush}\,\alpha) \\
\end{array}\]
respectively. 

Unfortunately, our calculus cannot express types of recursive
functions --- such as a concatenation function for perfect trees or a
zip function for bushes --- that take as inputs a nested type and an
argument of another type, both of which are parameterized over the
same variable. The fundamental issue is that recursion is expressible
only via $\fold$, which produces natural transformations in some
variables $\ol\alpha$ from $\mu$-types to other functors $F$. The
restrictions on $\Nat$-types entail that $F$ cannot itself be a
$\Nat$-type containing $\ol{\alpha}$, so, e.g., $\Nat^\alpha
(\mathit{PTree}\,\alpha) \,(\Nat^\emptyset (\mathit{PTree}\,\alpha)\,
(\mathit{PTree}\,(\alpha \times \alpha)))$ is not well-typed.
Uncurrying gives $\Nat^\alpha (\mathit{PTree}\,\alpha \times
\mathit{PTree}\,\alpha)\, (\mathit{PTree}\,(\alpha \times \alpha))$,
which is well-typed, but $\mathsf{fold}$ cannot produce a term of this
type because $\mathit{PTree}\,\alpha \times \mathit{PTree}\,\alpha$ is
not a $\mu$-type.  Our calculus can, however, express types of
recursive functions that take multiple nested types as arguments,
provided they are parameterized over disjoint sets of type variables
and the return type of the function is parameterized over only the
variables occurring in the type of its final argument.  Even for ADTs
there is a difference between which folds over them we can type when
they are viewed as ADTs (i.e., as fixpoints of first-order functors)
versus as proper nested types (i.e., as fixpoints of higher-order
functors). This is because, in the return type of $\mathsf{fold}$, the
arguments of the $\mu$-type must be variables bound by $\Nat$.  For
ADTs, the $\mu$-type takes no arguments, making it possible to write
recursive functions, such as a concatenation function for lists of
type $\alpha ; \emptyset \vdash \Nat^\emptyset \ (\mu \beta. \onet +
\alpha \times \beta)\, (\Nat^\emptyset (\mu \beta. \onet + \alpha
\times \beta) \, (\mu \beta. \onet + \alpha \times \beta))$.  This is
not possible for nested types --- even when they are semantically
equivalent to ADTs.

Interestingly, even some recursive functions of a single proper nested
type --- e.g., a reverse function for bushes --- cannot be expressed
as folds because the algebra arguments needed to define them are again
recursive functions with types of the same problematic form as the
type of, e.g., a zip function for perfect trees.  Expressivity of
folds for nested types has long been a vexing issue, and this is
naturally inherited by our calculus.  Adding more expressive recursion
combinators could help, but since this is orthogonal to the issue of
parametricity in the presence of primitive nested types we do not
consider it further here.

{\color{red} Integerate next paragraph into above discussion?} Our
calculus can, however, express types of recursive functions that take
multiple nested types as arguments, provided those nested types are
parameterized over disjoint sets of type variables and the return type
of the function is parameterized over only the variables occurring in
the type of its final argument.  Interestingly, even some recursive
functions of a single proper nested type --- e.g., a
$\mathtt{reverseBush}$ function that is a true involution --- cannot
be expressed as folds because the algebra arguments needed to define
them are again recursive functions
%  cannot be defined. This happens, for
%  example, when the algebra argument to a fold must be a recursive
%  function
%, and thus must itself be defined as a fold
with types of the same problematic forms.
%More sophisticated combinators for stylized recursion (e.g.,
%generalized folds)
%%  ~\cite{bp99})
%don't mitigate these difficulties, either. Indeed, they appear to be a
%fundamental consequence of the interaction of functoriality and
%polymorphism, not just some peculiarity of our particular calculus.
Allowing extra functorial variables in the codomains of $\Nat$-types
would recover typeability of, say, zip for bushes, but such extended
$\Nat$-types need not have semantics as $\omega$-cocontinuous functors
in $\set$, as will be required in Section~\ref{sec:type-interp}. For
example,
%as shown in Example D, Section VI of~\cite{jp19},
the type $\emptyset; \gamma \vdash \Nat^\emptyset\, (\mu \beta. \onet + \beta)\,
\gamma$ has no such semantics. To remedy this, we would need to
construct our models from semantic categories that are locally
$\lambda$-presentable for $\lambda > \omega$.
%It is tempting to try to recover typeability of, say, a zip function
%for bushes by allowing extra functorial variables in the codomain type
%of $\Nat$-types. But such extended $\Nat$-types need not have
%semantics as $\omega$-cocontinuous functors, as is required in
%Section~\ref{sec:type-interp}. For example, as shown in Example D,
%Section VI of~\cite{jp19}, the type $\emptyset; \gamma \vdash
%\Nat^\emptyset (\onet + \onet)\, \gamma$ does not.
%

\section{Interpreting Types}\label{sec:type-interp}

We denote the category of sets and functions by $\set$. The category
$\rel$ has as its objects triples $(A,B,R)$ where $R$ is a relation
between the objects $A$ and $B$ in $\set$, i.e., a subset of $A \times
B$, and has as its morphisms from $(A,B,R)$ to $(A',B',R')$ pairs $(f
: A \to A',g : B \to B')$ of morphisms in $\set$ such that $(f a,g\,b)
\in R'$ whenever $(a,b) \in R$. We write $R : \rel(A,B)$ in place of
$(A,B,R)$ when convenient.  If $R : \rel(A,B)$ we write $\pi_1 R$ and
$\pi_2 R$ for the {\em domain} $A$ of $R$ and the {\em codomain} $B$
of $R$, respectively.  If $A : \set$, then we write $\Eq_A =
(A,A,\{(x,x)~|~ x \in A\})$ for the {\em equality relation} on $A$.

The key idea underlying Reynolds' parametricity is to give each type
$F(\alpha)$ with one free variable $\alpha$ both an {\em object
  interpretation} $F_0$ taking sets to sets and a \emph{relational
  interpretation} $F_1$ taking relations $R : \rel(A,B)$ to relations
$F_1 (R) : \rel(F_0 (A), F_0 (B))$, and to interpret each term
$t(\alpha,x) : F(\alpha)$ with one free term variable $x : G(\alpha)$
as a map $t_0$ associating to each set $A$ a function $t_0(A) : G_0(A)
\to F_0(A)$. These interpretations are to be given inductively on the
structures of $F$ and $t$ in such a way that they imply two
fundamental theorems. The first is an \emph{Identity Extension Lemma},
which states that $F_1(\Eq_A) = \Eq_{F_0(A)}$, and is the essential
property that makes a model relationally parametric rather than just
induced by a logical relation. The second is an \emph{Abstraction
  Theorem}, which states that, for any $R :\rel(A, B)$,
$(t_0(A),t_0(B))$ is a morphism in $\rel$ from
$(G_0(A),G_0(B),G_1(R))$ to $(F_0(A),F_0(B),F_1(R))$. The Identity
Extension Lemma is similar to the Abstraction Theorem except that it
holds for {\em all} elements of a type's interpretation, not just
those that are interpretations of terms. Similar theorems are
expected to hold for types and terms with any number of free
variables.

The key to proving the Identity Extension Lemma in our setting
(Theorem~\ref{thm:iel}) is a familiar ``cutting down'' of the
interpretations of universally quantified types to include only the
``parametric'' elements; the relevant types in our calculus are the
$\Nat$-types.  This cutting down requires, as usual, that the set
interpretations of types (Section~\ref{sec:set-interp}) are defined
simultaneously with their relational interpretations
(Section~\ref{sec:rel-interp}). While the set interpretations are
relatively straightforward, their relation interpretations are less
so, mainly because of the cocontinuity conditions required to ensure
that they are well-defined. We develop these conditions in
Sections~\ref{sec:set-interp} and~\ref{sec:rel-interp}. This separates
our set and relational interpretations in space, but otherwise has no
impact on the fact that they are given by mutual induction.

\subsection{Interpreting Types as Sets}\label{sec:set-interp}

We interpret types in our calculus as $\omega$-cocontinuous functors
on locally finitely presentable categories~\cite{ar94}. Since functor
categories of locally finitely presentable categories are again
locally finitely presentable, this ensures that the fixpoints
interpreting $\mu$-types in $\set$ and $\rel$ exist, and thus that
both the set and relational interpretations of all of the types in
Definition~\ref{def:wftypes} are well-defined~\cite{jp19}. To
bootstrap this process, we interpret type variables as
$\omega$-cocontinuous functors in Definitions~\ref{def:set-env}
and~\ref{def:reln-env}. If $\C$ and $\D$ are locally finitely
presentable categories, we write $[\C,\D]$ for the category of
$\omega$-cocontinuous functors from $\C$ to $\D$.
%Note that the categories $\set$ and $\rel$ are both locally finitely
%presentable.

\begin{dfn}\label{def:set-env}
A {\em set environment} maps each type variable in $\tvars^k \cup
\fvars^k$ to an element of $[\set^k,\set]$.  A morphism $f : \rho \to
\rho'$ for set environments $\rho$ and $\rho'$ with $\rho|_\tvars =
\rho'|_\tvars$ maps each type constructor variable $\psi^k \in \tvars$
to the identity natural transformation on $\rho \psi^k = \rho'\psi^k$
and each functorial variable $\phi^k \in \fvars$ to a natural
transformation from the $k$-ary functor $\rho \phi^k$ on $\set$ to the
$k$-ary functor $\rho' \phi^k$ on $\set$.  Composition of morphisms on
set environments is given componentwise, with the identity morphism
mapping each set environment to itself. This gives a category of set
environments and morphisms between them, which we denote $\setenv$.
\end{dfn}
When convenient we identify a functor in $[\set^0, \set]$ with its
value on $\ast$ and consider a set environment to map a type variable
of arity $0$ to a set.  If $\ol{\alpha} = \{\alpha_1,...,\alpha_k\}$
and $\ol{A} = \{A_1,...,A_k\}$, then we write $\rho[\ol{\alpha := A}]$
for the set environment $\rho'$ such that $\rho' \alpha_i = A_i$ for
$i = 1,...,k$ and $\rho' \alpha = \rho \alpha$ if $\alpha \not \in
\{\alpha_1,...,\alpha_k\}$.  If $\rho$ is a set environment we write
$\Eq_\rho$ for the relation environment (see
Definition~\ref{def:reln-env}) such that $\Eq_\rho v = \Eq_{\rho v}$
for every type variable $v$.

We can now define our set interpretations.  The relational
interpretations appearing in the second clause of
Definition~\ref{def:set-sem} are given in
Definition~\ref{def:rel-sem}.

\begin{dfn}\label{def:set-sem}
{\color{red} Check clause for $\mu$-types.} The {\em set
  interpretation} $\setsem{\cdot} : \F \to [\setenv, \set]$ is defined
by:
\begin{align*}
  \setsem{\Gamma;\Phi \vdash \zerot}\rho &= 0\\
  \setsem{\Gamma;\Phi \vdash \onet}\rho &= 1\\
  \setsem{\Gamma; \emptyset
    \vdash \Nat^{\ol{\alpha}}
    \,F\,G}\rho &= \{\eta : \lambda \ol{A}. \,\setsem{\Gamma;
    \ol{\alpha} \vdash
    F}\rho[\ol{\alpha := A}] 
      \Rightarrow \lambda \ol{A}.\,\setsem{\Gamma; 
        \ol{\alpha} \vdash G}\rho[\ol{\alpha := A}] \\ 
      &\hspace{0.3in}|~\forall \overline{A}, \overline{B} :
      \set. \forall \overline{R : \rel(A, B)}.\\ 
      &\hspace{0.4in}(\eta_{\overline{A}}, \eta_{\overline{B}})
      : \relsem{\Gamma; \ol{\alpha} \vdash F}\Eq_{\rho}[\ol{\alpha := R}]
      \rightarrow \relsem{\Gamma; \ol{\alpha} \vdash
        G}\Eq_{\rho}[\ol{\alpha := R}] \} \\
  \setsem{\Gamma;\Phi \vdash \phi\ol{F}}\rho &=
  (\rho\phi)\,\ol{\setsem{\Gamma;\Phi \vdash
    F}\rho}\\
  \setsem{\Gamma;\Phi \vdash F+G}\rho &=
  \setsem{\Gamma;\Phi \vdash F}\rho +
  \setsem{\Gamma;\Phi \vdash G}\rho\\
  \setsem{\Gamma;\Phi \vdash F\times G}\rho &=
  \setsem{\Gamma;\Phi \vdash F}\rho \times
  \setsem{\Gamma;\Phi \vdash G}\rho\\ 
  \setsem{\Gamma;\Phi,\ol\gamma \vdash (\mu \phi.\lambda
    \ol{\alpha}. H)\ol{G}}\rho &= (\mu
    T^\set_{H,\rho})\ol{\setsem{\Gamma;\Phi,\ol\gamma \vdash G}\rho}\\
    \text{where } T^\set_{H,\rho}\,F & = \lambda
  \ol{A}. \setsem{\Gamma;\ol\gamma,\phi, \ol{\alpha} \vdash
    H}\rho[\phi :=  F][\ol{\alpha := A}]\\
  \text{and } T^\set_{H,\rho}\,\eta &= \lambda
  \ol{A}. \setsem{\Gamma;\ol\gamma,\phi, \ol{\alpha} \vdash
    H}\id_\rho[\phi := \eta][\ol{\alpha := \id_{A}}]
\end{align*}
\end{dfn}
%The interpretations in Definition~\ref{def:set-sem} respect weakening,
%i.e., a type and its weakenings have the same set interpretations.
%
%= \setsem{\Gamma \vdash \sigma} \rho \to
%\setsem{\Gamma \vdash \tau} \rho$, as expected {\color{blue} by IEL}.
If $\rho \in \setenv$ and $\vdash F$ then we write $\setsem{\vdash F}$
instead of $\setsem{\vdash F}\rho$ since the environment is
immaterial. The third clause of Definition~\ref{def:set-sem} does
indeed define a set: local finite presentability of $\set$ and
$\omega$-cocontinuity of $\setsem{\Gamma;\ol{\alpha} \vdash F}\rho$
ensure that $\{\eta : \setsem{\Gamma;\ol{\alpha} \vdash F}\rho
\Rightarrow \setsem{\Gamma;\ol{\alpha} \vdash G}\rho\}$ (which
contains $\setsem{\Gamma;\emptyset \vdash
  \Nat^{\ol{\alpha}}\,F\,G}\rho$) is a subset of
$\big\{({\setsem{\Gamma;\ol{\alpha} \vdash G}\rho[\ol{\alpha :=
      S}]})^{(\setsem{\Gamma;\ol{\alpha} \vdash F}\rho[\ol{\alpha :=
      S}])}~\big|~ \ol{S} = (S_1,...,S_{|\ol{\alpha}|}), \mbox{ and }$
$S_i \mbox{ is a finite set for } i =
1,...,|\ol{\alpha}|\big\}$. There are countably many choices of tuples
$\ol{S}$, each of which gives rise to a morphism from
${\setsem{\Gamma;\ol{\alpha} \vdash F}\rho[ \ol{\alpha := S}]}$ to
${\setsem{\Gamma;\ol{\alpha} \vdash G}\rho[\ol{\alpha := S}]}$, but
only $\set$-many choices of morphisms between any two objects since
$\set$ is locally small. Also, $\setsem{\Gamma; \emptyset \vdash
  \Nat^{\ol\alpha} F\,G}$ is $\omega$-cocontinuous since it is
constant on $\omega$-directed sets. Interpretations of $\Nat$-types
ensure that $\setsem{\Gamma \vdash F \to G}$ and $\setsem{\Gamma
  \vdash \forall \ol\alpha. F}$ are as expected in any parametric
model.

To make sense of the last clause in Definition~\ref{def:set-sem}, we
need to know that, for each $\rho \in \setenv$, $T^\set_{H,\rho}$ is
an $\omega$-cocontinuous endofunctor on $[\set^k, \set]$, and thus
admits a fixpoint.  Since $T_{H,\rho}^\set$ is defined in terms of
$\setsem{\Gamma;\ol\gamma,\phi, \ol{\alpha} \vdash H}$, this means
that interpretations of types must be such functors, which in turn
means that the actions of set interpretations of types on objects and
on morphisms in $\setenv$ are intertwined. Fortunately, we know
from~\cite{jp19} that, for every $\Gamma; \ol{\alpha} \vdash G$,
$\setsem{\Gamma; \ol{\alpha} \vdash G}$ is actually in $[\set^k,\set]$
where $k = |\ol \alpha|$. This means that for each $\setsem{\Gamma;
  \ol\gamma, \phi^k, \ol{\alpha} \vdash H}$, the corresponding
operator $T^\set_{H}$ can be extended to a {\em functor} from
$\setenv$ to $[[\set^k,\set],[\set^k,\set]]$. The action of $T^\set_H$
on an object $\rho \in \setenv$ is given by the higher-order functor
$T_{H,\rho}^\set$, whose actions on objects (functors in $[\set^k,
  \set]$) and morphisms (natural transformations) between them are
given in Definition~\ref{def:set-sem}. Its action on a morphism $f :
\rho \to \rho'$ is the higher-order natural transformation
$T^\set_{H,f} : T^\set_{H,\rho} \to T^\set_{H,\rho'}$ whose action on
$F : [\set^k,\set]$ is the natural transformation $T^\set_{H,f}\, F :
T^\set_{H,\rho}\,F \to T^\set_{H,\rho'}\,F$ whose component at
$\ol{A}$ is $(T^\set_{H,f}\, F)_{\ol{A}} = \setsem{\Gamma;
  \ol\gamma,\phi,\ol{\alpha} \vdash H}f[\phi := \id_F][\ol{\alpha :=
    \id_A}]$.

Using $T^\set_H$, we can define the functorial action of set
interpretation.
\begin{dfn}\label{def:set-sem-funcs}
Let $f: \rho \to \rho'$ be a morphism between set environments $\rho$
and $\rho'$ (so that $\rho|_\tvars = \rho'|_\tvars$). The action
$\setsem{\Gamma;\Phi \vdash F}f$ of\, $\setsem{\Gamma;\Phi \vdash F}$
on $f$ is given by:
\begin{itemize}
\item If \,$\Gamma;\Phi \vdash \zerot$ then $\setsem{\Gamma;\Phi \vdash
  \zerot}f = \id_0$
\item If \,$\Gamma;\Phi \vdash \onet$ then $\setsem{\Gamma;\Phi \vdash
  \onet}f = \id_1$
\item If \,$\Gamma; \emptyset
  \vdash \Nat^{\ol{\alpha}}\,F\,G$ then
  $\setsem{\Gamma; \emptyset
    \vdash \Nat^{\ol{\alpha}}\,F\,G} f =
  \id_{\setsem{\Gamma; \emptyset
      \vdash \Nat^{\ol{\alpha}}\,F\,G}\rho}$
\item If \,$\Gamma;\Phi \vdash \phi \ol{F}$ then
$\setsem{\Gamma;\Phi \vdash \phi \ol{F}} f : \setsem{\Gamma;\Phi
  \vdash \phi \ol{F}}\rho \to \setsem{\Gamma;\Phi \vdash
  \phi\ol{F}}\rho' = (\rho\phi) \ol{\setsem{\Gamma;\Phi \vdash
    F}\rho} \to (\rho'\phi) \ol{\setsem{\Gamma;\Phi \vdash
    F}\rho'}$ is defined by $\setsem{\Gamma;\Phi \vdash \phi
  \ol{F}} f = (f\phi)_{\ol{\setsem{\Gamma;\Phi \vdash
      F}\rho'}}\, \circ\, (\rho\phi) {\ol{\setsem{\Gamma;\Phi
      \vdash F}f}} = (\rho'\phi) {\ol{\setsem{\Gamma;\Phi \vdash
      F}f}}\, \circ\, (f \phi)_{\ol{\setsem{\Gamma;\Phi \vdash
      F}\rho}}$.  The latter equality holds because $\rho\phi$ and
  $\rho'\phi$ are functors and $f\phi : \rho\phi \to \rho'\phi$ is a
  natural transformation, so the following naturality square commutes:
{\footnotesize\begin{equation}\label{eq:cd2}
\begin{CD}
  (\rho\phi) \ol{\setsem{\Gamma;\Phi \vdash F}\rho} @> (f\phi)_{
    \ol{\setsem{\Gamma;\Phi \vdash F}\rho}} >> (\rho'\phi)
  \ol{\setsem{\Gamma;\Phi \vdash F}\rho} \\ @V(\rho\phi)
  \ol{\setsem{\Gamma;\Phi \vdash F}f}VV @V (\rho'\phi)
  \ol{\setsem{\Gamma;\Phi \vdash F}f} VV \\ (\rho\phi)
  \ol{\setsem{\Gamma;\Phi \vdash F}\rho'} @>(f\phi)_{
    \ol{\setsem{\Gamma;\Phi \vdash F}\rho'}}>> (\rho'\phi)
  \ol{\setsem{\Gamma;\Phi \vdash F}\rho'}
\end{CD}
\end{equation}}
\item If\, $\Gamma;\Phi \vdash F + G$ then $\setsem{\Gamma;\Phi
  \vdash F + G}f$ is defined by $\setsem{\Gamma;\Phi \vdash
  F + G}f(\inl\,x) = \inl\,(\setsem{\Gamma;\Phi \vdash
  F}f x)$ and $\setsem{\Gamma;\Phi \vdash F +
  G}f(\inr\,y) = \inr\,(\setsem{\Gamma;\Phi \vdash G}f y)$
\item If \,$\Gamma;\Phi\vdash F \times G$ then
  $\setsem{\Gamma;\Phi \vdash F \times G}f = 
  \setsem{\Gamma;\Phi \vdash F}f \times \setsem{\Gamma;\Phi \vdash
    G}f$
\item If \,$\Gamma;\Phi,\ol\gamma \vdash (\mu \phi.\lambda
  \ol{\alpha}. H)\ol{G}$ then
  \[\begin{array}{lll}
  \setsem{\Gamma;\Phi,\ol\gamma \vdash (\mu  \phi.\lambda
    \ol{\alpha}. H)\ol{G}} f &: &\setsem{\Gamma;\Phi,\ol\gamma 
    \vdash (\mu \phi.\lambda \ol{\alpha}. H)\ol{G}} \rho \to
  \setsem{\Gamma;\Phi,\ol\gamma \vdash (\mu
    \phi.\lambda\ol{\alpha}. H)\ol{G}} \rho'\\
  &= &(\mu
  T^\set_{H,\rho})\ol{\setsem{\Gamma;\Phi,\ol\gamma \vdash G}\rho} \to (\mu
  T^\set_{H,\rho'})\ol{\setsem{\Gamma;\Phi,\ol\gamma \vdash G}\rho'}
  \end{array}\]
  is
  defined by
  \[\begin{array}{ll} & (\mu T^\set_{H,f})\ol{\setsem{\Gamma;\Phi,\ol\gamma \vdash
      G}\rho'} \circ (\mu T^\set_{H,\rho})\ol{\setsem{\Gamma;\Phi,\ol\gamma
      \vdash G}f}\\ = & (\mu T^\set_{H,\rho'})\ol{\setsem{\Gamma;\Phi,\ol\gamma
      \vdash G}f} \circ (\mu T^\set_{H,f})\ol{\setsem{\Gamma;\Phi,\ol\gamma
      \vdash G}\rho}\end{array}\]  The latter equality holds because $\mu
  T^\set_{H,\rho}$ and $\mu T^\set_{H,\rho'}$ are functors and $\mu
  T_{H,f}^\set : \mu T_{H,\rho}^\set \to \mu T_{H,\rho'}^\set$ is a
  natural transformation, so the following naturality square commutes:
{\footnotesize\begin{equation}\label{eq:cd3}
\begin{CD}
 (\mu T^\set_{H,\rho}) \ol{\setsem{\Gamma;\Phi,\ol\gamma \vdash G}\rho} @> (\mu
  T^\set_{H,f})_{\ol{\setsem{\Gamma;\Phi,\ol\gamma \vdash G}\rho}} >> (\mu
  T^\set_{H,\rho'}) \ol{\setsem{\Gamma;\Phi,\ol\gamma \vdash G}\rho} \\ 
 @V(\mu T^\set_{H,\rho}) \ol{\setsem{\Gamma;\Phi,\ol\gamma \vdash G}f}VV @V  (\mu
 T^\set_{H,\rho'}) \ol{\setsem{\Gamma;\Phi,\ol\gamma \vdash G}f} VV \\ 
(\mu T^\set_{H,\rho}) \ol{\setsem{\Gamma;\Phi,\ol\gamma \vdash G}\rho'} @>(\mu
 T^\set_{H,f})_{\ol{\setsem{\Gamma;\Phi,\ol\gamma \vdash G}\rho'}}>> (\mu
 T^\set_{H,\rho'}) \ol{\setsem{\Gamma;\Phi,\ol\gamma \vdash G}\rho'}
\end{CD}
\end{equation}}
\end{itemize}
\end{dfn}

Definitions~\ref{def:set-sem} and~\ref{def:set-sem-funcs} respect
weakening, i.e., ensure that a type and its weakenings have the same
set interpretations.

\subsection{Interpreting Types as Relations}\label{sec:rel-interp}

\begin{dfn}\label{def:rel-transf}
A {\em $k$-ary relation transformer} $F$ is a triple $(F^1, F^2,F^*)$,
where
\begin{itemize}
\item $F^1,F^2 : [\set^k,\set]$ and $F^* : [\rel^k, \rel]$ are
  functors
\item If $R_1:\rel(A_1,B_1),...,R_k:\rel(A_k,B_k)$, then $F^* \ol{R} :
  \rel(F^1 \ol{A}, F^2 \ol{B})$
\item If $(\alpha_1, \beta_1) \in \Homrel(R_1,S_1),..., (\alpha_k,
  \beta_k) \in \Homrel(R_k,S_k)$ then $F^* \ol{(\alpha, \beta)} = (F^1
  \ol{\alpha}, F^2 \ol{\beta})$
\end{itemize}
We define $F\ol{R}$ to be $F^*\overline{R}$ and
$F\overline{(\alpha,\beta)}$ to be $F^*\overline{(\alpha,\beta)}$.
\end{dfn}
The last clause of Definition~\ref{def:rel-transf} expands to: if
$\ol{(a,b) \in R}$ implies $\ol{(\alpha\,a,\beta\,b) \in S}$ then
$(c,d) \in F^*\ol{R}$ implies $(F^1 \ol{\alpha}\,c,F^2 \ol{\beta}\,d)
\in F^*\ol{S}$. When convenient we identify a $0$-ary relation
transformer $(A,B,R)$ with $R : \rel(A,B)$, and write $\pi_1 F$ for
$F^1$ and $\pi_2 F$ for $F^2$. Below we extend these conventions to
relation environments in the obvious ways.

\begin{dfn}
The category $RT_k$ of $k$-ary relation transformers is given by the
following data:
\begin{itemize}
\item An object of $RT_k$ is a relation transformer
\item A morphism $\delta : (G^1,G^2,G^*) \to (H^1,H^2,H^*)$ in $RT_k$
  is a pair of natural transformations $(\delta^1, \delta^2)$, where
  $\delta^1 : G^1 \to H^1$ and $\delta^2 : G^2 \to H^2$, such that,
  for all $\ol{R : \rel(A, B)}$, if $(x, y) \in G^*\ol{R}$ then
  $(\delta^1_{\ol{A}}x, \delta^2_{\ol{B}}y) \in H^*\ol{R}$
\item Identity morphisms and composition are inherited from the
  category of functors on $\set$
\end{itemize}
\end{dfn}

\begin{dfn}\label{def:RT-functor}
An endofunctor $H$ on $RT_k$ is a triple $H = (H^1,H^2,H^*)$, where
\begin{itemize}
\item $H^1$ and $H^2$ are functors from $[\set^k,\set]$ to $[\set^k,\set]$
\item $H^*$ is a functor from $RT_k$ to $[\rel^k,\rel]$
\item For all $\overline{R : \rel(A,B)}$,
  $\pi_1((H^*(\delta^1,\delta^2))_{\overline{R}}) = (H^1
  \delta^1)_{\overline{A}}$ and
  $\pi_2((H^*(\delta^1,\delta^2))_{\overline{R}}) = (H^2
  \delta^2)_{\overline{B}}$
\item The action of $H$ on objects is given by $H\,(F^1,F^2,F^*) =
  (H^1F^1,\,H^2F^2,\,H^*(F^1,F^2,F^*))$
\item The action of $H$ on morphisms is given by
  $H\,(\delta^1,\delta^2) = (H^1\delta^1,H^2\delta^2)$ for
  $(\delta^1,\delta^2) : (F^1,F^2,F^*)\to (G^1,G^2,G^*)$
\end{itemize}
\end{dfn}
Since the results of applying an endofunctor $H$ to $k$-ary relation
transformers and morphisms between them must again be $k$-ary relation
transformers and morphisms between them, respectively,
Definition~\ref{def:RT-functor} implicitly requires that the following
three conditions hold:
\begin{itemize}
\item $H^*(F^1,F^2,F^*) \ol{R} : \rel(H^1F^1 \ol{A}, H^2F^2 \ol{B})$
  whenever $R_1:\rel(A_1,B_1),...,R_k:\rel(A_k,B_k)$
\item $H^*(F^1,F^2,F^*)\, \ol{(\alpha, \beta)} = (H^1F^1\ol{\alpha},
  H^2F^2 \ol{\beta})$ whenever $(\alpha_1, \beta_1) \in
  \Homrel(R_1,S_1),..., (\alpha_k, \beta_k) \in \Homrel(R_k,S_k)$
\item If $(\delta^1,\delta^2) : (F^1,F^2,F^*)\to (G^1,G^2,G^*)$ and
  $R_1:\rel(A_1,B_1),...,R_k:\rel(A_k,B_k)$, then
  $((H^1\delta^1)_{\ol{A}}x, (H^2\delta^2)_{\ol{B}}y) \in
  H^*(G^1,G^2,G^*)\ol{R}$ whenever $(x, y) \in H^*(F^1,F^2,F^*)\ol{R}$
\end{itemize}
  Note, however, that this last condition is
  automatically satisfied because it is implied by the third bullet
  point of Definition~\ref{def:RT-functor}.

\begin{dfn}\label{def:RT-nat-trans}
For endofunctors $H$ and $K$ on $RT_k$, a {\em natural transformation}
$\sigma : H \to K$ is a pair $\sigma = (\sigma^1, \sigma^2)$, where
$\sigma^1 : H^1 \to K^1$ and $\sigma^2 : H^2 \to K^2$ are natural
transformations between endofunctors on $[\set^k,\set]$ and the
component of $\sigma$ at $F = (F^1,F^2,F^*) \in RT_k$ is given by
$\sigma_F = (\sigma^1_{F^1}, \sigma^2_{F^2})$.
\end{dfn}
Definition~\ref{def:RT-nat-trans} entails that $\sigma^i_{F^i}$ is
natural in $F^i : [\set^k,\set]$, and, for every $F$, both
$(\sigma^1_{F^1})_{\overline{A}}$ and
$(\sigma^2_{F^2})_{\overline{A}}$ are natural in $\overline{A}$.
Moreover, since the results of applying $\sigma$ to $k$-ary relation
transformers must be morphisms of $k$-ary relation transformers,
Definition~\ref{def:RT-nat-trans} implicitly requires that
$(\sigma_F)_{\overline{R}} = ( (\sigma^1_{F^1})_{\overline{A}},
(\sigma^2_{F^2})_{\overline{B}})$ is a morphism in $\rel$ for any
$k$-tuple of relations $\overline{R : \rel(A, B)}$, i.e., that if $(x,
y) \in H^*F\overline{R}$, then $((\sigma^1_{F^1})_{\overline{A}} x,
(\sigma^2_{F^2})_{\overline{B}} y) \in K^*F\overline{R}$.

\vspace*{0.1in}
Critically, we can compute $\omega$-directed colimits in
$RT_k$. Indeed, if $\cal D$ is an $\omega$-directed set then
$\colim{d \in {\cal D}}{(F^1_d, F^2_d,F^*_d)} = (\colim{d \in {\cal
    D}}{F^1_d}, \colim{d \in {\cal D}}{F^2_d}, \colim{d \in {\cal
    D}}{F^*_d})$.  We define an endofunctor $T = (T^1,T^2,T^*)$ on
$RT_k$ to be {\em $\omega$-cocontinuous} if $T^1$ and $T^2$ are
$\omega$-cocontinuous endofunctors on $[\set^k,\set]$ and $T^*$ is an
$\omega$-cocontinuous functor from $RT_k$ to $[\rel^k,\rel]$, i.e., is
in $[RT_k,[\rel^k,\rel]]$.
%\begin{lemma}\label{lem:colimits}
%$\colim{d \in {\cal D}}{(F^1_d, F^2_d,F^*_d)} = (\colim{d \in {\cal
%      D}}{F^1_d}, \colim{d \in {\cal D}}{F^2_d}, \colim{d \in {\cal
%      D}}{F^*_d})$
%\end{lemma}
%\begin{proof}
%We first observe that $(\colim{d \in {\cal D}}{F^1_d}, \colim{d \in
%  {\cal D}}{F^2_d}, \colim{d \in {\cal D}}{F^*_d})$ is in $RT_k$.  If
%$R_1:\rel(A_1,B_1),...,R_k:\rel(A_k,B_k)$, then $\colim{d \in \cal
%  D}{F^*_d\ol{R}} : \rel(\colim{d \in {\cal D}}{F^1_d\ol{A}},
%\,\colim{d \in {\cal D}}{F^2_d\ol{B}})$ because of how colimits are
%computed in $\rel$. Moreover, if $(\alpha_1, \beta_1) \in
%\Homrel(R_1,S_1),..., (\alpha_k, \beta_k) \in \Homrel(R_k,S_k)$, then
%\[\begin{array}{ll}
%  & (\colim{d \in \cal D}{F_d^*})\ol{(\alpha,\beta)}\\
%= & \colim{d \in \cal D}{F_d^*\ol{(\alpha,\beta)}}\\
%= & \colim{d \in \cal D}{(F_d^1\ol{\alpha},\, F_d^2\ol{\beta})}\\
%= & (\colim{d \in \cal D}{F^1_d \ol{\alpha}}, \,\colim{d \in \cal D}{
%  F^2_d \ol{\beta}})
%\end{array}\]
%so $(\colim{d \in {\cal D}}{F^1_d}, \colim{d \in {\cal D}}{F^2_d},
%\colim{d \in {\cal D}}{F^*_d})$ actually is in $RT_k$.
%
%Now to see that $\colim{d \in {\cal D}}{(F^1_d, F^2_d,F^*_d)} =
%(\colim{d \in {\cal D}}{F^1_d}, \colim{d \in {\cal D}}{F^2_d},
%\colim{d \in {\cal D}}{F^*_d})$, let $\gamma^1_d : F^1_d \to \colim{d
%  \in {\cal D}}{F^1_d}$ and $\gamma^2_d : F^2_d \to \colim{d \in {\cal
%    D}}{F^2_d}$ be the injections for the colimits $\colim{d \in {\cal
%    D}}{F^1_d}$ and $\colim{d \in {\cal D}}{F^2_d}$,
%respectively. Then $(\gamma^1_d, \gamma^2_d) : (F^1_d, F^2_d,F^*_d)
%\to \colim{d \in {\cal D}}{(F^1_d, F^2_d,F^*_d)}$ is a morphism in
%$RT_k$ because, for all $\ol{R : \rel(A, B)}$,
%$((\gamma^1_d)_{\ol{A}}, (\gamma^2_d)_{\ol{B}}) : F^*_d \ol{R} \to
%\colim{d \in {\cal D}}{F^*_d \ol{R}}$ is a morphism in $\rel$. So
%$\{(\gamma^1_d, \gamma^2_d)\}_{d \in {\cal D}}$ are the mediating
%morphisms of a cocone in $RT_k$ with vertex $\colim{d \in {\cal
%    D}}{(F^1_d, F^2_d,F^*_d)}$. To see that this cocone is a
%colimiting cocone, let $C = (C^1,C^2,C^*)$ be the vertex of a cocone
%for $\{(F^1_d,F^2_d,F^*_d)\}_{d \in {\cal D}}$ with injections
%$(\delta^1_d,\delta^2_d) : (F^1_d,F^2_d,F^*_d) \to C$. If $\eta^1 :
%\colim{d \in {\cal D}}{F^1_d} \to C^1$ and $\eta^2 : \colim{d \in
%  {\cal D}}{F^2_d} \to C^2$ are the mediating morphisms in
%$[\set^k,\set]$, then $\eta^1$ and $\eta^2$ are unique such that
%$\delta^1_d = \eta^1 \circ \gamma^1_d$ and $\delta^2_d = \eta^2 \circ
%\gamma^2_d$.  We therefore have that $(\eta^1,\eta^2) : \colim{d \in
%  {\cal D}}{(F^1_d, F^2_d,F^*_d)} \to C$ is the mediating morphism in
%$RT_k$. Indeed, for all $\ol{R : \rel(A,B)}$ and $(x,y) \in \colim{d
%  \in {\cal D}}{F^*_d \ol{R}}$, there exist $d$ and $(x',y') \in
%F^*_d\ol{R}$ such that $(\gamma^1_d)_{\ol{A}}x' = x$ and
%$(\gamma^2_d)_{\ol{B}}y' = y$. But then $(\eta^1_{\ol{A}}x,
%\eta^2_{\ol{B}}y) = (\eta^1_{\ol{A}}((\gamma^1_d)_{\ol{A}}x'),
%\eta^2_{\ol{B}}((\gamma^2_d)_{\ol{B}}y')) = ((\delta^1_d)_{\ol{A}}x',
%(\delta^2_d)_{\ol{B}}y')$, and this pair is in $C^*\ol{R}$ because
%$(\delta^1_d, \delta^2_d)$ is a morphism from $(F^1_d,F^2_d,F^*_d)$ to
%$C$ in $RT_k$.
%\end{proof}
\begin{comment}
\begin{dfn}\label{def:omega-cocont}
An endofunctor $T = (T^1,T^2,T^*)$ on $RT_k$ is {\em
$\omega$-cocontinuous} if $T^1$ and $T^2$ are $\omega$-cocontinuous
endofunctors on $[\set^k,\set]$ and $T^*$ is an $\omega$-cocontinuous
functor from $RT_k$ to $[\rel^k,\rel]$, i.e., is in
$[RT_k,[\rel^k,\rel]]$.
\end{dfn}
\end{comment}
Now, for any $k$, any $A : \set$, and any $R : \rel(A, B)$, let
$K^\set_A$ be the constantly $A$-valued functor from $\set^k$ to
$\set$ and $K^\rel_R$ be the constantly $R$-valued functor from
$\rel^k$ to $\rel$.  Also let $0$ denote either the initial object of
either $\set$ or $\rel$, as appropriate.  Observing that, for every
$k$, $K^\set_0$ is initial in $[\set^k,\set]$, and $K^\rel_0$ is
initial in $[\rel^k,\rel]$, we have that, for each $k$, $K_0 =
(K^\set_0,K^\set_0,K^\rel_0)$ is initial in $RT_k$. Thus, if $T =
(T^1,T^2,T^*) : RT_k \to RT_k$ is an endofunctor on $RT_k$ then we can
define the relation transformer $\mu T$ to be $\colim{n \in \nat}{T^n
  K_0}$. It is not hard to see that $\mu T$ is given explicitly as
\begin{equation}\label{eq:mu}
\mu T = (\mu T^1,\mu T^2, \colim{n \in \nat}{(T^nK_0)^*})
\end{equation}
Moreover, $\mu T$ really is a fixpoint for $T$ if $T$ is
$\omega$-cocontinuous:
\begin{lemma}\label{lem:fp}
For any $T : [RT_k,RT_k]$, $\mu T \cong T(\mu T)$.
\end{lemma}
\noindent
The isomorphism is given by the morphisms $(\mathit{in}_1,
\mathit{in}_2) : T(\mu T) \to \mu T$ and $(in_1^{-1}, in_2^{-1}) : \mu
T \to T(\mu T)$ in $RT_k$. The latter is always a morphism in $RT_k$,
but the former need not be if $T$ is not $\omega$-cocontinuous.

It is worth noting that the third component in Equation~(\ref{eq:mu})
is the colimit in $[\rel^k,\rel]$ of third components of relation
transformers, rather than a fixpoint of an endofunctor on
$[\rel^k,\rel]$. There is thus an asymmetry between the first two
components of $\mu T$ and its third component, which reflects the
important conceptual observation that the third component of an
endofunctor on $RT_k$ need not be a functor on all of
$[\rel^k,\rel]$. {\color{red} KEEP? In particular, although we can
  define $T_{H,\rho}\, F$ for a relation transformer $F$ in
  Definition~\ref{def:rel-sem} below, it is not clear how we could
  define it for an arbitrary $F : [\rel^k,\rel]$. This observation
  will also be critical in Section~\ref{sec:GADTs}.}

\begin{dfn}\label{def:reln-env}
A {\em relation environment} maps each type variable in $\tvars^k \cup
\fvars^k$ to a $k$-ary relation transformer.  A morphism $f : \rho \to
\rho'$ between relation environments $\rho$ and $\rho'$ with
$\rho|_\tvars = \rho'|_\tvars$ maps each type constructor variable
$\psi^k \in \tvars$ to the identity morphism on $\rho \psi^k = \rho'
\psi^k$ and each functorial variable $\phi^k \in \fvars$ to a morphism
from the $k$-ary relation transformer $\rho \phi$ to the $k$-ary
relation transformer $\rho' \phi$. Composition of morphisms on
relation environments is given componentwise, with the identity
morphism mapping each relation environment to itself. This gives a
category of relation environments and morphisms between them, which we
denote $\relenv$.
\end{dfn}
We identify a $0$-ary relation transformer with the relation
(transformer) that is its codomain and consider a relation environment
to map a type variable of arity $0$ to a relation.  We write
$\rho[\ol{\alpha := R}]$ for the relation environment $\rho'$ such
that $\rho' \alpha_i \, = R_i$ for $i = 1,...,k$ and $\rho' \alpha =
\rho\alpha$ if $\alpha \not \in \{\alpha_1,...,\alpha_k\}$.  If $\rho$
is a relation environment, we write $\pi_1 \rho$ and $\pi_2 \rho$ for
the set environments mapping each type variable $\phi$ to the functors
$(\rho\phi)^1$ and $(\rho\phi)^2$, respectively.

\begin{dfn}\label{def:relenv-functor}
For each $k$, an $\omega$-cocontinuous functor $H : [\relenv, RT_k]$
is a triple $H = (H^1,H^2,H^*)$, where
\begin{itemize}
\item $H^1$ and $H^2$ are objects in $[\setenv,[\set^k,\set]]$
\item $H^*$ is a an object in $[\relenv,[\rel^k,\rel]]$
\item For all $\overline{R : \rel(A,B)}$ and morphisms $f$ in
  $\relenv$, $\pi_1(H^*f \,{\overline{R}}) = H^1 (\pi_1
  f)\,{\overline{A}}$ and $\pi_2(H^*f \,{\overline{R}}) = H^2 (\pi_2
  f)\,{\overline{B}}$
\item The action of $H$ on $\rho$ in $\relenv$ is given by $H \rho = (H^1
  (\pi_1 \rho),\,H^2 (\pi_2 \rho),\,H^*\rho)$
\item The action of $H$ on morphisms $f : \rho \to \rho'$ in $\relenv$
  is given by $Hf = (H^1 (\pi_1 f),H^2 (\pi_2 f))$
\end{itemize}
\end{dfn}
\noindent Spelling out the last two bullet points above gives the
following analogues of the three conditions immediately following
Definition~\ref{def:RT-functor}:
\begin{itemize}
\item $H^*\rho\, \ol{R} : \rel(H^1(\pi_1 \rho)\, \ol{A}, H^2(\pi_2
  \rho)\, \ol{B})$ whenever $R_1 : \rel(A_1,B_1),...,R_k :
  \rel(A_k,B_k)$
\item $H^*\rho\, \ol{(\alpha, \beta)} = (H^1(\pi_1 \rho)\,\ol{\alpha},
  H^2(\pi_2 \rho)\, \ol{\beta})$ whenever $(\alpha_1, \beta_1) \in
  \Homrel(R_1,S_1),..., (\alpha_k, \beta_k) \in \Homrel(R_k,S_k)$
\item If $f : \rho \to \rho'$ and
  $R_1:\rel(A_1,B_1),...,R_k:\rel(A_k,B_k)$, then $(H^1(\pi_1
  f)\,{\ol{A}}\,x, H^2(\pi_2 f)\,{\ol{B}}\,y) \in H^*\rho'\,\ol{R}$
  whenever $(x, y) \in H^*\rho\,\ol{R}$.
\end{itemize}
As before, the last condition is automatically satisfied because it is
implied by the third bullet point of
Definition~\ref{def:relenv-functor}.

Considering $\relenv$ as a product $\Pi_{\phi^k \in \tvars \cup
  \fvars} RT_k$, computation of $\omega$-directed colimits in $RT_k$
extends componentwise to $\relenv$. Similarly, $\omega$-cocontinuity
for endofunctors on $RT_k$ extends componentwise to functors from
$\relenv$ to $RT_k$.  Recalling from the start of this subsection that
Definition~\ref{def:rel-sem} is given mutually inductively with
Definition~\ref{def:set-sem} we can now define our relational
interpretations.

\begin{dfn}\label{def:rel-sem}
The {\em relational interpretation} $\relsem{\cdot} : \F \to [\relenv,
 \rel]$ is defined by
\begin{align*}
  \relsem{\Gamma;\Phi \vdash \zerot}\rho &= 0\\
  \relsem{\Gamma;\Phi \vdash \onet}\rho &= 1\\
  \end{align*}

\vspace*{-0.5in}

\begin{align*}
  \relsem{\Gamma; \emptyset \vdash \Nat^{\ol{\alpha}} \,F\,G}\rho &= \{\eta
  : \lambda \ol{R}.\,\relsem{\Gamma; \ol{\alpha} \vdash
    F}\rho[\ol{\alpha := R}] \Rightarrow \lambda \ol{R}. \,\relsem{
    \Gamma; \ol{\alpha} \vdash G}\rho[\ol{\alpha := R}]\}\\
  &=
  \{(t,t') \in \setsem{\Gamma; \emptyset
    \vdash \Nat^{\ol{\alpha}}
    \,F\,G} (\pi_1 \rho) \times \setsem{ 
    \Gamma;\emptyset
    \vdash \Nat^{\ol{\alpha}} \,F\,G} (\pi_2
  \rho)~|~\\ 
  & \hspace{0.3in} \forall {R_1 : \rel(A_1,B_1)}\,...\,{R_k : \rel(A_k,B_k)}.\\
  & \hspace{0.4in} (t_{\ol{A}},t'_{\ol{B}}) \in
  (\relsem{\Gamma; \ol{\alpha} \vdash G}\rho[\ol{\alpha :=
      R}])^{\relsem{\Gamma;\ol{\alpha}\vdash F}\rho[\ol{\alpha := R}]} \}\\  
  \relsem{\Gamma;\Phi \vdash \phi \ol{F}}\rho &=
  (\rho\phi)\ol{\relsem{\Gamma;\Phi \vdash 
    F}\rho}\\
  \relsem{\Gamma;\Phi \vdash F+G}\rho &=
  \relsem{\Gamma;\Phi \vdash F}\rho +
  \relsem{\Gamma;\Phi \vdash G}\rho\\
  \relsem{\Gamma;\Phi \vdash F\times G}\rho &=
  \relsem{\Gamma;\Phi \vdash F}\rho \times
  \relsem{\Gamma;\Phi \vdash G}\rho\\  
   \relsem{\Gamma;\Phi,\ol\gamma \vdash (\mu \phi.\lambda
    \ol{\alpha}. H)\ol{G}}\rho
  &= (\mu T_{H,\rho})\ol{\relsem{\Gamma;\Phi,\ol\gamma \vdash
     G}\rho}\\
  \text{where }	T_{H,\rho}
    &= (T^\set_{H,\pi_1\rho}, T^\set_{H,\pi_2\rho}, T^\rel_{H,\rho}) \\
  \text{and } T^\rel_{H,\rho}\,F
    &= \lambda \ol{R}. \relsem{
      \Gamma;\ol\gamma,\phi,\ol{\alpha} \vdash H}\rho[\phi :=
    F][\ol{\alpha := R}]\\
  \text{and } T^\rel_{H,\rho}\,\delta
    &= \lambda \ol{R}. \relsem{
      \Gamma;\ol\gamma,\phi,\ol{\alpha} \vdash H}\id_\rho[\phi :=
    \delta][\ol{\alpha := \id_{\ol{R}}}]
\end{align*}
\end{dfn}

The interpretations in Definitions~\ref{def:rel-sem}
and~\ref{def:rel-sem-funcs} below respect weakening, and also ensure
that $\relsem{\Gamma \vdash F \to G}$ and $\relsem{\Gamma \vdash
  \forall \ol \alpha. F}$ are as expected in any parametric model.  As
for set interpretations, $\relsem{\Gamma; \emptyset \vdash
  \Nat^{\ol\alpha} F\,G}$ is $\omega$-cocontinuous because it is
constant on $\omega$-directed sets. If $\rho \in \relenv$ and $\vdash
F$, then we write $\relsem{\vdash F}$ instead of $\relsem{\vdash
  F}\rho$.  For the last clause in Definition~\ref{def:rel-sem} to be
well-defined we need $T_{H,\rho}$ to be an $\omega$-cocontinuous
endofunctor on $RT$ so that, by Lemma~\ref{lem:fp}, it admits a
fixpoint. Since $T_{H,\rho}$ is defined in terms of
$\relsem{\Gamma;\ol\gamma,\phi^k, \ol{\alpha} \vdash H}$, this means
that relational interpretations of types must be $\omega$-cocontinuous
functors from $\relenv$ to $RT_0$, which in turn entails that the
actions of relational interpretations of types on objects and on
morphisms in $\relenv$ are intertwined. As for set interpretations, we
know from~\cite{jp19} that, for every $\Gamma; \ol{\alpha} \vdash F$,
$\relsem{\Gamma; \ol{\alpha} \vdash F}$ is actually in $[\rel^k,\rel]$
where $k = |\ol \alpha|$. We first define the actions of each of these
functors on morphisms between environments, and then argue that they
are well-defined and have the required properties. To do this, we
extend $T_H$ to a {\em functor} from $\relenv$ to
$[[\rel^k,\rel],[\rel^k,\rel]]$. Its action on an object $\rho \in
\relenv$ is given by the higher-order functor $T_{H,\rho}$ whose
actions on objects and morphisms are given in
Definition~\ref{def:rel-sem-funcs}. Its action on a morphism $f : \rho
\to \rho'$ is the higher-order natural transformation $T_{H,f} :
T_{H,\rho} \to T_{H,\rho'}$ whose action on any $F : [\rel^k,\rel]$ is
the natural transformation $T_{H,f}\, F : T_{H,\rho}\, F \to
T_{H,\rho'}\, F$ whose component at $\ol{R}$ is $(T_{H,f}\,
F)_{\ol{R}} = \relsem{\Gamma; \ol\gamma,\phi,\ol{\alpha} \vdash
  H}f[\phi := \id_F][\ol{\alpha := \id_R}]$.

Using $T_H$, we can define the functorial action of relational
interpretation.
\begin{dfn}\label{def:rel-sem-funcs}
Let $f: \rho \to \rho'$ for relation environments $\rho$ and $\rho'$
(so that $\rho|_\tvars = \rho'|_\tvars$). The action
$\relsem{\Gamma;\Phi \vdash F}f$ of $\relsem{\Gamma;\Phi \vdash F}$ on
the morphism $f$ is given exactly as in
Definition~\ref{def:set-sem-funcs}, except that all interpretations
are relational interpretations and all occurrences of $T^\set_{H,f}$
are replaced by $T_{H,f}$.
\begin{comment}
as follows:
\begin{itemize}
\item If \,$\Gamma;\Phi \vdash \zerot$ then $\relsem{\Gamma;\Phi \vdash
  \zerot}f = \id_0$
\item If\, $\Gamma;\Phi \vdash \onet$ then $\relsem{\Gamma;\Phi \vdash
  \onet}f = \id_1$
\item If \,$\Gamma; \Phi
  \vdash \Nat^{\ol{\alpha}}\,F\,G$ then
  $\relsem{\Gamma; \Phi
    \vdash \Nat^{\ol{\alpha}}\,F\,G} f =$\\
\hspace*{0.2in} $\lambda t : \relsem{\Gamma;\Phi \vdash
    \Nat^{\ol{\alpha}}\,F\,G}\rho.\, 
  (\lambda \ol{A}. \relsem{\Gamma; \Phi,\ol\alpha \vdash G}f[\ol{\alpha
      := id_A}]) \circ t$  
\item If \,$\Gamma;\Phi \vdash \phi \ol{\tau}$, then
  $\relsem{\Gamma;\Phi \vdash \phi \ol{\tau}} f : \relsem{\Gamma;\Phi
  \vdash \phi \ol{\tau}}\rho \to \relsem{\Gamma;\Phi \vdash \phi
  \ol{\tau}}\rho' = (\rho\phi) \ol{\relsem{\Gamma;\Phi \vdash
    \tau}\rho} \to (\rho'\phi) \ol{\relsem{\Gamma;\Phi \vdash
    \tau}\rho'}$ is defined by $\relsem{\Gamma;\Phi \vdash \phi
  \tau{A}} f = (f\phi)_{\ol{\relsem{\Gamma;\Phi \vdash \tau}\rho'}}
  \,\circ\, (\rho\phi) \ol{\relsem{\Gamma;\Phi \vdash \tau}f} =
  (\rho'\phi) \ol{\relsem{\Gamma;\Phi \vdash \tau}f} \,\circ\, (f
  \phi)_{\ol{\relsem{\Gamma;\Phi \vdash \tau}\rho}}$
\item If\, $\Gamma;\Phi\vdash \sigma + \tau$ then $\relsem{\Gamma;\Phi
  \vdash \sigma + \tau}f$ is defined by $\relsem{\Gamma;\Phi \vdash
  \sigma + \tau}f(\inl\,x) = \inl\,(\relsem{\Gamma;\Phi \vdash
  \sigma}f x)$ and $\relsem{\Gamma;\Phi \vdash \sigma +
  \tau}f(\inr\,y) = \inr\,(\relsem{\Gamma;\Phi \vdash \tau}f y)$
\item If\, $\Gamma;\Phi\vdash \sigma \times \tau$ then
  $\relsem{\Gamma;\Phi \vdash \sigma \times \tau}f =
  \relsem{\Gamma;\Phi \vdash \sigma}f \times \relsem{\Gamma;\Phi
    \vdash \tau}f$
\item If\, $\Gamma;\Phi \vdash (\mu \phi^k.\lambda
  \ol{\alpha}. H)\ol{\tau}$ then $\relsem{\Gamma;\Phi \vdash (\mu
    \phi.\lambda \ol{\alpha}. H)\ol{\tau}} f = (\mu
  T_{H,f})\ol{\relsem{\Gamma;\Phi \vdash \tau}\rho'} \circ (\mu
  T_{H,\rho})\ol{\relsem{\Gamma;\Phi \vdash \tau}f} = (\mu
  T_{H,\rho'})\ol{\relsem{\Gamma;\Phi \vdash \tau}f} \circ (\mu
  T_{H,f})\ol{\relsem{\Gamma;\Phi \vdash \tau}\rho}$
\end{itemize}
\end{comment}
\end{dfn}

For the functors given in Definitions~\ref{def:rel-sem}
and~\ref{def:rel-sem-funcs} to be well-defined we need that, for every
$H$, $T_{H,\rho}\,F$ is a relation transformer for any relation
transformer $F$, and that $T_{H,f}\, F : T_{H,\rho}\, F \to
T_{H,\rho'}\, F$ is a morphism of relation transformers for every
relation transformer $F$ and every morphism $f : \rho \to \rho'$ in
$\relenv$. This is an immediate consequence of
\begin{lemma}\label{lem:rel-transf-morph}
For every $\Gamma;\Phi \vdash F$,
\[\sem{\Gamma;\Phi \vdash F} = (\setsem{\Gamma;\Phi \vdash F},
\setsem{\Gamma;\Phi \vdash F},\relsem{\Gamma;\Phi \vdash F})
\in[\relenv,RT_0]\] 
\end{lemma}
\noindent
The proof is a straightforward induction on the structure of $F$,
using an appropriate result from~\cite{jp19} to deduce
$\omega$-cocontinuity of $\sem{\Gamma;\Phi \vdash F}$ in each case,
{\color{red} KEEP? together with Lemma~\ref{lem:fp} and
  Equation~\ref{eq:mu} for $\mu$-types.}

We can prove by simultaneous induction that our interpretations of
types interact well with demotion of functorial variables to
non-functorial ones, along with other useful identities. Indeed, if
$\rho, \rho' : \setenv$, \,$f : \rho \to \rho'$, \,$\rho \phi = \rho
\psi = \rho' \phi = \rho' \psi$, \, $f \phi = f \psi = \id_{\rho
  \phi}$,\, $\Gamma; \Phi, \phi^k \vdash F$,\,
$\Gamma;\Phi,\ol{\alpha} \vdash G$,\, $\Gamma;\Phi,\alpha_1...\alpha_k
\vdash H$, and $\ol{\Gamma;\Phi \vdash K}$, then
\begin{gather}
\label{thm:demotion-objects}
\setsem{\Gamma; \Phi, \phi \vdash F} \rho = \setsem{\Gamma, \psi; \Phi
  \vdash F[\phi :== \psi] } \rho\\
\label{thm:demotion-morphisms}
\setsem{\Gamma; \Phi, \phi \vdash F} f = \setsem{\Gamma, \psi; \Phi
  \vdash F[\phi :== \psi]} f\\
\label{eq:subs-var}
\setsem{\Gamma;\Phi \vdash G[\ol{\alpha := K}]}\rho =
\setsem{\Gamma;\Phi,\ol{\alpha} \vdash G}\rho[\ol{\alpha := 
\setsem{\Gamma;\Phi \vdash K}\rho}]\\
\label{eq:subs-var-morph}
\setsem{\Gamma;\Phi \vdash G[\ol{\alpha := K}]}f =
\setsem{\Gamma;\Phi,\ol{\alpha} \vdash G}f[\ol{\alpha :=
\setsem{\Gamma;\Phi \vdash K}f}]\\
\label{eq:subs-const}
\setsem{\Gamma; \Phi \vdash F[\phi := H]}\rho
= \setsem{\Gamma; \Phi, \phi \vdash F}\rho
[\phi := \lambda \ol{A}.\, \setsem{\Gamma;\Phi,\overline{\alpha}\vdash
    H}\rho[\overline{\alpha := A}]] \\ 
\label{eq:subs-const-morph}
\setsem{\Gamma; \Phi \vdash F[\phi := H]}f
= \setsem{\Gamma; \Phi, \phi \vdash F}f
[\phi := \lambda \ol{A}.\,\setsem{\Gamma;\Phi,\overline{\alpha}\vdash
    H}f[\overline{\alpha := \id_{\ol{A}}}]] 
\end{gather}
Identities analogous to (\ref{thm:demotion-objects}) through
(\ref{eq:subs-const-morph}) hold for relational interpretations as well.

\section{The Identity Extension Lemma}\label{sec:iel}

In most treatments of parametricity, equality relations on sets are
taken as {\em given} --- either directly as diagonal relations, or
perhaps via reflexive graphs if kinds are also being tracked --- and
the graph relations used to validate existence of initial algebras are
defined in terms of them. We take a different approach here, giving a
categorical definition of graph relations for morphisms (i.e., natural
transformations) between functors and {\em constructing} equality
relations as particular graph relations. Our definitions specialize to
the usual ones for the graph relation for morphisms between sets and
equality relations on sets. In light of its novelty, we spell out
our construction in detail.

The standard definition of the graph for a morphism $f : A \to B$ in
$\set$ is the relation $\graph{f} : \rel(A,B)$ defined by $(x,y) \in
\graph{f}$ iff $fx = y$. This definition naturally generalizes to
associate to each natural transformation between $k$-ary functors on
$\set$ a $k$-ary relation transformer as follows:

\begin{dfn}\label{dfn:graph-nat-transf}
If $F, G: \Set^k \to \Set$ and $\alpha : F \to G$ is a natural
transformation, then the functor $\graph{\alpha}^*: \rel^k \to \rel$
is defined as follows. Given $R_1 : \rel(A_1, B_1),...,R_k :
\rel(A_k,B_k)$, let $\iota_{R_i} : R_i \hookrightarrow A_i \times
B_i$, for $i = 1,...,k$, be the inclusion of $R_i$ as a subset of $A_i
\times B_i$,
%. By the universal property of the product, there exists a
let $h_{\overline{A \times B}}$ be the unique morphism making the diagram
{\footnotesize\[\begin{tikzcd}[row sep = large]
        F\overline{A}
        &F(\overline{A \times B})
        \ar[l, "{F\overline{\pi_1}}"']
        \ar[r, "{F\overline{\pi_2}}"]
        \ar[d, dashed, "{h_{\overline{A \times B}}}"]
        &F\overline{B}
        \ar[r, "{\alpha_{\ol{B}}}"]
        &G\overline{B} \\
        &F\overline{A} \times G\overline{B}
        \ar[ul, "{\pi_1}"] \ar[urr, "{\pi_2}"']
\end{tikzcd}\]}

\noindent
commute, and let $h_{\overline{R}} : F\overline{R} \to F\overline{A}
\times G\overline{B}$ be $h_{\overline{A \times B}} \circ
F\overline{\iota_R}$. Further, let $\alpha^\wedge\overline{R}$ be the
subobject through which $h_{\overline{R}}$ is factorized by the
mono-epi factorization system in $\set$, as shown in the
following diagram:
{\footnotesize\[\begin{tikzcd}
        F\overline{R}
        \ar[rr, "{h_{\overline{R}}}"]
        \ar[dr, twoheadrightarrow, "{q_{\alpha^\wedge\overline{R}}}"']
        &&F\overline{A} \times G\overline{B} \\
        &\alpha^\wedge\overline{R}
        \ar[ur, hookrightarrow, "{\iota_{\alpha^\wedge\overline{R}}}"']
\end{tikzcd}\]}

\noindent
Then $\alpha^\wedge\overline{R} : \rel(F\overline{A}, G\overline{B})$
by construction, so the action of $\langle \alpha \rangle^*$ on
objects can be given by $\langle \alpha \rangle^* \overline{(A,B,R)} =
(F\overline{A}, G\overline{B}, \iota_{\alpha^\wedge
  \overline{R}}\alpha^\wedge\overline{R})$. Its action on morphisms is
given by $\graph{\alpha}^*\overline{(\beta, \beta')} =
(F\overline\beta, G\overline\beta')$.
\end{dfn}

The data in Definition~\ref{dfn:graph-nat-transf} yield the {\em graph
  relation transformer for $\alpha$}, denoted $\graph{\alpha} = (F, G,
\graph{\alpha}^*)$.

\begin{lemma}\label{lem:graph-reln-functors}
If $F,G : [\set^k,\set]$, and if $\alpha : F \to G$ is a natural
transformation, then $\graph{\alpha}$ is in $RT_k$.
\end{lemma}
\begin{proof}
Clearly, $\graph{\alpha}^*$ is $\omega$-cocontinuous, so
$\graph{\alpha}^* : [\rel^k,\rel]$. Now, let $\overline{R :
  \rel(A, B)}$, $\overline{S : \rel(C, D)}$, and $\overline{(\beta,
  \beta') : R \to S}$. We want to show that there exists a morphism
$\epsilon : \alpha^\wedge\overline{R} \to \alpha^\wedge\overline{S}$
such that the diagram on the left below commutes. Since
$\ol{(\beta,\beta') : R \to S}$, there exist $\overline{\gamma : R \to
  S}$ such that each diagram in the middle commutes.
Moreover, since both $h_{\overline{C \times D}} \circ
F(\overline{\beta \times \beta'})$ and $(F\overline{\beta} \times
G\overline{\beta'}) \circ h_{\overline{A \times B}}$ make the diagram
on the right commute, they must be equal.
\begin{figure*}[ht]
\vspace*{-0.1in}
  \hspace*{-0.85in}
  \begin{minipage}[b]{0.25\linewidth}
 {\small    \[
    \begin{tikzcd}
        \alpha^\wedge\overline{R}
        \ar[r, hookrightarrow, "{\iota_{\alpha^\wedge\overline{R}}}"]
        \ar[d, "{\epsilon}"']
        & F\overline{A} \times G\overline{B}
        \ar[d, "{F\overline{\beta} \times G\overline{\beta'}}"] \\
        \alpha^\wedge\overline{S}
        \ar[r, hookrightarrow, "{\iota_{\alpha^\wedge\overline{S}}}"']
        & F\overline{C} \times G\overline{D}
    \end{tikzcd}
    \]}
\end{minipage}
\begin{minipage}[b]{0.25\linewidth}
{\small    \[
    \begin{tikzcd}
        R_i
        \ar[d, "{\gamma_i}"']
        \ar[r, hookrightarrow, "{\iota_{R_i}}"]
        &A_i \times B_i
        \ar[d, "{\beta_i \times \beta'_i}"] \\
        S_i
        \ar[r, hookrightarrow, "{\iota_{S_i}}"]
        &C_i \times D_i
    \end{tikzcd}
    \]}
\end{minipage}
\begin{minipage}[b]{0.25\linewidth}
{\footnotesize \[
      \begin{tikzcd}[row sep = large]
          F\overline{C}
          &F\overline{C} \times F\overline{D}
          \ar[l, "{\pi_1}"'] \ar[r, "{\pi_2}"]
          &F\overline{D}
          \ar[r, "{\alpha_{\ol{D}}}"]
          &G\overline{D}\\
          &F(\overline{A \times B})
          \ar[u, dashed, "{\exists !}"]
          \ar[ul, "{F\ol{\pi_1} \circ F(\overline{\beta \times \beta'})}"]
          \ar[urr, "{\alpha_{\ol{D}} \circ F\ol{\pi_2} \circ F(\overline{\beta \times \beta'})}"']
      \end{tikzcd}
      \]}
\end{minipage}
\end{figure*}

\vspace*{-0.1in}

\noindent
We therefore get that the right-hand square in the diagram on the left
below commutes, and thus that the entire diagram does as well.
Finally, by the left-lifting property of $q_{F^\wedge\overline{R}}$
with respect to $\iota_{F^\wedge\overline{S}}$ given by the mono-epi
factorization system, there exists an $\epsilon$ such that the diagram
on the right below commutes as desired.
\begin{figure*}[ht]
  \vspace*{-0.1in}
  \hspace*{-0.5in}
  \begin{minipage}[b]{0.45\linewidth}
{\footnotesize \[
      \begin{tikzcd}
          F\overline{R}
          \ar[d, "{F\overline{\gamma}}"']
          \ar[r, hookrightarrow, "{F\overline{\iota_R}}"]
          \ar[rr, bend left, "{h_{\overline{R}}}"]
          &F(\overline{A \times B})
          \ar[d, "{F(\overline{\beta \times \beta'})}"]
          \ar[r, "{h_{\overline{A \times B}}}"]
          &F\overline{A} \times G\overline{B}
          \ar[d, "{F\overline{\beta} \times F\overline{\beta'}}"] \\
          F\overline{S}
          \ar[r, hookrightarrow, "{F\overline{\iota_S}}"']
          \ar[rr, bend right, "{h_{\overline{S}}}"']
          &F(\overline{C \times D})
          \ar[r, "{h_{\overline{C \times D}}}"']
          &F\overline{C} \times G\overline{D}
      \end{tikzcd}
      \]}
\end{minipage}
  \vspace*{-0.5in}
  \begin{minipage}[b]{0.45\linewidth}
      {\footnotesize
        \[  \vspace*{0.4in}
      \begin{tikzcd}
          F\overline{R}
          \ar[d, "{F\overline{\gamma}}"']
          \ar[r, twoheadrightarrow, "{q_{\alpha^\wedge\overline{R}}}"]
          &\alpha^\wedge\overline{R}
          \ar[d, dashed, "{\epsilon}"]
          \ar[r, hookrightarrow, "{\iota_{\alpha^\wedge\overline{R}}}"]
          &F\overline{A} \times G\overline{B}
          \ar[d, "{F\overline{\beta} \times G\overline{\beta'}}"] \\
          F\overline{S}
          \ar[r, twoheadrightarrow, "{q_{\alpha^\wedge\overline{S}}}"']
          &\alpha^\wedge\overline{S}
          \ar[r, hookrightarrow, "{\iota_{\alpha^\wedge\overline{S}}}"']
          &F\overline{C} \times G\overline{D}
      \end{tikzcd}
      \]}
\end{minipage}
\end{figure*}


\begin{comment}

Finally, by the left-lifting property of $q_{F^\wedge\overline{R}}$
      with respect to $\iota_{F^\wedge\overline{S}}$ given by the mono-epi
      factorization system, there exists an $\epsilon$ such that the
      following diagram commutes:
      {\footnotesize
        \[
      \begin{tikzcd}
          F\overline{R}
          \ar[d, "{F\overline{\gamma}}"']
          \ar[r, twoheadrightarrow, "{q_{\alpha^\wedge\overline{R}}}"]
          &\alpha^\wedge\overline{R}
          \ar[d, dashed, "{\epsilon}"]
          \ar[r, hookrightarrow, "{\iota_{\alpha^\wedge\overline{R}}}"]
          &F\overline{A} \times G\overline{B}
          \ar[d, "{F\overline{\beta} \times G\overline{\beta'}}"] \\
          F\overline{S}
          \ar[r, twoheadrightarrow, "{q_{\alpha^\wedge\overline{S}}}"']
          &\alpha^\wedge\overline{S}
          \ar[r, hookrightarrow, "{\iota_{\alpha^\wedge\overline{S}}}"']
          &F\overline{C} \times G\overline{D}
      \end{tikzcd}
      \]}

      \vspace*{-0.1in}
\end{comment}
\end{proof}

\vspace*{0.1in}

If $f : A \to B$ is a morphism in $\set$ then the definition of the
graph relation transformer $\langle f \rangle$ for $f$ as a natural
transformation between $0$-ary functors $A$ and $B$ coincides with its
standard definition.  Graph relation transformers are thus a
reasonable extension of graph relations to functors.
\begin{comment}

\vspace*{0.2in}
  
If $f : A \to B$ is a function with graph relation $\graph{f} = (A, B,
\graph{f}^*)$, then $\langle \id_{A}, f \rangle : A \to A \times B$
and $\langle \id_{A}, f \rangle\, A = \graph{f}^*$.  Moreover, if
$\iota_{\graph{f}} : \graph{f}^* \hookrightarrow A \times B$ is the
inclusion of $\graph{f}^*$ into $A \times B$ then there is an
isomorphism of subobjects
\[\begin{tikzcd}
A \ar[rr, "{\cong}"] \ar[dr, "{\langle \id_{A}, f \rangle}"']
&&{\graph{f}^*} \ar[dl, "{\iota_{\graph{f}}}"]\\
&A \times B
\end{tikzcd}\]

We also note that if $f : A \to B$ is a function seen as a natural
transformation between 0-ary functors, then $\graph{f}$ is (the 0-ary
relation transformer associated with) the graph relation of $f$.
Indeed, we need to apply Definition~\ref{dfn:graph-nat-transf} with $k
= 0$, i.e., to the degenerate relation $\ast : \rel(\ast, \ast)$.  As
degenerate $0$-ary functors, $A$ and $B$ are constant functors, i.e.,
$A\, \ast = A$ and $B\, \ast = B$.  By the universal property of the
product, there exists a unique $h$ making the diagram
\[ \begin{tikzcd}[row sep = large]
        A
        &A
        \ar[l, equal]
        \ar[r, equal]
        \ar[d, dashed, "{h}"]
        &A
        \ar[r, "{f}"]
        &B \\
        &A \times B
        \ar[ul, "{\pi_1}"] \ar[urr, "{\pi_2}"']
\end{tikzcd}\]
commute. Since $\iota_\ast : \ast \to \ast$ is the identity on $\ast$,
and $A\, \id_{\ast} = \id_{A}$, we have $h_{\ast} = h$.  Moreover,
$h_{\overline{A \times B}} = \langle \id_{A}, f \rangle$ is a
monomorphism in $\set$ because $\id_{A}$ is.  Then,
$\iota_{f^\wedge\ast} = \langle \id_{A}, f \rangle$ and $f^\wedge\ast
= A$, from which we deduce that $\iota_{f^\wedge\ast} f^\wedge\ast =
\langle \id_{A}, f \rangle\, A = \graph{f}^*$. This ensures that the
graph of $f$ as a 0-ary natural transformation coincides with the
graph of $f$ as a morphism in $\set$, and so that
Definition~\ref{dfn:graph-nat-transf} is a reasonable generalization
of Definition~\ref{def:graph}.

Just as the equality relation $\Eq_B$ on a set $B$ coincides with
$\graph{\id_B}$, the graph of the identity on the set, so we can
define the equality relation transformer to be the graph of the
identity natural transformation. This gives

\begin{dfn}
Let $F : [\set^k, \set]$.  The equality relation transformer on $F$ is
defined to be $\Eq_F = \graph{\id_{F}}$. This entails that $Eq_F = (F,
F, \Eq_F^*)$ with $\Eq_F^* = \graph{\id_{F}}^*$.
\end{dfn}
\end{comment}

The action of a graph relation transformer on a graph relation can be
computed explicitly:  

\begin{lemma}\label{lem:eq-reln-equalities}
If $\alpha : F \to G$ is a morphism in $[\Set^k, \Set]$
and $f_1: A_1 \to B_1, ..., f_k : A_k \to B_k$,
then $\graph{\alpha}^* \graph{\overline{f}}
= \langle G \ol{f} \circ \alpha_{\ol{A}} \rangle
= \langle \alpha_{\ol{B}} \circ F \ol{f} \rangle$.
\end{lemma}
\begin{proof}
Since $h_{\overline{A \times B}}$ is the unique morphism making the
bottom triangle of the diagram on the left below commute, and since
$h_{\graph{\overline{f}}} = h_{\overline{A \times B}} \circ F
\,\ol{\iota_{\graph{f}}} = h_{\overline{A \times B}} \circ F
\overline{\langle \id_A, f \rangle}$, the universal property of the
product depicted in the diagram on the right gives
$h_{\graph{\overline{f}}} = \langle \id_{F \ol{A}}, \alpha_{\ol{B}}
\circ F\ol{f} \rangle : F \ol{A} \to F \ol{A} \times G \ol{B}$.

\begin{figure*}[ht]
  \vspace*{-0.15in}
  \begin{minipage}[b]{0.45\linewidth}
{\footnotesize
\[\begin{tikzcd}[row sep = large]
        &F\overline{A}
        \ar[d, "{F \overline{\langle \id_A, f \rangle}}" description]
        \ar[dl, equal]
        \ar[dr, "{F\ol{f}}"]\\
        F\overline{A}
        &F(\overline{A \times B})
        \ar[l, "{F\overline{\pi_1}}"']
        \ar[r, "{F\overline{\pi_2}}"]
        \ar[d, "{h_{\overline{A \times B}}}"]
        &F\overline{B}
        \ar[r, "{\alpha_{\ol{B}}}"]
        &G\overline{B}\\
        &F\overline{A} \times G\overline{B}
        \ar[ul, "{\pi_1}"] \ar[urr, "{\pi_2}"']
\end{tikzcd}\]}
\end{minipage}
  \begin{minipage}[b]{0.45\linewidth}
{\footnotesize
\[
      \begin{tikzcd}[row sep = large]
          F\overline{A}
          &F\overline{A} \times G\overline{B}
          \ar[l, "{\pi_1}"'] \ar[r, "{\pi_2}"]
          &G\overline{B}\\
          &F\overline{A}
          \ar[u, dashed, "{\exists !}"]
          \ar[ul, equal]
          \ar[r, "{F\ol{f}}"']
          &F{\ol{B}}
          \ar[u, "{\alpha_{\ol{B}}}"']
      \end{tikzcd}
      \]}
\end{minipage}
\end{figure*}

\vspace*{-0.1in}

\noindent
Moreover, $\langle \id_{F \ol{A}}, \alpha_{\ol{B}} \circ F\ol{f}
\rangle$ is a monomorphism in $\set$ because $\id_{F \ol{A}}$ is, so
its mono-epi factorization gives $\iota_{\alpha^\wedge
  \graph{\overline{f}}} = \langle \id_{F \ol{A}}, \alpha_{\ol{B}}
\circ F\ol{f} \rangle$, and thus $\alpha^\wedge \graph{\overline{f}} =
F\overline{A}$.  Then $\iota_{\alpha^\wedge \graph{\overline{f}}}
\alpha^\wedge \graph{\overline{f}} = \langle \id_{F \ol{A}},
\alpha_{\ol{B}} \circ F\ol{f} \rangle (F \ol{A}) = \graph{
  \alpha_{\ol{B}} \circ F\ol{f} }^*$, so that $\graph{ \alpha }^*
\graph{ \overline{f} } = (F\overline{A}, G\overline{B},
\iota_{\alpha^\wedge \graph{\overline{f}}}\, \alpha^\wedge
\graph{\overline{f}}) = (F\overline{A}, G\overline{B}, \graph{
  \alpha_{\ol{B}} \circ F\ol{f} }^*) = \graph{ \alpha_{\ol{B}} \circ
  F\ol{f} }$.  Finally, $\alpha_{\ol{B}} \circ F\ol{f} = G\ol{f} \circ
\alpha_{\ol{A}}$ by naturality of $\alpha$.
\end{proof}

To prove the IEL, we also need to know that the equality relation
transformer preserves equality relations.  The {\em equality relation
  transformer} on $F : [\set^k,\set]$ is defined to be $\Eq_F =
\graph{\id_{F}} = (F, F, \graph{\id_{F}}^*)$.
Lemma~\ref{lem:eq-reln-equalities} then gives that, for all $\ol{A :
\set}$,
\begin{equation}\label{eq:eq-pres-eq}
\Eq^*_F \ol{\Eq_A}
= \graph{\id_F}^* \graph{\id_{\ol{A}}}
= \graph{F \id_{\ol{A}} \circ (\id_F)_{\ol{A}}}
= \graph{\id_{F\ol{A}} \circ \id_{F\ol{A}}}
= \graph{\id_{F\ol{A}}}
= \Eq_{F\ol{A}}
\end{equation}

Graph relation transformers in general, and equality relation
transformers in particular, naturally extend to relation environments.
Indeed, if $\rho, \rho' : \setenv$ and $f : \rho \to \rho'$, then the
{\em graph relation environment} $\graph{f}$ is defined pointwise by
$\graph{f} \phi = \graph{f \phi}$ for every $\phi$, which entails that
$\pi_1 \graph{f} = \rho$ and $\pi_2 \graph{f} = \rho'$. In particular,
the {\em equality relation environment} $\Eq_\rho$ is defined to be
$\graph{\id_{\rho}}$, which entails that $\Eq_\rho \phi = \Eq_{\rho
  \phi}$ for every $\phi$.

With these definitions in hand, we can state and prove both an
Identity Extension Lemma and a Graph Lemma for our calculus.
\begin{thm}[IEL]\label{thm:iel}
If $\rho : \setenv$ and $\Gamma; \Phi \vdash F$ then $\relsem{\Gamma;
  \Phi \vdash F} \Eq_\rho = \Eq_{\setsem{\Gamma; \Phi \vdash F}\rho}$.
\end{thm}
{\color{red} INSERT ENTIRE PROOF. CHECK PROOF FOR $\mu$-TYPES AND
  CHECK NOTATION.}
The proof is by induction on the structure of $F$. Only the $\Nat$,
application, and fixpoint cases are non-routine. The latter two use
Lemma~\ref{lem:eq-reln-equalities}. The fixpoint case also uses the
observation that, for every $n \in \nat$, the following intermediate
results can be proved by simultaneous induction with
Theorem~\ref{thm:iel}: for any $H$, $\rho$, $A$, and any subformula
$J$ of $H$, both
%\begin{equation}\label{eq:iel-fix-point-intermediate1}
$T^n_{H,\Eq_{\rho}} K_0\, \ol{\Eq_A}
%{\setsem{\Gamma; \Phi \vdash F}\rho}}
= (\Eq_{(T^\set_{H,\rho})^n K_0})^*
\ol{\Eq_A}$\;
  %{\setsem{\Gamma; \Phi \vdash F}\rho}}$\;
%\end{equation}
and\;
%\begin{equation}\label{eq:iel-fix-point-intermediate2}
%\begin{split}
\[\begin{array}{ll}
&  \relsem{\Gamma; \Phi, \phi, \ol{\alpha} \vdash J} \Eq_{\rho} [\phi
  := T^{n}_{H,\Eq_{\rho}} K_0] \overline{[\alpha := \Eq_A]}\\
%{\setsem{\Gamma; \Phi \vdash F}\rho}]}\\
=  &
\relsem{\Gamma; \Phi, \phi,
  \ol{\alpha} \vdash J} \Eq_{\rho} [\phi := \Eq_{(T^\set_{H,\rho})^n K_0}]
\overline{[\alpha := \Eq_A]}
%         {\setsem{\Gamma; \Phi \vdash F}\rho}]}.
\end{array}\]
%\end{split}
%\end{equation}
hold. With these results in hand, the proof follows easily. It is
given in detail in the accompanying anonymous supplementary
material. As noted there, if functorial variables of arity greater
than $0$ were allowed to appear in the bodies of $\mu$-types, then the
IEL would fail.

\begin{comment}
\begin{proof}
By induction on the structure of $\tau$.
\begin{itemize}
\item $\relsem{\Gamma; \emptyset \vdash v}\Eq_{\rho} = \Eq_{\rho} v =
  \Eq_{\rho v} = \Eq_{\setsem{\Gamma; \emptyset \vdash v}\rho}$ where
  $v \in \Gamma$.
\item By definition, $\relsem{\Gamma; \emptyset \vdash
  \Nat^{\overline\alpha} \,F\,G} \Eq_{\rho}$ is the relation on
  $\setsem{\Gamma; \emptyset \vdash \Nat^{\overline\alpha} \,F\,G}
  \rho$ relating $t$ and $t'$ if, for all ${R_1 :
    \rel(A_1,B_1)},...,{R_k : \rel(A_k,B_k)}$, $(t_{\overline{A}},
  t'_{\overline{B}})$ is a morphism from $\relsem{\Gamma;
    \overline\alpha \vdash F} \Eq_{\rho}\overline{[\alpha := R]}$ to
  $\relsem{\Gamma ; \overline\alpha \vdash G}
  \Eq_{\rho}\overline{[\alpha := R]}$ in $\rel$.  To prove that this
  is equal to $\Eq_{\setsem{\Gamma; \emptyset \vdash
      \Nat^{\overline\alpha} \,F\,G} \rho}$ we need to show that
  $(t_{\overline{A}}, t'_{\overline{B}})$ is a morphism from
  $\relsem{\Gamma; \overline\alpha \vdash F}
  \Eq_{\rho}\overline{[\alpha := R]}$ to $\relsem{\Gamma ;
    \overline\alpha \vdash G} \Eq_{\rho}\overline{[\alpha := R]}$ in
  $\rel$ for all ${R_1 : \rel(A_1,B_1)},...,{R_k : \rel(A_k,B_k)}$ if
  and only if $t = t'$ and $(t_{\overline{A}}, t_{\overline{B}})$ is a
  morphism from $\relsem{\Gamma; \overline\alpha \vdash F}
  \Eq_{\rho}\overline{[\alpha := R]}$ to $\relsem{\Gamma ; \overline
    \alpha \vdash G} \Eq_{\rho}\overline{[\alpha := R]}$ in $\rel$ for
  all ${R_1 : \rel(A_1,B_1)}, ...,$ ${R_k : \rel(A_k,B_k)}$. The only
  interesting part of this equivalence is to show that if
  $(t_{\overline{A}}, t'_{\overline{B}})$ is a morphism from
  $\relsem{\Gamma; \overline\alpha \vdash F}
  \Eq_{\rho}\overline{[\alpha := R]}$ to $\relsem{\Gamma ;
    \overline\alpha \vdash G} \Eq_{\rho}\overline{[\alpha := R]}$ in
  $\rel$ for all ${R_1 : \rel(A_1,B_1),}$ $...,{R_k : \rel(A_k,B_k)}$,
  then $t = t'$.  By hypothesis, $(t_{\overline{A}},
  t'_{\overline{A}})$ is a morphism from $\relsem{\Gamma;
    \overline\alpha \vdash F} \Eq_{\rho}\overline{[\alpha :=
      \Eq_{A}]}$ to $\relsem{\Gamma ; \overline\alpha \vdash G}
  \Eq_{\rho}\overline{[\alpha := \Eq_{A}]}$ in $\rel$ for all
  $A_1\,...\,A_k : \set$. By the induction hypothesis, it is therefore
  a morphism from $\Eq_{\setsem{\Gamma; \overline\alpha \vdash F}
    \rho\overline{[\alpha := A]}}$ to $\Eq_{\setsem{\Gamma ;
      \overline\alpha \vdash G} \rho\overline{[\alpha := A]}}$ in
  $\rel$. This means that, for every $x : \Eq_{\setsem{\Gamma;
      \overline\alpha \vdash F} \rho\overline{[\alpha := A]}}$,
  $t_{\overline{A}}x = t'_{\overline{A}}x$.  Then, by extensionality,
  $t = t'$.
\item $\relsem{\Gamma; \Phi \vdash \zerot} \Eq_{\rho} = 0_\rel =
  \Eq_{0_\set} = \Eq_{\setsem{\Gamma; \Phi \vdash \zerot}\rho}$
\item $\relsem{\Gamma; \Phi \vdash \onet} \Eq_{\rho} = 1_\rel =
  \Eq_{1_\set} = \Eq_{\setsem{\Gamma; \Phi \vdash \onet}\rho}$
\item The application case is proved by the following sequence of
  equalities, where the second equality is by the induction hypothesis
  and the definition of the relation environment $\Eq_\rho$, the third
  is by the definition of application of relation transformers, and
  the fourth is by Lemma~\ref{lem:eq-reln-equalities}:
\[
\begin{split}
\relsem{\Gamma; \Phi \vdash \phi\ol{\tau}}\Eq_{\rho} &=
(\Eq_{\rho}\phi)\ol{\relsem{\Gamma; \Phi \vdash \tau}
\Eq_{\rho}}\\
&= \Eq_{\rho \phi}\, \ol{\Eq_{\setsem{\Gamma; \Phi \vdash \tau}
  \rho}}\\
&= (\Eq_{\rho \phi})^* \,\ol{\Eq_{\setsem{\Gamma; \Phi \vdash \tau}
  \rho}}\\
&= \Eq_{(\rho \phi) \,\ol{\setsem{\Gamma; \Phi \vdash \tau} \rho}}\\
&= \Eq_{\setsem{\Gamma; \Phi \vdash \phi\ol{\tau}}\rho}
\end{split}
\]
\item The fixpoint case is proven by the sequence of equalities
\[
\begin{split}
\relsem{\Gamma; \Phi \vdash (\mu \phi.\lambda
  \ol{\alpha}. H)\ol{\tau}}\Eq_{\rho} 
&=(\mu {T_{\Eq_{\rho}}}) \,\ol{\relsem{\Gamma; \Phi \vdash \tau}\Eq_{\rho}}\\ 
&= \colim{n \in \nat}{T^n_{\Eq_{\rho}} K_0}\, \ol{\relsem{\Gamma; \Phi
  \vdash \tau}\Eq_{\rho}}\\
&= \colim{n \in \nat}{ T^n_{\Eq_{\rho}} K_0 \,\ol{\Eq_{\setsem{\Gamma;
    \Phi \vdash \tau}\rho}}}\\
&= \colim{n \in \nat}{(\Eq_{(T^\set_\rho)^n K_0})^*
  \ol{\Eq_{\setsem{\Gamma; \Phi \vdash \tau}\rho}}}\\
&= \colim{n \in \nat}{\Eq_{(T^\set_\rho)^n K_0 \,\ol{\setsem{\Gamma;
        \Phi \vdash \tau}\rho}}}\\ 
&= \Eq_{\colim{n \in \nat}{ (T^\set_{\rho})^n K_0\,
    \ol{\setsem{\Gamma; \Phi \vdash \tau}\rho}}}\\
&= \Eq_{\setsem{\Gamma; \Phi \vdash (\mu \phi.\lambda
      \ol{\alpha}. H)\ol{\tau}}\rho}
\end{split}
\]
Here, the third equality is by induction hypothesis, the fifth is by
Lemma~\ref{lem:eq-reln-equalities} and the fourth equality is because,
for every $n \in \nat$, the following two statements can be proved by
simultaneous induction:
\begin{equation}\label{eq:iel-fix-point-intermediate1}
T^n_{\Eq_{\rho}} K_0\, \ol{\Eq_{\setsem{\Gamma; \Phi \vdash
      \tau}\rho}} = (\Eq_{(T^\set_\rho)^n K_0})^*
\ol{\Eq_{\setsem{\Gamma; \Phi \vdash \tau}\rho}}
\end{equation}
and
\begin{equation}\label{eq:iel-fix-point-intermediate2}
\begin{split}
  \relsem{\Gamma; \Phi, \phi, \ol{\alpha} \vdash H}
\Eq_{\rho} [\phi := 
 & T^{n}_{\Eq_{\rho}} K_0] \overline{[\alpha :=
    \Eq_{\setsem{\Gamma; \Phi \vdash \tau}\rho}]} \\
=\;\; & \relsem{\Gamma; \Phi, \phi, \ol{\alpha} \vdash H} \Eq_{\rho} [\phi
  := \Eq_{(T^\set_\rho)^n K_0}] \overline{[\alpha :=
    \Eq_{\setsem{\Gamma; \Phi \vdash \tau}\rho}]}
\end{split}
\end{equation}
We prove~\eqref{eq:iel-fix-point-intermediate1}.  The case $n=0$ is
trivial, because $T^0_{\Eq_{\rho}} K_0 = K_0$ and
$(T^\set_\rho)^0 K_0 = K_0$; the inductive step is
proved by the following sequence of equalities:
\[
\begin{split}
T^{n+1}_{\Eq_{\rho}} K_0\, \overline{\Eq_{\setsem{\Gamma; \Phi \vdash \tau}\rho}}
&= T^\rel_{\Eq_{\rho}} (T^{n}_{\Eq_{\rho}} K_0)
\overline{\Eq_{\setsem{\Gamma; \Phi \vdash \tau}\rho}} \\ 
&= \relsem{\Gamma; \Phi, \phi, \ol{\alpha} \vdash H} \Eq_{\rho} [\phi
  := T^{n}_{\Eq_{\rho}} K_0] \overline{[\alpha :=
    \Eq_{\setsem{\Gamma; \Phi \vdash \tau}\rho}]} \\ 
&= \relsem{\Gamma; \Phi, \phi, \ol{\alpha} \vdash H} \Eq_{\rho} [\phi
  := \Eq_{(T^\set_\rho)^n K_0}] \overline{[\alpha :=
    \Eq_{\setsem{\Gamma; \Phi \vdash \tau}\rho}]} \\ 
&= \relsem{\Gamma; \Phi, \phi, \ol{\alpha} \vdash H} \Eq_{\rho [\phi
    := (T^\set_\rho)^n K_0] \overline{[\alpha :=
      \setsem{\Gamma; \Phi \vdash \tau}\rho]}} \\ 
&= \Eq_{\setsem{\Gamma; \Phi, \phi, \ol{\alpha} \vdash H} \rho [\phi
    := (T^\set_\rho)^n K_0] \overline{[\alpha :=
      \setsem{\Gamma; \Phi \vdash \tau}\rho]}} \\ 
&= \Eq_{(T^\set_\rho)^{n+1} K_0 \overline{\setsem{\Gamma; \Phi
      \vdash \tau}\rho}} \\ 
&= (\Eq_{(T^\set_\rho)^{n+1} K_0})^*\, \overline{\Eq_{\setsem{\Gamma;
      \Phi \vdash \tau}\rho}} 
\end{split}
\]
Here, the third equality is by~\eqref{eq:iel-fix-point-intermediate2},
the fifth by the induction hypothesis on $H$, and the last by
Lemma~\ref{lem:eq-reln-equalities}.  We prove the induction step
of~\eqref{eq:iel-fix-point-intermediate2} by structural induction on
$H$: the only interesting case, though, is when $\phi$ is applied,
i.e., for $H = \phi \ol{\sigma}$, which is proved by the sequence of
equalities:
\[
\begin{split}
& \relsem{\Gamma; \Phi, \phi, \ol{\alpha} \vdash \phi
    \ol{\sigma}} \Eq_{\rho} [\phi := T^{n}_{\Eq_{\rho}} K_0]
  \overline{[\alpha := \Eq_{\setsem{\Gamma; \Phi \vdash \tau}\rho}]}
  \\
&= T^{n}_{\Eq_{\rho}} K_0\, \overline{\relsem{\Gamma; \Phi,
      \phi, \ol{\alpha} \vdash \sigma} \Eq_{\rho} [\phi :=
      T^{n}_{\Eq_{\rho}} K_0] \overline{[\alpha :=
        \Eq_{\setsem{\Gamma; \Phi \vdash \tau} \rho}]}} \\ 
&= T^{n}_{\Eq_{\rho}} K_0\, \overline{\relsem{\Gamma; \Phi,
      \phi, \ol{\alpha} \vdash \sigma} \Eq_{\rho} [\phi :=
      \Eq_{(T^\set_\rho)^{n} K_0}] \overline{[\alpha :=
        \Eq_{\setsem{\Gamma; \Phi \vdash \tau} \rho}]}} \\ 
&= T^{n}_{\Eq_{\rho}} K_0\, \overline{\relsem{\Gamma; \Phi,
      \phi, \ol{\alpha} \vdash \sigma} \Eq_{\rho [\phi := (T^\set_\rho)^{n}
        K_0] \overline{[\alpha := \setsem{\Gamma; \Phi \vdash
            \tau} \rho]}}} \\ 
&= T^{n}_{\Eq_{\rho}} K_0\, \overline{\Eq_{\setsem{\Gamma;
        \Phi, \phi, \ol{\alpha} \vdash \sigma} \rho [\phi :=
        (T^\set_\rho)^{n} K_0] \overline{[\alpha :=
          \setsem{\Gamma; \Phi \vdash \tau} \rho]}}} \\ 
&= (\Eq_{(T^\set_\rho)^{n} K_0})^* \,\overline{\Eq_{\setsem{\Gamma;
        \Phi, \phi, \ol{\alpha} \vdash \sigma} \rho [\phi :=
        (T^\set_\rho)^{n} K_0] \overline{[\alpha :=
          \setsem{\Gamma; \Phi \vdash \tau} \rho]}}} \\ 
&= (\Eq_{(T^\set_{\rho})^{n} K_0})^* \overline{\relsem{\Gamma;
      \Phi, \phi, \ol{\alpha} \vdash \sigma} \Eq_{\rho} [\phi :=
      \Eq_{(T^\set_{\rho})^{n} K_0}] \overline{[\alpha :=
        \Eq_{\setsem{\Gamma; \Phi \vdash \tau}\rho}]}} \\ 
&= \relsem{\Gamma; \Phi, \phi, \ol{\alpha} \vdash \phi \ol{\sigma}}
  \Eq_{\rho} [\phi := \Eq_{(T^\set_{\rho})^{n} K_0}]
  \overline{[\alpha := \Eq_{\setsem{\Gamma; \Phi \vdash \tau}\rho}]} 
\end{split}
\]
Here, the second equality is by the induction hypothesis
for~\eqref{eq:iel-fix-point-intermediate2} on the $\sigma$s, the
fourth is by the induction hypothesis for Theorem~\ref{thm:iel} on the
$\sigma$s, and the fifth is by the induction hypothesis on $n$
for~\eqref{eq:iel-fix-point-intermediate1}.
\item $\relsem{\Gamma; \Phi \vdash \sigma + \tau} \Eq_{\rho} =
  \relsem{\Gamma; \Phi \vdash \sigma} \Eq_{\rho} + \relsem{\Gamma;
    \Phi \vdash \tau} \Eq_{\rho} = \Eq_{\setsem{\Gamma; \Phi \vdash
      \sigma}\rho} + \Eq_{\setsem{\Gamma; \Phi \vdash \tau}\rho} =
  \Eq_{\setsem{\Gamma; \Phi \vdash \sigma}\rho + \setsem{\Gamma; \Phi
      \vdash \tau}\rho} = \Eq_{\setsem{\Gamma; \Phi \vdash \sigma +
      \tau}\rho}$
\item $\relsem{\Gamma; \Phi \vdash \sigma \times \tau} \Eq_{\rho} =
  \relsem{\Gamma; \Phi \vdash \sigma}\Eq_{\rho} \times \relsem{\Gamma;
    \Phi \vdash \tau}\Eq_{\rho} = \Eq_{\setsem{\Gamma; \Phi \vdash
      \sigma}\rho} \times \Eq_{\setsem{\Gamma; \Phi \vdash \tau}\rho}
  = \Eq_{\setsem{\Gamma; \Phi \vdash \sigma}\rho \times
    \setsem{\Gamma; \Phi \vdash \tau}\rho} = \Eq_{\setsem{\Gamma;
      \Phi \vdash \sigma \times \tau}\rho}$
\end{itemize}
\end{proof}
\end{comment}

With the IEL in hand we can prove a Graph Lemma appropriate to our
setting:
\begin{lemma}[Graph Lemma]\label{lem:graph}
If $\rho, \rho' : \setenv$ and $f : \rho \to \rho'$ then
$\graph{\setsem{\Gamma; \Phi \vdash F} f} = \relsem{\Gamma; \Phi
  \vdash F}\graph{f}$.
\end{lemma}
\begin{proof}
Applying Lemma~\ref{lem:rel-transf-morph} to the morphisms $(f,
\id_{\rho'}) : \graph{f} \to \Eq_{\rho'}$ and $(\id_{\rho}, f) :
\Eq_{\rho} \to \graph{f}$ of relation environments gives that
$(\setsem{\Gamma; \Phi \vdash F}f, \setsem{\Gamma; \Phi \vdash
  F}\id_{\rho'}) = \relsem{\Gamma; \Phi \vdash F} (f, \id_{\rho'}) :
\relsem{\Gamma; \Phi \vdash F}\graph{f} \to \relsem{\Gamma; \Phi
  \vdash F}\Eq_{\rho'}$ and $(\setsem{\Gamma; \Phi \vdash
  F}\id_{\rho}, \setsem{\Gamma; \Phi \vdash F}f) = \relsem{\Gamma;
  \Phi \vdash F} (\id_{\rho}, f) : \relsem{\Gamma; \Phi \vdash
  F}\Eq_{\rho} \to \relsem{\Gamma; \Phi \vdash F}\graph{f}$.
Expanding the first equation gives that if $(x,y) \in \relsem{\Gamma;
  \Phi \vdash F}\graph{f}$ then $(\setsem{\Gamma; \Phi \vdash F} f\,
x, \setsem{\Gamma; \Phi \vdash F}\id_{\rho'}\, y) \in \relsem{\Gamma;
  \Phi \vdash F}\Eq_{\rho'}$. So $\setsem{\Gamma; \Phi \vdash
  F}\id_{\rho'}\, y = \id_{\setsem{\Gamma; \Phi \vdash F}\rho'}\, y =
y$ and $\relsem{\Gamma; \Phi \vdash F}\Eq_{\rho'} =
\Eq_{\setsem{\Gamma; \Phi \vdash F}\rho'}$, and if $(x,y) \in
\relsem{\Gamma; \Phi \vdash F}\graph{f}$ then $(\setsem{\Gamma; \Phi
  \vdash F} f\, x, y) \in \Eq_{\setsem{\Gamma; \Phi \vdash F}\rho'}$,
i.e., $\setsem{\Gamma; \Phi \vdash F} f\, x = y$, i.e., $(x, y) \in
\graph{\setsem{\Gamma; \Phi \vdash F} f}$.  So, we have that
$\relsem{\Gamma; \Phi \vdash F}\graph{f} \subseteq
\graph{\setsem{\Gamma; \Phi \vdash F}f}$.  Expanding the second
equation gives that if $x \in \setsem{\Gamma; \Phi \vdash F}\rho$ then
$(\setsem{\Gamma; \Phi \vdash F}\id_{\rho}\, x,$\\
$\setsem{\Gamma; \Phi
  \vdash F} f\, x) \in \relsem{\Gamma; \Phi \vdash F}\graph{f}$.  Then
$\setsem{\Gamma; \Phi \vdash F}\id_{\rho}\, x = \id_{\setsem{\Gamma;
    \Phi \vdash F}\rho} x = x$, so for any $x \in \setsem{\Gamma; \Phi
  \vdash F}\rho$ we have that $(x, \setsem{\Gamma; \Phi \vdash F}f\,
x) \in \relsem{\Gamma; \Phi \vdash F}\graph{f}$.  Moreover, $x \in
\setsem{\Gamma; \Phi \vdash F}\rho$ if and only if $(x,
\setsem{\Gamma; \Phi \vdash F} f\, x) \in \graph{\setsem{\Gamma; \Phi
    \vdash F}f}$ and, if $x \in \setsem{\Gamma; \Phi \vdash F}\rho$
then $(x, \setsem{\Gamma; \Phi \vdash F} f\, x) \in \relsem{\Gamma;
  \Phi \vdash F} \graph{f}$, so if $(x, \setsem{\Gamma; \Phi \vdash F}
f\, x) \in \graph{\setsem{\Gamma; \Phi \vdash F}f}$ then $(x,
\setsem{\Gamma; \Phi \vdash F} f\, x) \in \relsem{\Gamma; \Phi \vdash
  F} \graph{f}$, i.e., $\graph{\setsem{\Gamma; \Phi \vdash F}f}
\subseteq \relsem{\Gamma; \Phi \vdash F} \graph{f}$.
\end{proof}



\begin{comment}

\begin{proof}
First observe that $(f, \id_{\rho'}) : \graph{f} \to \Eq_{\rho'}$ and
$(\id_{\rho}, f) : \Eq_{\rho} \to \graph{f}$ are morphisms of relation
environments.  Applying Lemma~\ref{lem:rel-transf-morph} to each of
these observations gives that
\begin{equation}\label{eq:graph-one}
(\setsem{\Gamma; \Phi \vdash F}f, \setsem{\Gamma; \Phi \vdash
    F}\id_{\rho'}) = \relsem{\Gamma; \Phi \vdash F} (f, \id_{\rho'}) :
  \relsem{\Gamma; \Phi \vdash F}\graph{f} \to \relsem{\Gamma; \Phi
    \vdash F}\Eq_{\rho'}
\end{equation}
and
\begin{equation}\label{eq:graph-two}
(\setsem{\Gamma; \Phi \vdash F}\id_{\rho}, \setsem{\Gamma; \Phi \vdash F}f)
= \relsem{\Gamma; \Phi \vdash F} (\id_{\rho}, f)
: \relsem{\Gamma; \Phi \vdash F}\Eq_{\rho} \to \relsem{\Gamma; \Phi \vdash F}\graph{f}
\end{equation}
Expanding Equation~\ref{eq:graph-one} gives that if
$(x,y) \in \relsem{\Gamma; \Phi \vdash F}\graph{f}$
then
\[(\setsem{\Gamma; \Phi \vdash F} f\, x, \setsem{\Gamma; \Phi \vdash
  F}\id_{\rho'}\, y) \in \relsem{\Gamma; \Phi \vdash F}\Eq_{\rho'}\]
Observe that $\setsem{\Gamma; \Phi \vdash F}\id_{\rho'}\, y =
\id_{\setsem{\Gamma; \Phi \vdash F}\rho'}\, y = y$ and
$\relsem{\Gamma; \Phi \vdash F}\Eq_{\rho'} = \Eq_{\setsem{\Gamma; \Phi
    \vdash F}\rho'}$. So, if $(x,y) \in \relsem{\Gamma; \Phi \vdash
  F}\graph{f}$ then $(\setsem{\Gamma; \Phi \vdash F} f\, x, y) \in
\Eq_{\setsem{\Gamma; \Phi \vdash F}\rho'}$, i.e., $\setsem{\Gamma;
  \Phi \vdash F} f\, x = y$, i.e., $(x, y) \in \graph{\setsem{\Gamma;
    \Phi \vdash F} f}$.  So, we have that $\relsem{\Gamma; \Phi \vdash
  F}\graph{f} \subseteq \graph{\setsem{\Gamma; \Phi \vdash F}f}$

Expanding Equation~\ref{eq:graph-two} gives that, for any
$x \in \setsem{\Gamma; \Phi \vdash F}\rho$,
then
\[
(\setsem{\Gamma; \Phi \vdash F}\id_{\rho}\, x, \setsem{\Gamma; \Phi
  \vdash F} f\, x) \in \relsem{\Gamma; \Phi \vdash F}\graph{f} 
\]
Observe that $\setsem{\Gamma; \Phi \vdash F}\id_{\rho}\, x =
\id_{\setsem{\Gamma; \Phi \vdash F}\rho} x = x$ so, for any $x \in
\setsem{\Gamma; \Phi \vdash F}\rho$, we have that $(x, \setsem{\Gamma;
  \Phi \vdash F}f\, x) \in \relsem{\Gamma; \Phi \vdash F}\graph{f}$.
Moreover, $x \in \setsem{\Gamma; \Phi \vdash F}\rho$ if and only if
$(x, \setsem{\Gamma; \Phi \vdash F} f\, x) \in \graph{\setsem{\Gamma;
    \Phi \vdash F}f}$ and, if $x \in \setsem{\Gamma; \Phi \vdash
  F}\rho$ then $(x, \setsem{\Gamma; \Phi \vdash F} f\, x) \in
\relsem{\Gamma; \Phi \vdash F} \graph{f}$, so if $(x, \setsem{\Gamma;
  \Phi \vdash F} f\, x) \in \graph{\setsem{\Gamma; \Phi \vdash F}f}$
then $(x, \setsem{\Gamma; \Phi \vdash F} f\, x) \in \relsem{\Gamma;
  \Phi \vdash F} \graph{f}$, i.e., $\graph{\setsem{\Gamma; \Phi \vdash
    F}f} \subseteq \relsem{\Gamma; \Phi \vdash F} \graph{f}$. We
conclude that $\relsem{\Gamma; \Phi \vdash F}\graph{f} =
\graph{\setsem{\Gamma; \Phi \vdash F}f}$ as desired.
\end{proof}
\end{comment}

{\color{red} STOPPED HERE!!!!!}

\section{Interpreting Terms}\label{sec:term-interp}

If $\Delta = x_1 : F_1,...,x_n : F_n$ is a term context for $\Gamma$
and $\Phi$, then the interpretations $\setsem{\Gamma;\Phi \vdash \Delta}$ and
$\relsem{\Gamma;\Phi \vdash \Delta}$ are defined by
\[\begin{array}{lll}
\setsem{\Gamma;\Phi \vdash \Delta} & = & \setsem{\Gamma;\Phi \vdash
  F_1} \times ... \times \setsem{\Gamma;\Phi \vdash F_n}\\ 
\relsem{\Gamma;\Phi \vdash \Delta} & = & \relsem{\Gamma;\Phi \vdash
  F_1} \times ... \times \relsem{\Gamma;\Phi \vdash F_n}\\ 
\end{array}\]
Every well-formed term $\Gamma;\Phi~|~\Delta \vdash t : F$ then
has, for every $\rho \in \setenv$, set interpretations
$\setsem{\Gamma;\Phi~|~\Delta \vdash t : F}\rho$ as natural
transformations from $\setsem{\Gamma; \Phi \vdash \Delta}\rho$ to
$\setsem{\Gamma; \Phi \vdash F}\rho$, and, for every $\rho \in
\relenv$, relational interpretations $\relsem{\Gamma;\Phi~|~\Delta
  \vdash t : F}\rho$ as natural transformations from
$\relsem{\Gamma; \Phi \vdash \Delta}\rho$ to $\relsem{\Gamma; \Phi
  \vdash F}\rho$. These are given in Definition~\ref{def:set-interp}.

\begin{dfn}\label{def:set-interp}
If $\rho$ is a set (resp., relation) environment and
$\Gamma;\Phi~|~\Delta \vdash t : F$ then
$\setsem{\Gamma;\Phi~|~\Delta \vdash t : F}\rho$ (resp.,
$\relsem{\Gamma;\Phi~|~\Delta \vdash t : F}\rho$) is defined as in
Figure~\ref{fig:term-sem}, where $\mathsf D$ is either $\set$ or
$\rel$ as appropriate.
\end{dfn}

\subsection{Basic Properties of Term Interpretations}

The interpretations in Definition~\ref{def:set-interp} respect
weakening, i.e., a term and its weakenings all have the same set and
relational interpretations. Specifically, for any $\rho \in \setenv$,
$\setsem{\Gamma;\Phi \,|\, \Delta, x : F \vdash t : G}\rho =
(\setsem{\Gamma;\Phi \,|\, \Delta \vdash t : G}\rho) \circ
\pi_{\Delta}$, where $\pi_{\Delta}$ is the projection
$\setsem{\Gamma;\Phi \vdash \Delta, x : F} \to
\setsem{\Gamma;\Phi \vdash \Delta}$. A similar result holds for
relational interpretations.

\begin{figure*}
\hspace*{-3.1in}
\resizebox{0.46\linewidth}{!}{
\begin{minipage}[t]{0.5\textwidth}
\[\begin{array}{lll}
\dsem{\Gamma;\Phi \,|\, \Delta,x :F \vdash x : F} \rho& = &
\pi_{|\Delta|+1}\\
%\dsem{\Gamma;\emptyset \,|\, \Delta \vdash \lambda x.t : \sigma \to \tau}\rho &
%= & \curry (\dsem{\Gamma;\emptyset \,|\, \Delta, x : \sigma \vdash t :
%  \tau}\rho)\\ 
%\dsem{\Gamma;\emptyset \,|\, \Delta \vdash st: \tau} \rho & = &
%\eval \circ
% \langle \dsem{\Gamma;\emptyset \,|\, \Delta \vdash s: \sigma \to
%  \tau}\rho, \dsem{\Gamma;\emptyset \,|\, \Delta \vdash t: \sigma}\rho
%\rangle\\
\dsem{\Gamma;\emptyset \,|\, \Delta \vdash L_{\overline \alpha} x.t : \Nat^{\overline
    \alpha} \,F \,G}\rho & = &  \curry (\dsem{\Gamma;\overline \alpha
  \,|\, \Delta, x : F \vdash t: G}\rho[\overline{\alpha := \_}])\\
\dsem{\Gamma;\Phi \,|\, \Delta \vdash t_{\overline K} s:
  G [\overline{\alpha := K}]}\rho & = & \eval \circ \langle
  \lambda d.\,(\dsem{\Gamma;\emptyset \,|\, \Delta \vdash t :
  \Nat^{\overline{\alpha}} \,F \,G}\rho\; d)_{\overline{\dsem{\Gamma;\Phi
      \vdash K}\rho}},\\ 
 & & \hspace*{0.5in} \dsem{\Gamma;\Phi \,|\,
    \Delta \vdash s: F [\overline{\alpha := K}]}\rho \rangle\\ 
& & \\
%% \color{red} \mbox{Add rules for } \forall \mbox{ if we include it} & & \\
%\dsem{\Gamma;\Phi \,|\, \Delta,x :F \vdash x : F} \rho& = &
%\pi_{|\Delta|+1}\\
\dsem{\Gamma;\Phi \,|\, \Delta \vdash \bot_F t : F} \rho& = &
!^0_{\dsem{\Gamma;\Phi \vdash F}\rho} \circ
  \dsem{\Gamma;\Phi~|~\Delta \vdash t : \zerot}\rho, \mbox{ where } \\
 & & \hspace*{0.1in} !^0_{\dsem{\Gamma;\Phi \vdash F}\rho}
\mbox{ is the unique morphism from } 0\\
 & & \hspace*{0.1in} \mbox{ to } \dsem{\Gamma;\Phi \vdash F}\rho\\
\dsem{\Gamma;\Phi \,|\, \Delta \vdash \top : \onet}\rho & = &
!^{\dsem{\Gamma;\Phi\vdash \Delta}\rho}_1, \mbox{ where }
!^{\dsem{\Gamma;\Phi\vdash \Delta}\rho}_1\\ 
& & \hspace*{0.1in} \mbox{ is the unique morphism from }
\dsem{\Gamma;\Phi\vdash \Delta}\rho \mbox{ to } 1\\ 
\dsem{\Gamma;\Phi \,|\, \Delta \vdash (s,t) : F \times G} \rho& = &
\dsem{\Gamma;\Phi \,|\, \Delta \vdash s: F} \rho\times
\dsem{\Gamma;\Phi \,|\, \Delta \vdash t : G} \rho\\
\dsem{\Gamma;\Phi \,|\, \Delta \vdash \pi_1 t : F} \rho& = &
\pi_1 \circ \dsem{\Gamma;\Phi \,|\, \Delta \vdash t : F \times G}\rho\\
\dsem{\Gamma;\Phi \,|\, \Delta \vdash \pi_2 t : G}\rho & = &
\pi_2 \circ \dsem{\Gamma;\Phi \,|\, \Delta \vdash t : F \times
  G} \rho\\
\dsem{\Gamma;\Phi~|~\Delta \vdash \cse{t}{x \mapsto l}{y \mapsto r} :
  K}\rho & = & \eval \circ \langle \curry \,[\dsem{\Gamma;\Phi
    \,|\, \Delta, x : F \vdash l : K}\rho,\\
   & & \hspace*{0.79in} \dsem{\Gamma;\Phi \,|\, \Delta, y
    : G \vdash r : K}\rho],\\
   & &  \hspace*{0.5in} \dsem{\Gamma;\Phi \,|\, \Delta \vdash t :
  F + G} \rho\rangle\\   
\dsem{\Gamma;\Phi \,|\, \Delta \vdash \inl \,s: F + G} \rho& = &
\inl \circ \dsem{\Gamma;\Phi \,|\, \Delta \vdash s: F}\rho\\
\dsem{\Gamma;\Phi \,|\, \Delta \vdash \inr \,t: F + G}\rho & = & 
\inr \circ \dsem{\Gamma;\Phi \,|\, \Delta \vdash t : G}\rho\\
\llbracket \Gamma;\emptyset \,|\, \emptyset \vdash \map^{\ol{F},\ol{G}}_H
  : \Nat^\emptyset (\Nat^{\ol\beta,\ol\gamma} F\,G)
& = & \lambda d\, \ol\eta\,\ol{C}.\,
\dsem{\Gamma; \ol{\phi},\ol{\gamma}\vdash H}\id_{\rho[\ol{\gamma:=
      C}]}[\ol{\phi := \lambda \ol B. \eta_{\ol B\, \ol C}}]\\ 
\hspace*{0.5in}
  (\Nat^{\ol{\gamma}}\,H[\ol{\phi :=_{\ol{\beta}} F}]\,H[\ol{\phi
      :=_{\ol{\beta}} G}]) \rrbracket^{\mathsf D} \rho & &\\
%\hspace*{0.79in}  & & \hspace*{0.1in}\id_{\rho[\ol{\gamma :=
%      C}]}[\ol{\phi := \lambda
%    \ol{B}. (\dsem{\Gamma;\ol\alpha\,|\,\Delta \vdash t : 
%    \Nat^{\ol{\beta},\ol{\gamma}}\,F\,G}\rho\,d)_{\ol{B}\,\ol{C}}}]\\
\llbracket \Gamma;\emptyset \,|\, \emptyset \vdash \tin_H :
Nat^{\ol{\beta},\ol{\gamma}} \, H[\phi := (\mu \phi.\lambda {\overline
    \alpha}.H){\overline \beta}][\ol{\alpha := \beta}] & = &
\lambda d\,\ol{B}\,
\ol{C}.\,(\mathit{in}_{{T}^X_{H,\rho[\ol{\gamma :=
        C}]}})_{\ol{B}} \;\;\mbox{ where } X \mbox{ is } \set \mbox{ when } \\ 
\hspace*{0.79in}(\mu \phi.\lambda {\overline \alpha}.H){\overline
  \beta} \rrbracket^{\mathsf{D}} \rho & & \hspace*{0.2in}  
\mathsf{D} = \set \mbox{ and not present when }
\mathsf{D} = \rel\\  
\llbracket \Gamma;\emptyset \,|\, \emptyset \vdash
  \fold^F_H : \Nat^\emptyset\;(\Nat^{\ol{\beta}, \ol{\gamma}}\,H[\phi
    :=_{\ol{\beta}} F][\ol{\alpha := \beta}]\,F) & = &  
\lambda d\,\eta\,\ol{B}\,\ol{C}.\,
(\mathit{fold}_{T^X_{H,\rho[\ol{\gamma := C}]}} \, (\lambda
\ol{A}.\,\eta_{\ol{A}\,\ol{C}}))_{\ol{B}}\\ 
\hspace*{0.79in}(\Nat^{{\ol{\beta},\ol{\gamma}} }\,(\mu
  \phi.\lambda \overline \alpha.H)\overline \beta\;F)
\rrbracket^{\mathsf{D}} \rho & & \hspace*{0.2in} \mbox{ where } X \mbox{ is as above
}\vspace*{-0.1in} 
\end{array}\]
\caption{Term semantics}\label{fig:term-sem} 
\end{minipage}}\vspace*{-0.05in}
\end{figure*}

\begin{comment}
\begin{dfn}\label{def:rel-interp}
If $\rho$ is a relation environment and $\Gamma;\Phi~|~\Delta \vdash t :
\tau$ then $\relsem{\Gamma;\Phi~|~\Delta \vdash t : \tau}\rho$ is
defined as follows:
\[\begin{array}{lll}
\relsem{\Gamma;\emptyset \,|\, \Delta,x :\tau \vdash x : \tau} \rho& = &
\pi_{|\Delta|+1}\\
%\relsem{\Gamma;\emptyset \,|\, \Delta \vdash \lambda x.t : \sigma \to \tau}\rho &
%= & \curry (\relsem{\Gamma;\emptyset \,|\, \Delta, x : \sigma \vdash t :
%  \tau}\rho)\\ 
%\relsem{\Gamma;\emptyset \,|\, \Delta \vdash st: \tau} \rho & = & \eval
%\circ \langle \relsem{\Gamma;\emptyset \,|\, \Delta \vdash s: \sigma \to
%  \tau}\rho, \relsem{\Gamma;\emptyset \,|\, \Delta \vdash t: \sigma}\rho
%\rangle\\
\relsem{\Gamma;\emptyset \,|\, \Delta \vdash L_{\overline \alpha} x.t : \Nat^{\overline
    \alpha} \,F \,G}\rho & = &  \curry (\relsem{\Gamma;\overline \alpha
  \,|\, \Delta, x : F \vdash t: G}\rho[\overline{\alpha := \_}])\\
\relsem{\Gamma;\Phi \,|\, \Delta \vdash t_{\overline{\tau}} s:
  G [\overline{\alpha := \tau}]}\rho & = & \eval \circ \langle
  \lambda e. \,(\relsem{\Gamma;\emptyset \,|\, \Delta \vdash t :
  \Nat^{\overline{\alpha}} \,F \,G}\rho\; e)_{\overline{\relsem{\Gamma;\Phi
      \vdash \tau}\rho}},\\ 
 & & \hspace*{0.5in} \relsem{\Gamma;\Phi \,|\,
    \Delta \vdash s: F [\overline{\alpha := \tau}]}\rho \rangle\\ 
& & \\
%% \color{red} \mbox{Add rules for } \forall \mbox{ if we include it} & & \\
\relsem{\Gamma;\Phi \,|\, \Delta,x :\tau \vdash x : \tau} \rho& = &
\pi_{|\Delta|+1}\\
\relsem{\Gamma;\Phi \,|\, \Delta \vdash \bot_\tau t : \tau} \rho& = &
!^0_{\relsem{\Gamma;\Phi \vdash \tau}\rho} \circ
  \relsem{\Gamma;\Phi~|~\Delta \vdash t : \zerot}\rho, \mbox{ where } \\
 & & \hspace*{0.1in} !^0_{\relsem{\Gamma;\Phi \vdash \tau}\rho}
\mbox{ is the unique morphism from } 0\\
 & & \hspace*{0.1in} \mbox{ to } \relsem{\Gamma;\Phi \vdash \tau}\rho\\
\relsem{\Gamma;\Phi \,|\, \Delta \vdash \top : \onet}\rho & = &
!^{\relsem{\Gamma;\Phi\vdash \Delta}\rho}_1, \mbox{ where }
!^{\relsem{\Gamma;\Phi\vdash \Delta}\rho}_1\\ 
& & \hspace*{0.1in} \mbox{ is the unique morphism from }
\relsem{\Gamma;\Phi\vdash \Delta}\rho \mbox{ to } 1\\ 
\relsem{\Gamma;\Phi \,|\, \Delta \vdash (s,t) : \sigma \times \tau} \rho& = &
\relsem{\Gamma;\Phi \,|\, \Delta \vdash s: \sigma} \rho\times
\relsem{\Gamma;\Phi \,|\, \Delta \vdash t: \tau} \rho\\
\relsem{\Gamma;\Phi \,|\, \Delta \vdash \pi_1 t : \sigma} \rho& = &
\pi_1 \circ \relsem{\Gamma;\Phi \,|\, \Delta \vdash t : \sigma \times \tau}\rho\\
\relsem{\Gamma;\Phi \,|\, \Delta \vdash \pi_2 t : \sigma}\rho & = &
\pi_2 \circ \relsem{\Gamma;\Phi \,|\, \Delta \vdash t : \sigma \times
  \tau} \rho\\
\relsem{\Gamma;\Phi~|~\Delta \vdash \cse{t}{x \mapsto l}{y \mapsto r} :
  \gamma}\rho & = & \eval \circ \langle \curry \,[\relsem{\Gamma;\Phi
    \,|\, \Delta, x : \sigma \vdash l : \gamma}\rho,\\
   & & \hspace*{0.79in} \relsem{\Gamma;\Phi \,|\, \Delta, y
    : \tau \vdash r : \gamma}\rho],\\
   & &  \hspace*{0.5in} \relsem{\Gamma;\Phi \,|\, \Delta \vdash t :
  \sigma + \tau} \rho\rangle \\
\relsem{\Gamma;\Phi \,|\, \Delta \vdash \inl \,s: \sigma + \tau} \rho& = &
\inl \circ \relsem{\Gamma;\Phi \,|\, \Delta \vdash s: \sigma}\rho\\
\relsem{\Gamma;\Phi \,|\, \Delta \vdash \inr \,t: \sigma + \tau}\rho & = & 
\inr \circ \relsem{\Gamma;\Phi \,|\, \Delta \vdash t : \tau}\rho\\
\llbracket \Gamma;\emptyset \,|\, \emptyset \vdash \map^{\ol{F},\ol{G}}_H :
\Nat^\emptyset\;(\ol{\Nat^{\ol{\beta},\ol{\gamma}}\,F\,G})\;&
= & \lambda d\, \ol{\eta}\,\ol{R}.\,
\relsem{\Gamma; \ol{\phi},\ol{\gamma}\vdash H}\id_{\rho[\ol{\gamma :=
      R}]}[\ol{\phi := \lambda \ol{S}.\eta_{\ol{S}\,\ol{R}}}]\\
\hspace*{0.79in} (\Nat^{\ol{\gamma}}\,H[\ol{\phi :=_{\ol{\beta}} F}]\,H[\ol{\phi
      :=_{\ol{\beta}} G}]) \rrbracket^\rel \rho & & \\
\llbracket \Gamma;\emptyset \,|\, \emptyset \vdash \tin_H :
Nat^{\ol{\beta},\ol{\gamma}} \, H[\phi := (\mu \phi.\lambda {\overline
    \alpha}.H){\overline \beta}][\ol{\alpha := \beta}] & = &
\lambda d\,\ol{R}\, \ol{S}.\,(\mathit{in}_{T_{\rho[\ol{\gamma := S}]}})_{\ol{R}}\\
\hspace*{0.79in}(\mu \phi.\lambda {\overline \alpha}.H){\overline
  \beta} \rrbracket^\rel \rho & & \\
\llbracket \Gamma;\emptyset \,|\, \emptyset \vdash
  \fold^F_H : \Nat^\emptyset\;(\Nat^{\ol{\beta}, \ol{\gamma}}\,H[\phi
    :=_{\ol{\beta}} F][\ol{\alpha := \beta}]\,F) & = &  
\lambda d\,\eta\,\ol{R}\,\ol{S}.\, (\mathit{fold}_{T_{\rho[\ol{\gamma
        := S}]}} \, (\lambda
\ol{Z}.\,\eta_{\ol{Z}\,\ol{S}}))_{\ol{R}}\\
\hspace*{0.79in}(\Nat^{{\ol{\beta},\ol{\gamma}} }\,(\mu
  \phi.\lambda \overline \alpha.H)\overline \beta\;F)
\rrbracket^\rel \rho & & 
\end{array}\]
\end{dfn}
{\color{blue} Add return type for fold in last clause? Should be
  $\relsem{\Gamma;\ol\beta,\ol\gamma \vdash F}\rho[\ol{\gamma :=
  C}]$.}

This interpretation gives that $\relsem{\Gamma;\emptyset \,|\, \Delta
  \vdash \lambda x.t : \sigma \to \tau}\rho = \curry
(\relsem{\Gamma;\emptyset \,|\, \Delta, x : \sigma \vdash t :
  \tau}\rho)$ and $\relsem{\Gamma;\emptyset \,|\, \Delta \vdash st:
  \tau} \rho = \eval \circ \langle \relsem{\Gamma;\emptyset \,|\,
  \Delta \vdash s: \sigma \to \tau}\rho, \relsem{\Gamma;\emptyset
  \,|\, \Delta \vdash t: \sigma}\rho \rangle$, as expected.

If $t$ is closed, i.e., if $\emptyset; \emptyset~|~\emptyset \vdash t
: \tau$, then we write $\setsem{\vdash t : \tau}$ instead of
$\setsem{\emptyset; \emptyset~|~\emptyset \vdash t : \tau}$.
\end{comment}

\begin{comment}
  , and for any $\rho \in \relenv$, 
\[ \relsem{\Gamma;\Phi \,|\, \Delta, x : \sigma \vdash t : \tau}\rho
  = (\relsem{\Gamma;\Phi \,|\, \Delta \vdash t : \tau}\rho) \circ
  \pi_{\Delta}\] where $\pi_{\Delta}$ is the projection
  $\relsem{\Gamma;\Phi \vdash \Delta, x : \sigma} \to
  \relsem{\Gamma;\Phi \vdash \Delta}$.
\end{comment}

The return type for the semantic fold is
  $\dsem{\Gamma;\ol\beta,\ol\gamma \vdash F}\rho[\ol{\gamma :=
    C}][\ol{\beta := B}]$.
  This interpretation gives $\dsem{\Gamma;\emptyset \,|\, \Delta
    \vdash \lambda x.t : F \to G}\rho = \curry
  (\dsem{\Gamma;\emptyset \,|\, \Delta, x : F \vdash t :
    G}\rho)$ and $\dsem{\Gamma;\emptyset \,|\, \Delta \vdash st:
    G} \rho = \eval \circ \langle \dsem{\Gamma;\emptyset \,|\,
    \Delta \vdash s: F \to G}\rho, \dsem{\Gamma;\emptyset
    \,|\, \Delta \vdash t: F}\rho \rangle$, so it specializes to
  the standard interpretations for System F terms.  If $t$ is closed,
  i.e., if $\emptyset; \emptyset~|~\emptyset \vdash t : F$, then we
  write $\dsem{\vdash t : F}$ instead of $\dsem{\emptyset;
    \emptyset~|~\emptyset \vdash t : F}$.
%, and similarly for $\relsem{\emptyset; \emptyset~|~\emptyset \vdash
%t : \tau}$.
Moreover, if
  $\Gamma,\alpha;\Phi \,|\, \Delta \vdash t : F$ and
  $\Gamma;\Phi,\alpha \,|\, \Delta \vdash t' : F$ and $\Gamma;\Phi
  \vdash G$ then
\begin{itemize}
\item $\setsem{\Gamma;\Phi \,|\, \Delta[\alpha := G] \vdash
  t[\alpha := G] : F[\alpha := G]}\rho =
  \setsem{\Gamma,\alpha;\Phi \,|\, \Delta \vdash t : F }\rho [
    \alpha := \setsem{\Gamma;\Phi\vdash G}\rho ]$
%\item $\relsem{\Gamma;\Phi \,|\, \Delta[\alpha := \sigma] \vdash
%  t[\alpha := \sigma] : \tau[\alpha := \sigma]}\rho =
%  \relsem{\Gamma,\alpha;\Phi \,|\, \Delta \vdash t : \tau }\rho [
%    \alpha := \relsem{\Gamma;\Phi\vdash\sigma}\rho ]$
\item $\setsem{\Gamma;\Phi \,|\, \Delta[\alpha := G] \vdash
  t'[\alpha := G] : F[\alpha := G]}\rho =
  \setsem{\Gamma;\Phi,\alpha \,|\, \Delta \vdash t' : F }\rho [
    \alpha := \setsem{\Gamma;\Phi\vdash G}\rho ]$
%\item $\relsem{\Gamma;\Phi \,|\, \Delta[\alpha := \sigma] \vdash
%  t'[\alpha := \sigma] : \tau[\alpha := \sigma]}\rho =
%  \relsem{\Gamma;\Phi,\alpha \,|\, \Delta \vdash t' : \tau }\rho [
%    \alpha := \relsem{\Gamma;\Phi\vdash\sigma}\rho ]$
\end{itemize}
and if $\Gamma;\Phi \,|\, \Delta, x: G \vdash t : F$ and
$\Gamma;\Phi \,|\, \Delta \vdash s : G$ then
\begin{itemize}
\item $\lambda A.\, \setsem{\Gamma;\Phi \,|\, \Delta \vdash t[x := s]
  : F }\rho \, A = \lambda A.\,\setsem{\Gamma;\Phi \,|\, \Delta, x:
  G \vdash t : F}\rho \,(A, \setsem{\Gamma;\Phi \,|\,
  \Delta\vdash s: G}\rho\, A)$
%\item $\lambda R.\,\relsem{\Gamma;\Phi \,|\, \Delta \vdash t[x := s] :
%  \tau }\rho\,R = \lambda R.\,\relsem{\Gamma;\Phi \,|\, \Delta, x:
%  \sigma \vdash t : \tau}\rho \,(R, \relsem{\Gamma;\Phi \,|\,
%  \Delta\vdash s: \sigma}\rho\,R)$
\end{itemize}
Direct calculation reveals that the set interpretations of terms also
satisfy
\begin{itemize}
\item $\setsem{\Gamma; \Phi~|~\Delta \vdash
  (L_{\ol{\alpha}}x.t)_{\ol{K}}s} = \setsem{\Gamma; \Phi~|~\Delta
  \vdash t [\ol{\alpha := K}][x := s]}$
\end{itemize}
Term extensionality with respect to types and terms --- i.e.,
$\setsem{\Gamma;\Phi\vdash (L_\alpha x.t)_\alpha \top : F} =
\setsem{\Gamma;\Phi \vdash t : F}$ and $\setsem{\Gamma;\Phi\vdash
  (L_\alpha x.t)_\alpha x : F} = \setsem{\Gamma;\Phi \vdash t : F}$
%$\relsem{\Gamma;\Phi\vdash (L_\alpha x.t)_\alpha t} =
%\relsem{\Gamma;\Phi \vdash t}$, as well as
%term extensionality
%and $\relsem{\Gamma;\Phi\vdash
%  (L_\alpha x.t)_\alpha \top} = \relsem{\Gamma;\Phi \vdash t}$
--- follow (when both sides of the equations are defined). Similar
properties hold for relational interpretations.

\subsection{Properties of Terms of $\Nat$-Type}\label{sec:Nat-type-terms}

Define, for $\Gamma; \ol{\alpha} \vdash F$, the term $\id_F$ to be
$\Gamma;\emptyset~|~\emptyset \vdash L_{\ol{\alpha}}x.x :
\Nat^{\ol{\alpha}} F\,F$ and, for terms $\Gamma; \emptyset \,|\,
\Delta \vdash t: \Nat^{\overline{\alpha}} F\,G$ and $\Gamma; \emptyset
\,|\, \Delta \vdash s: \Nat^{\overline{\alpha}} G\,H$, the {\em
  composition} $s \circ t$ of $t$ and $s$ to be $\Gamma;
\emptyset\,|\, \Delta \vdash L_{\overline{\alpha}}
x. s_{\overline{\alpha}}(t_{\overline{\alpha}}x):
\Nat^{\overline{\alpha}} F\,H$. Then $\setsem{\Gamma; \emptyset \,|\,
  \emptyset \vdash \id_{F} : \Nat^{\ol{\alpha}} F\,F} \rho\, \ast =
\id_{\lambda \ol{A}. \setsem{\Gamma; \ol{\alpha} \vdash F} \rho
  [\ol{\alpha := A}]}$ for any set environment $\rho$, and
$\setsem{\Gamma; \emptyset \,|\, \Delta \vdash s \circ t:
  \Nat^{\overline{\alpha}} F\,H} = \setsem{\Gamma; \emptyset \,|\,
  \Delta \vdash s: \Nat^{\overline{\alpha}} G\,H} \circ
\setsem{\Gamma; \emptyset \,|\, \Delta \vdash t:
  \Nat^{\overline{\alpha}} F\,G}$. Straightforward calculation shows
that terms of $\Nat$-type behave as natural transformations with
respect to their source and target functorial types, i.e., we have
\begin{thm}\label{eq:ft-from-nat} 
  If\, $\Gamma; \emptyset \,|\, \Delta \vdash s : \Nat^{\overline{\alpha},
  \overline{\gamma}} F\,G$ and $\overline{\Gamma; \emptyset \,|\,
  \Delta \vdash t : \Nat^{\overline{\gamma}} K\, H}$, then
  \[\begin{array}{l}
  \hspace*{0.135in}
\setsem{\Gamma; \emptyset\,|\, \Delta
  \vdash 
  ((\map_G^{\overline{K}, \overline{H}})_\emptyset \,\overline{t}) \circ
(L_{\overline{\gamma}} z. s_{\overline{K}, \overline{\gamma}}
  z)
  : \Nat^{\overline{\gamma}} F[\overline{\alpha := K}]\,
  G[\overline{\alpha := H}]}\\
= \setsem{ \Gamma; \emptyset \,|\, \Delta \vdash
(L_{\overline{\gamma}} z.
  s_{\overline{H}, \overline{\gamma}} z)\circ
  ((\map_F^{\overline{K}, \overline{H}})_\emptyset \,
  \overline{t})  : \Nat^{\overline{\gamma}} F[\overline{\alpha :=
      K}]\, G[\overline{\alpha := H}]}
\end{array}\]
\end{thm}
\noindent
When $s = \mathsf{in}_H$, and
$\overline{\Gamma; \emptyset \,|\, t :
 \Nat^{\overline{\gamma}} F\, G}$,
and $\xi = \Nat^{\overline{\gamma}} H[\phi :=
  (\mu \phi. \lambda \overline{\alpha}. H)
  \overline{\beta}][\overline{\alpha := F}]\, (\mu \phi. \lambda
\overline{\alpha}. H)\overline{G}$, Theorem~\ref{eq:ft-from-nat}
specializes to
\begin{equation}\label{thm:subst}
\begin{array}{l}
\hspace*{0.135in}\setsem{\Gamma; \emptyset \,|\, \Delta \vdash
((\map_{(\mu \phi. \lambda
    \overline{\alpha}. H) \overline{\beta}}^{\overline{F},
    \overline{G}})_\emptyset\, \overline{t}) \circ (L_{\overline{\gamma}} z.
  (\tin_{H})_{\overline{F},
    \overline{\gamma}} z) : \xi}\\
= \setsem{\Gamma; \emptyset \,|\, \Delta
\vdash (L_{\overline{\gamma}} z. (\tin_H)_{\overline{G},
  \overline{\gamma}} z) \circ
  ((\map_{H[\phi := (\mu \phi. \lambda \overline{\alpha}. H)
      \overline{\beta}]}^{\overline{F},
    \overline{G}})_\emptyset\, \overline{t})
  : \xi}
\end{array}
\end{equation}
\noindent
Theorem~\ref{eq:ft-from-nat} gives a family of free theorems that are
consequences of naturality, and thus do not require the full power of
parametricity. Other specific instances include the three
$\mathtt{map}$/$\mathtt{reverse}$ theorems from
Section~\ref{sec:intro}. The $\mathtt{map}$/$\mathtt{reverse}$ theorem
for bushes, e.g., is
\begin{align*}
  &\setsem{\emptyset; \emptyset~|~ y : \Nat^\emptyset F \, G
    \vdash ((\map_{\mathit{Bush}\,\alpha}^{{F},
      {G}}P)_\emptyset\, y) \circ (L_{{\emptyset}}
    z. \mathit{reverseBush}_{F}\, z) : \Nat^{{\emptyset}}
    (\mathit{Bush} \, F) \, (\mathit{Bush} \, G) }\\ =\;
  &\setsem{\emptyset; \emptyset~|~ y : \Nat^\emptyset F\, G
    \vdash (L_{\emptyset} z. \mathit{reverseBush}_{G}\,z) \circ
    ((\map_{\mathit{Bush} \, \alpha}^{F, G})_\emptyset\,
           {y}) : \Nat^{\emptyset} (\mathit{Bush} \, F ) \,
           (\mathit{Bush} \, G)}
\end{align*}
for any term $\vdash \mathit{reverseBush} : \Nat^\alpha (\mathit{Bush}
\,\alpha) \, (\mathit{Bush} \, \alpha)$. We can also prove a theorem
for the data type $\emptyset;\alpha,\gamma \vdash
\mathit{Tree}\,\alpha\,\gamma$ from Section~\ref{sec:calculus} that is
similar but only maps along some of its functorial variables:
%  \begin{align*}
%  &\setsem{\emptyset; \alpha~|~ y : \Nat^\emptyset \sigma \, \tau
%    \vdash ((\map_{\mathit{PTree}\,\alpha}^{{\sigma},
%      {\tau}})_{\emptyset} {y}) \circ (L_{{\emptyset}}
%    z. \mathit{reverse}_{\sigma} z) : \Nat^{{\emptyset}}
%    (\mathit{PTree} \, \sigma) \, (\mathit{PTree} \, \tau) }\\ =\;
%  &\setsem{\emptyset; \alpha~|~ y : \Nat^\emptyset \sigma \, \tau
%    \vdash (L_{\emptyset} z. \mathit{reverse}_{\tau} z) \circ
%    ((\map_{\mathit{PTree} \, \alpha}^{{\sigma}, {\tau}})_{\emptyset} {y}) :
%    \Nat^{\emptyset} (\mathit{PTree} \, \sigma ) \, (\mathit{PTree} \,
%    \tau)}
%\end{align*}
%for any term $\vdash \mathit{reverse} : \Nat^\alpha (\mathit{PTree}
%\,\alpha) \, (\mathit{PTree} \, \alpha)$,
if $\vdash \mathit{reverseTree} : \Nat^{\alpha, \gamma} (\mathit{Tree}
\,\alpha \, \gamma) \, (\mathit{Tree} \, \alpha \, \gamma)$ then
\begin{align*}
  &\setsem{\emptyset; \emptyset~|~y : \Nat^\gamma F \, G 
  \vdash  ((\map_{\mathit{Tree}\,\alpha \, \gamma}^{F,
      G})_\emptyset\, y) \circ (L_{{\gamma}} z. \mathit{reverseTree}_{F,
      \gamma}\, z) : \Nat^{{\gamma}} 
    (\mathit{Tree} \, F \, \gamma) \, (\mathit{Tree} \, G \,
    \gamma) }\\ =\; &\setsem{\emptyset; \emptyset~|~y :
    \Nat^\gamma F \, G \vdash (L_{\gamma}
    z. \mathit{reverseTree}_{G, \gamma}\,z) \circ
    ((\map_{\mathit{Tree} \, \alpha\, \gamma}^{{F},
      {G}})_\emptyset\, y) : \Nat^{\gamma} (\mathit{Tree} \,
    F \, \gamma) \, (\mathit{Tree} \, G\, \gamma)}
\end{align*}
\noindent
%Note this instance uses the following version of map:
%$$\map_{\mathit{Tree} \,\alpha \, \gamma}^{\sigma, \tau} : 
%\Nat^{\emptyset} (\Nat^\gamma \, \sigma \,\tau)\,
%(\Nat^\gamma(\mathit{Tree}\,\sigma\,\gamma)\,(\mathit{Tree}\,\tau\,\gamma))$$
%as opposed to 
%$$\map_{\mathit{Tree} \,\alpha \, \gamma}^{\sigma, \sigma', \tau, \tau'} : 
%\Nat^{\emptyset} ((\Nat^\emptyset \, \sigma \,\tau) \times
%(\Nat^\emptyset\,\sigma'\,\tau')) \,
%(\Nat^\emptyset\,(\mathit{Tree}\,\sigma\,\sigma')\,(\mathit{Tree}\,\tau\,\tau'))$$
We observed in Section~\ref{sec:calculus} that $ \phi; \alpha \vdash
\mathit{GRose}\,\phi\,\alpha$ cannot appear as the (co)domain of a
$\Nat$-type binding both $\phi$ and $\alpha$. As a result, there are
no instances of, say, a $\mathtt{map}$/$\mathtt{reverse}$ free theorem
for this data type that maps replacements for both $\phi$ and
$\alpha$. On the other hand, $\phi; \alpha \vdash
\mathit{GRose}\,\phi\,\alpha$ does support a
$\mathtt{map}$/$\mathtt{reverse}$ theorem that maps only a replacement
for $\alpha$.

As usual, analogous results hold for relation environments and
relational interpretations.

\subsection{Properties of Initial Algebraic Constructs}\label{sec:iaps}

Our semantics interprets applications of $\map$ as applications of
semantic $\mathit{map}$ functions.
\begin{comment}
Indeed, if \(\Gamma; \ol{\phi},
\ol{\gamma} \vdash H\), \(\ol{\Gamma; \emptyset, \ol{\gamma} \vdash
  F}\), and \(\ol{\Gamma; \Phi, \emptyset, \ol{\gamma} \vdash G}\),
%and $\Gamma;\Phi\,|\,\Delta \vdash t :
%\Nat^{\ol{\beta},\ol{\gamma}}\,F\,G$
then 
Definition~\ref{def:set-interp} gives
%\begin{multline}\label{eq:map-sem-def}
\begin{align}
& \setsem{
\Gamma;\Phi \,|\, \Delta
\vdash \map^{\ol{F},\ol{G}}_H \,\ol t
: %\Nat^\emptyset\;(\ol{\Nat^{\ol{\beta},\ol{\gamma}}\,F\,G})\; {}
\Nat^{\ol{\gamma}}\,H[\ol{\phi :=_{\ol{\beta}} F}]\,H[\ol{\phi :=_{\ol{\beta}} G}]
} \rho \nonumber \\ 
=\;\; & \lambda d\, \ol{\eta}\,\ol{B}.\,
\setsem{\Gamma; \ol{\phi},\ol{\gamma}\vdash H}
\id_{\rho[\ol{\gamma := B}]}[\ol{\phi := \lambda
    \ol{A}.\eta_{\ol{A}\,\ol{B}}}] \label{eq:map-sem-def}
\end{align}
%\end{multline}
\end{comment}
In particular, if $\Gamma; \ol{\alpha} \vdash H$, $\ol{\Gamma;
  \emptyset \vdash F}$, and $\ol{\Gamma; \emptyset \vdash G}$, then
Definition~\ref{def:set-interp} gives, for all $\ol{f :
  \setsem{\Gamma;\emptyset \vdash \Nat^\emptyset F\,G}\rho}$, that
\[\begin{array}{rl}
&\setsem{ \Gamma;\emptyset\,|\,\ol{x : \Nat^\emptyset F \, G}
  \vdash (\map^{\ol{F},\ol{G}}_H)_\emptyset\,\ol x :
  \Nat^{\emptyset}\,H[\ol{\alpha := F}]\,H[\ol{\alpha := G}]}
\rho\,\ol f\\ =& \setsem{\Gamma; \ol{\alpha}\vdash H}
\id_{\rho}[\ol{\alpha := f}] \\ =&
%\lambda \ol{f : \setsem{\Gamma; \emptyset \vdash \sigma}\rho \to \setsem{\Gamma%; \emptyset \vdash \tau}\rho}.\,
\mathit{map}_{\lambda \ol{A}.\,\setsem{\Gamma; \ol{\alpha}\vdash H} \rho [\ol{\alpha := A}]} \ol{f} \\
%=& \mathit{map}_{\lambda \ol{A}.\,\setsem{\Gamma; \ol{\alpha}\vdash H} \rho [\ol{\alpha := A}]}
\end{array}
\]
\begin{comment}
\[\begin{array}{rl}
&\setsem{
\Gamma;\emptyset \,|\, \emptyset
\vdash \map^{\ol{\sigma},\ol{\tau}}_H
: \Nat^\emptyset\;(\ol{\Nat^{\emptyset}\,\sigma\,\tau})\; {}
(\Nat^{\emptyset}\,H[\ol{\alpha := \sigma}]\,H[\ol{\alpha := \tau}])
} \rho\, \ast \\
=& \lambda \ol{f : \setsem{\Gamma; \emptyset \vdash \sigma}\rho \to \setsem{\Gamma; \emptyset \vdash \tau}\rho}.\,
\setsem{\Gamma; \ol{\alpha}\vdash H}
\id_{\rho}[\ol{\alpha := f}] \\
=& \lambda \ol{f : \setsem{\Gamma; \emptyset \vdash \sigma}\rho \to \setsem{\Gamma; \emptyset \vdash \tau}\rho}.\,
\mathit{map}_{\lambda \ol{A}.\,\setsem{\Gamma; \ol{\alpha}\vdash H} \rho [\ol{\alpha := A}]} \ol{f} \\
=& \mathit{map}_{\lambda \ol{A}.\,\setsem{\Gamma; \ol{\alpha}\vdash H} \rho [\ol{\alpha := A}]}
\end{array}
\]
\end{comment}

\vspace*{0.05in}

\noindent
Here, we obtain the first equality from the appropriate instance of
Definition~\ref{def:set-interp}, and the second one by noting that
$\lambda \ol{A}.\,\setsem{\Gamma; \ol{\alpha}\vdash H} \rho
[\ol{\alpha := A}]$ is a functor in $\alpha$ and using
$\mathit{map}_G\,\ol f$ to denote the action of the semantic functor
$G$ on morphisms $\ol f$.

\vspace*{0.1in}

We have the expected properties of the interpretations of $\map$,
$\tin$, and $\fold$, namely:

\vspace*{0.1in}

\noindent
$\bullet$\;  If
$\Gamma; \ol{\psi}, \ol{\gamma} \vdash H$,\;
$\ol{\Gamma; \ol{\alpha}, \ol{\gamma}, \ol{\phi} \vdash K}$,\;
$\ol{\Gamma; \ol{\beta}, \ol{\gamma} \vdash F}$,\; and
$\ol{\Gamma; \ol{\beta}, \ol{\gamma} \vdash G}$,
then
\[\setsem{\Gamma; \emptyset \,|\, \emptyset \vdash
\map_{H[\ol{\psi := K}]}^{\ol{F}, \ol{G}} : \xi} = \setsem{\Gamma;
  \emptyset \,|\, \emptyset \vdash L_\emptyset \ol
  z. (\map_H^{\ol{K[\ol{\phi := F}]}, 
    \ol{K[\ol{\phi := G}]}})_\emptyset \,(\ol{(\map_K^{\ol{F}, \ol{G}})_\emptyset \, \ol z}) :
  \xi}\]
for $\xi = \Nat^{\emptyset} (\ol{\Nat^{\ol{\alpha}, \ol{\beta},
    \ol{\gamma}} F\, G})\, (\Nat^{\ol{\gamma}} H[\ol{\psi :=
    K}][\ol{\phi := F}]\, H[\ol{\psi := K}][\ol{\phi := G}])$

\vspace*{0.18in}

\noindent
$\bullet$\; If $\Gamma; \overline{\beta}, \overline{\gamma} \vdash
H$,\; $\Gamma; \overline{\beta}, \overline{\gamma} \vdash K$,\;
$\overline{\Gamma; \overline{\alpha}, \overline{\gamma} \vdash F}$,\;
$\overline{\Gamma; \emptyset, \overline{\alpha}, \overline{\gamma}
  \vdash G}$,\; 
$\overline{\Gamma; \phi, \overline{\psi}, \overline{\gamma} \vdash
  M}$,\; $\overline{I}$ is the sequence $\overline{F}, H$,\;
$\overline{J}$ is the sequence $\overline{G}, K$, and $\Gamma;
\emptyset\,|\,\Delta \vdash s : \Nat^{\overline{\beta},
  \overline{\gamma}} H\, K$ and $\ol{\Gamma; \emptyset \,|\,\Delta \vdash
  t : \Nat^{\overline{\alpha}, \overline{\gamma}} F\, G}$, then
\[\hspace*{0.13in}\setsem{\Gamma; \emptyset \,|\, \Delta
    \vdash L_{\overline{\gamma}} z.\,
    s_{\overline{M [\overline{\psi := G}] [\phi := K]},
      \overline{\gamma}} \Big(\big( (\map_{H}^{\overline{M
        [\overline{\psi := F}] [\phi := H]}, \overline{M
        [\overline{\psi := G}] [\phi := K]}})_\emptyset
    (\overline{(\map_{M}^{\overline{I}, \overline{J}})_\emptyset
      (s, \overline{t})}) \big)_{\overline{\gamma}} z \Big) : \xi}\]
\[= \setsem{\Gamma; \emptyset\,|\, \Delta \vdash
    L_{\overline{\gamma}} z.\, \big( (\map_{K}^{\overline{M
      [\overline{\psi := F}] [\phi := H]}, \overline{M [\overline{\psi
          := G}] [\phi := K]}})_\emptyset (\overline{(\map_{M}^{\overline{I},
    \overline{J}})_\emptyset (s, \overline{t})}) \big)_{\overline{\gamma}} \Big(
s_{\overline{M [\overline{\psi := F}] [\phi := H]}, \overline{\gamma}}
z \Big) : \xi}\] for $\xi = \Nat^{\overline{\gamma}}\,
  H[\overline{\beta:= M}] [\overline{\psi := F}] [\phi := H]\;
  K[\overline{\beta := M}] [\overline{\psi := G}] [\phi := K]$

\vspace*{0.18in}

\noindent
$\bullet$\; If $\xi = \Nat^{\overline{\beta}, \overline{\gamma}}\,
H[\phi := (\mu \phi. \lambda
  \overline{\alpha}. H)\overline{\beta}][\overline{\alpha := \beta}]\;
F$, then
\[\hspace*{-0.72in}\setsem{\Gamma; \emptyset \,|\, x:
  \Nat^{\overline{\beta}, \overline{\gamma}} H[\phi :=
    F][\overline{\alpha := \beta}]\, F \vdash ((\fold_{H,
    F})_{\emptyset} x) \circ \tin_{H} : \xi}\]

\vspace*{-0.15in}

\[= \setsem{ \Gamma; \emptyset \,|\, x: \Nat^{\overline{\beta},
    \overline{\gamma}} H[\phi := F][\overline{\alpha := \beta}]\, F
  \vdash x \circ \big( (\map_{H [\ol{\alpha := \beta}]}^{(\mu
    \phi. \lambda \overline{\alpha} H) \overline{\beta},
    F})_\emptyset ((\fold_{H, F})_{\emptyset} x) \big) : \xi}\]

\vspace*{0.1in}

\noindent
$\bullet$\; If $\xi = \Nat^{\overline{\beta}, \overline{\gamma}}\, (\mu
\phi. \lambda \overline{\alpha}. H)\overline{\beta}\; (\mu
\phi. \lambda \overline{\alpha}. H)\overline{\beta}$, then
\[\setsem{\Gamma; \emptyset \,|\, \emptyset
  \vdash \tin_H \circ (\fold_{H, H[\phi := (\mu \phi. \lambda
      \overline{\alpha}. H)\overline{\beta}]})_{\emptyset}
  ((\map_{H}^{H[\phi := (\mu \phi. \lambda
      \overline{\alpha}. H)\overline{\beta}][\overline{\alpha :=
        \beta}], (\mu \phi. \lambda
    \overline{\alpha}. H)\overline{\beta}})_\emptyset \tin_H) :
  \xi}\]

\vspace*{-0.15in}

\[\hspace*{-3.46in} = \setsem{\Gamma; \emptyset \,|\, \emptyset \vdash \mathit{id}_{(\mu
    \phi. \lambda \overline{\alpha}. H)\overline{\beta}} : \xi}\]

\vspace*{0.15in}

\noindent
$\bullet$\; If $\xi = \Nat^{\overline{\beta}, \overline{\gamma}}
H[\phi := (\mu \phi. \lambda \overline{\alpha}. H)\overline{\beta}]\,
H[\phi := (\mu \phi. \lambda \overline{\alpha}. H)\overline{\beta}]$,
then
\[\setsem{\Gamma; \emptyset \,|\, \emptyset \vdash
(\fold_{H, H[\phi := (\mu \phi. \lambda
      \overline{\alpha}. H)\overline{\beta}]})_{\emptyset}
  ((\map_{H}^{H[\phi := (\mu \phi. \lambda
      \overline{\alpha}. H)\overline{\beta}][\overline{\alpha :=
        \beta}], (\mu \phi. \lambda
    \overline{\alpha}. H)\overline{\beta}})_\emptyset \tin_H) \circ
  \tin_H : \xi}\]

\vspace*{-0.15in}

\[\hspace*{-3.15in} =\setsem{ \Gamma; \emptyset \,|\, \emptyset \vdash
  \mathit{id}_{H[\phi := (\mu \phi. \lambda
      \overline{\alpha}. H)\overline{\beta}]} : \xi}\]

\vspace*{0.1in}

\noindent
Analogous results hold for relational interpretations of terms and
relational environments.

\begin{comment}
\subsection{Free Theorems Derived from Naturality}\label{sec:ft-nat}

In our setting, free theorems of a certain familiar form are derivable
directly from the semantic properties of $\Nat$-types. Indeed, the
following theorem is immediate from Equation~\ref{thm:subst}, by taking
$\gamma$ to be empty, expanding the interpretations on the left- and
right-hand sides, and using the fact from Section~\ref{sec:iaps} that
$\map$ terms are interpreted as semantic $\mathit{map}$ functions:
\begin{thm}\label{thm:ft-nat}
If\, $\Gamma; \ol\alpha \vdash F : \F$,\, $\Gamma; \ol\alpha \vdash G :
\F$, $\rho : \setenv$, $x \in \setsem{\Gamma; \emptyset \vdash
  \Nat^{\ol\alpha} F\, G } \rho$, and, for vectors of length
$|\ol\alpha|$, \, $\ol{\Gamma; \emptyset \vdash \sigma : \F}$,\,
$\ol{\Gamma; \emptyset \vdash \tau: \F}$, and $\ol{y \in
  \setsem{\Gamma; \emptyset \vdash \Nat^{\emptyset} \sigma\, \tau }
  \rho}$, then
\[\mathit{map}_{\setsem{\Gamma; \ol\alpha \vdash G} \rho[\ol{\alpha := \_}]} \ol{y}
  \circ x_{\ol{{\setsem{\Gamma; \emptyset \vdash \sigma} \rho}}} =
  x_{\ol{\setsem{\Gamma; \emptyset \vdash \tau} \rho} } \circ
  \mathit{map}_{\setsem{\Gamma; \ol\alpha \vdash F} \rho[\ol{\alpha :=
        \_}]} \, \ol{y}\]
\end{thm}
\noindent
%INCORRECT
%In particular, for $\ol{A, B: \set}$, variables $\ol{v}$ and $\ol{w}$
%with $\ol{\rho v = A}$ and $\ol{\rho w = B}$, and functions $\ol{f : A
%  \to B}$, the following holds: $\mathit{map}_{\setsem{\Gamma; \ol\alpha \vdash G}
%  \rho[\ol{\alpha := \_}]} \ol{f} \circ x_{\ol{A}} = x_{\ol{B}} \circ
%\mathit{map}_{\setsem{\Gamma; \ol\alpha \vdash F} \rho[\ol{\alpha :=
%      \_}]} \, \ol{f}$.
A similar result holds for relational interpretations.

Specific instances of Theorem~\ref{thm:ft-nat} include {\color{blue}
  Wadler free theorems, map-reverse theorems from intro, ???}
\end{comment}

\begin{comment}
We already know from Equation~\ref{thm:subst} that 
\begin{multline}
\setsem{\Gamma; \emptyset \,|\, x :
  \Nat^{\overline{\alpha}, 
    \overline{\gamma}} F\,G, \overline{y : \Nat^{\overline{\gamma}}
    \sigma\, \tau} \vdash ((\map_G^{\overline{\sigma},
    \overline{\tau}})_{\emptyset} \overline{y}) \circ
  (L_{\overline{\gamma}} z. x_{\overline{\sigma}, \overline{\gamma}}
  z) : \Nat^{\overline{\gamma}} F[\overline{\alpha := \sigma}]\,
  G[\overline{\alpha := \tau}]} \\
= \setsem{ \Gamma; \emptyset \,|\, x
  : \Nat^{\overline{\alpha}, \overline{\gamma}} F\, G, \overline{y :
    \Nat^{\overline{\gamma}} \sigma\, \tau} \vdash
  (L_{\overline{\gamma}} z. x_{\overline{\tau}, \overline{\gamma}} z)
  \circ ((\map_F^{\overline{\sigma}, \overline{\tau}})_{\emptyset}
  \overline{y}) : \Nat^{\overline{\gamma}} F[\overline{\alpha :=
      \sigma}]\, G[\overline{\alpha := \tau}]}
\end{multline}

In particular, for any set environment $\rho$, natural transformation 
$x \in \setsem{\Gamma; \emptyset \vdash \Nat^{\ol\alpha} F\, G } \rho$, and functions
$\ol{y \in \setsem{\Gamma; \emptyset \vdash \Nat^{\emptyset} \sigma\, \tau } \rho}$
(thus specializing to the case where there are no $\gamma$’s), we have
\begin{multline}
\setsem{\Gamma; \emptyset \,|\, x :
  \Nat^{\overline{\alpha}} F\,G, \overline{y : \Nat^{\emptyset}
    \sigma\, \tau} \vdash ((\map_G^{\overline{\sigma},
    \overline{\tau}})_{\emptyset} \overline{y}) \circ
  (L_{\emptyset} z. x_{\overline{\sigma}}
  z) : \Nat^{\emptyset} F[\overline{\alpha := \sigma}]\,
  G[\overline{\alpha := \tau}]} \rho (x, \ol{y}) \\
= \setsem{ \Gamma; \emptyset \,|\, x
  : \Nat^{\overline{\alpha}} F\, G, \overline{y :
    \Nat^{\emptyset} \sigma\, \tau} \vdash
  (L_{\emptyset} z. x_{\overline{\tau}} z)
  \circ ((\map_F^{\overline{\sigma}, \overline{\tau}})_{\emptyset}
  \overline{y}) : \Nat^{\emptyset} F[\overline{\alpha :=
      \sigma}]\, G[\overline{\alpha := \tau}]} \rho (x, \ol{y})
\end{multline}

Unwinding these interpretations yields
\begin{multline}
\setsem{\Gamma; \emptyset \,|\, x :
  \Nat^{\overline{\alpha}} F\,G, \overline{y : \Nat^{\emptyset}
    \sigma\, \tau} \vdash ((\map_G^{\overline{\sigma},
    \overline{\tau}})_{\emptyset} \overline{y}) \circ
  (L_\emptyset z. x_{\overline{\sigma}}
  z) : \Nat^{\emptyset} F[\overline{\alpha := \sigma}]\,
  G[\overline{\alpha := \tau}]} \rho \, (x , \ol{y}) \\
= 
\setsem{\Gamma; \emptyset \,|\, x : \Nat^{\overline{\alpha}} F\,G, 
  \overline{y : \Nat^{\emptyset}
    \sigma\, \tau} \vdash (\map_G^{\overline{\sigma},
    \overline{\tau}})_{\emptyset} \overline{y} } \rho \, (x, \ol{y})
   \circ
  \setsem{\Gamma; \emptyset \,|\, x : \Nat^{\overline{\alpha}} F\,G 
   , \overline{y : \Nat^{\emptyset}
      \sigma\, \tau} \vdash
   L_{\emptyset} z. x_{\overline{\sigma}}
  z } \rho \, (x, \ol{y}) \\
= 
\setsem{\Gamma; \emptyset \,|\, \overline{y : \Nat^{\emptyset}
    \sigma\, \tau} \vdash (\map_G^{\overline{\sigma},
    \overline{\tau}})_{\emptyset} \overline{y} } \rho \, \ol{y}
   \circ
  \setsem{\Gamma; \emptyset \,|\, x : \Nat^{\overline{\alpha}} F\,G \vdash
    L_{\emptyset} z. x_{\overline{\sigma}}
  z } \rho \, x \\
= \map_{\setsem{\Gamma; \ol\alpha \vdash G} \rho[\ol{\alpha := \_}]} \ol{y}
  \circ 
  x_{\ol{{\setsem{\Gamma; \emptyset \vdash \sigma} \rho}}}
\end{multline}


and 
\begin{multline}
\setsem{ \Gamma; \emptyset \,|\, x
  : \Nat^{\overline{\alpha}} F\, G, \overline{y :
    \Nat^{\emptyset} \sigma\, \tau} \vdash
  (L_{\emptyset} z. x_{\overline{\tau}} z)
  \circ ((\map_F^{\overline{\sigma}, \overline{\tau}})_{\emptyset}
  \overline{y}) : \Nat^{\emptyset} F[\overline{\alpha :=
      \sigma}]\, G[\overline{\alpha := \tau}]} \rho (x, \ol{y}) \\
=
\setsem{ \Gamma; \emptyset \,|\, x
  : \Nat^{\overline{\alpha}} F\, G, \overline{y :
    \Nat^{\emptyset} \sigma\, \tau} \vdash
  L_{\emptyset} z. x_{\overline{\tau}} z)} \rho (x, \ol{y})
  \circ 
  \setsem{\Gamma; \emptyset
  \,|\, x : \Nat^{\overline{\alpha}} F\, G, \overline{y :
    \Nat^{\emptyset} \sigma\, \tau} \vdash 
  (\map_F^{\overline{\sigma}, \overline{\tau}})_{\emptyset}
  \overline{y} } \rho (x, \ol{y}) \\
= \setsem{\Gamma; \emptyset \,|\, x
  : \Nat^{\overline{\alpha}} F\, G \vdash 
  L_{\emptyset} z. x_{\overline{\tau}} z} \rho \, x
  \circ 
  \setsem{\Gamma;\emptyset \,|\, \overline{y :
    \Nat^{\emptyset} \sigma\, \tau} \vdash
    (\map_F^{\overline{\sigma}, \overline{\tau}})_{\emptyset}
  \overline{y} } \rho \, \ol{y}  \\
  = x_{\ol{\setsem{\Gamma; \emptyset \vdash \tau} \rho} }
  \circ \map_{\setsem{\Gamma; \ol\alpha \vdash F} 
    \rho[\ol{\alpha := \_}]} \, \ol{y}
\end{multline}


So, we can conclude that
\begin{equation}
\map_{\setsem{\Gamma; \ol\alpha \vdash G} \rho[\ol{\alpha := \_}]} \ol{y}
  \circ 
  x_{\ol{{\setsem{\Gamma; \emptyset \vdash \sigma} \rho}}}
= x_{\ol{\setsem{\Gamma; \emptyset \vdash \tau} \rho} }
\circ \map_{\setsem{\Gamma; \ol\alpha \vdash F} 
  \rho[\ol{\alpha := \_}]} \, \ol{y}
\end{equation}

Moreover, for any $\ol{A, B: \set}$,
we can choose $\ol{\sigma = v}$ and $\ol{\tau = w}$ to be variables such that
$\ol{\rho v = A}$ and $\ol{\rho w = B}$.
Then for any functions $\ol{f : A \to B}$ we have that
\begin{equation}
\map_{\setsem{\Gamma; \ol\alpha \vdash G} \rho[\ol{\alpha := \_}]} \ol{f}
  \circ 
  x_{\ol{A}}
  = x_{\ol{B}}
\circ \map_{\setsem{\Gamma; \ol\alpha \vdash F} 
  \rho[\ol{\alpha := \_}]} \, \ol{f}
\end{equation}
\end{proof}
\end{comment}

\subsection{The Abstraction Theorem}\label{sec:thms} 

To go beyond naturality and get {\em all} consequences of
parametricity, we prove an Abstraction Theorem for our calculus. As
usual for such theorems, we prove a more general result in
Theorem~\ref{thm:at-gen} that handles possibly open terms. We then
recover the Abstraction Theorem (Theorem~\ref{thm:abstraction}) as the
special case Theorem~\ref{thm:at-gen} for closed terms of closed type.

\begin{thm}\label{thm:at-gen}
Every well-formed term $\Gamma;\Phi~|~\Delta \vdash t : F$ induces
a natural transformation from $\sem{\Gamma; \Phi \vdash \Delta}$ to
$\sem{\Gamma; \Phi \vdash F}$, i.e., a triple of natural
transformations 
\[(\setsem{\Gamma;\Phi~|~\Delta \vdash t : F},\,
\setsem{\Gamma;\Phi~|~\Delta \vdash t : F},\,
\relsem{\Gamma;\Phi~|~\Delta \vdash t : F})\]
where
\[\begin{array}{lll}
\setsem{\Gamma;\Phi~|~\Delta \vdash t : F} & : & \setsem{\Gamma;
  \Phi \vdash \Delta} \to \setsem{\Gamma; \Phi \vdash F}
\end{array}\]
has as its component at $\rho : \setenv$ a morphism
\[\begin{array}{lll}
\setsem{\Gamma;\Phi~|~\Delta \vdash t : F}\rho & : & \setsem{\Gamma;
  \Phi \vdash \Delta}\rho \to \setsem{\Gamma; \Phi \vdash F}\rho
\end{array}\]
in $\set$,
\[\begin{array}{lll}
\relsem{\Gamma;\Phi~|~\Delta \vdash t : F} & : & \relsem{\Gamma;
  \Phi \vdash \Delta} \to \relsem{\Gamma; \Phi \vdash F}
\end{array}\]
has as its component at $\rho : \relenv$ a morphism
\[\begin{array}{lll}
\relsem{\Gamma;\Phi~|~\Delta \vdash t : F}\rho & : & \relsem{\Gamma;
  \Phi \vdash \Delta}\rho \to \relsem{\Gamma; \Phi \vdash F}\rho
\end{array}\]
in $\rel$,
and, for all $\rho : \relenv$,
\begin{equation}\label{eq:projs}
\relsem{\Gamma;\Phi~|~\Delta \vdash t : F}\rho =
(\setsem{\Gamma;\Phi~|~\Delta \vdash t : F}(\pi_1 \rho),\,
\setsem{\Gamma;\Phi~|~\Delta \vdash t : F}(\pi_2 \rho))
\end{equation}
\end{thm}
\begin{proof}
By structural induction on the type judgment for $t$. The overall
challenge of our development manifests in this proof. It lies in
showing that the set and relational interpretations of each term
judgment are natural transformations, and that all set interpretations
of terms of $\Nat$-types satisfy the appropriate equality preservation
conditions from Definition~\ref{def:set-sem}.  For the interesting
cases of abstraction, application, $\map$, $\tin$, and $\fold$ terms,
propagating the naturality conditions is quite involved; the latter
two cases especially require some rather delicate diagram
chasing. That this is possible provides strong evidence that our
definitions and development are sensible, natural, and at an
appropriate level of abstraction. Detailed proofs for the set
interpretations for the five interesting forms of terms are included
in the accompanying anonymous supplementary material. Even in the
supplementary material we omit the other, straightforward, cases.  The
proofs for the relational interpretations of all term judgments are
entirely analogous to the proofs for their set interpretations. The
proof that Equation~\ref{eq:projs} holds in each case is by direct
calculation, using the facts that projections are surjective and that
the set and relational interpretations are defined ``in parallel'',
i.e., are fibred.
\end{proof}

The following theorem is an immediate consequence of
Theorem~\ref{thm:at-gen}:
\begin{thm}\label{thm:at-gen-rel}
If \,$\Gamma; \Phi \,|\, \Delta \vdash t : F$ and \,$\rho \in \relenv$,
  and if \,$(a, b) \in \relsem{\Gamma; \Phi \vdash \Delta} \rho$,
  then \\
  $(\setsem{\Gamma; \Phi \,|\, \Delta \vdash t : F} (\pi_1 \rho) \,a \, ,
      \setsem{\Gamma; \Phi \,|\, \Delta \vdash t : F } (\pi_2 \rho) \,b) \in 
    \relsem{\Gamma; \Phi \vdash F} \rho$
\end{thm}
\noindent
Finally, the Abstraction Theorem is the instantiation of
Theorem~\ref{thm:at-gen-rel} to closed terms of closed type:
\begin{thm}[Abstraction Theorem]\label{thm:abstraction}
If $\vdash t : F$, then $(\setsem{\vdash t : F},\setsem{\vdash t
  : F}) \in \relsem{\vdash F}$.
\end{thm}

\section{Free Theorems for Nested Types}\label{sec:ftnt}

In this section we show how Theorem~\ref{thm:abstraction} can be used
to prove more advanced free theorems than those of
Section~\ref{sec:Nat-type-terms} in the presence of directly
constructed nested types.

\subsection{Free Theorem for Type of Polymorphic
  Bottom}\label{sec:bottom} 

Suppose $ \vdash g : \Nat^\alpha \,\onet\,\alpha$, let $G^\set =
\setsem{\vdash g : \Nat^\alpha \,\onet\,\alpha}$, and let $G^\rel =
\relsem{\vdash g : \Nat^\alpha \,\onet\,\alpha}$.  By
Theorem~\ref{thm:at-gen}, $(G^\set(\pi_1\rho),G^\set(\pi_2\rho))
= G^\rel\rho$. Thus, for all $\rho \in \relenv$ and any $(a, b) \in
\relsem{\vdash \emptyset}\rho = 1$, eliding the only possible
instantiations of $a$ and $b$ gives that
%\[\begin{array}{lll}
$(G^\set,G^\set) \;= \; (G^\set(\pi_1 \rho), G^\set (\pi_2 \rho))$
$ \in  \relsem{\vdash \Nat^\alpha \,\onet\,\alpha}\rho$
$ =  \{\eta : K_1 \Rightarrow \id\}$
$ =  \{(\eta_1 : K_1 \Rightarrow \id, \eta_2 : K_1 \Rightarrow
\id)\}$ 
%\end{array}\]
That is, $G^\set$ is a natural transformation from the constantly
$1$-valued functor to the identity functor in $\set$. In particular,
for every $S : \set$, $G^\set_S : 1 \to S$. Note, however, that if $S
= \emptyset$, then there can be no such morphism, so no such natural
transformation,
%in $\set$,
and thus no term $\vdash g : \Nat^\alpha \onet \,\alpha$, can exist.
%in our calculus.
That is, our calculus admits no non-terminating terms, i.e., terms
with the closed type $\Nat^\alpha \onet \,\alpha$ of the polymorphic
bottom.

\subsection{Free Theorem for Type of Polymorphic
  Identity}\label{sec:identity} 

Suppose $ \vdash g : \Nat^\alpha \,\alpha\,\alpha$, let $G^\set =
\setsem{\vdash g : \Nat^\alpha \,\alpha\,\alpha}$, and let $G^\rel =
\relsem{\vdash g : \Nat^\alpha \,\alpha\,\alpha}$.  By
Theorem~\ref{thm:at-gen}, $(G^\set(\pi_1\rho),G^\set(\pi_2\rho))
= G^\rel\rho$. Thus, for all $\rho \in \relenv$ and any $(a, b) \in
\relsem{\vdash \emptyset}\rho = 1$, eliding the only possible
instantiations of $a$ and $b$ gives that
%\[\begin{array}{lll}
$(G^\set, G^\set) \; = \; (G^\set(\pi_1 \rho), G^\set (\pi_2 \rho))$
$ \in \relsem{\vdash \Nat^\alpha \,\alpha\,\alpha}\rho$
$ =  \{\eta : \id \Rightarrow \id\}$
$ =  \{(\eta_1 : \id \Rightarrow \id, \eta_2 : \id \Rightarrow
\id)\}$
%\end{array}\]
That is, $G^\set$ is a natural transformation from the identity
functor on $\set$ to itself. Now let $S$ be any set.  If $S =
\emptyset$, then there is exactly one morphism $\id_S: S \to S$, so
$G^\set_S : S \to S$ must be $\id_S$. If $S \not = \emptyset$, if
$a$ is any element of $S$, and if $K_a :S \to S$ is the constantly
$a$-valued morphism on $S$, then instantiating the naturality square
implied by the above equality gives that $G^\set_S \circ K_a = K_a
\circ G^\set_S$, i.e., $G^\set_S \, a = a$, i.e., $G^\set_S = \id_S$.
Putting these two cases together we have that for every $S : \set$,
$G^\set_S = \id_S$, i.e., $G^\set$ is the identity natural
transformation for the identity functor on $\set$. So every closed
term $g$ of closed type $\Nat^\alpha\alpha\,\alpha$ always denotes the
identity natural transformation for the identity functor on $\set$,
i.e., every closed term $g$ of type $\Nat^\alpha\alpha\,\alpha$
denotes the polymorphic identity function.

\subsection{Standard Free Theorems for ADTs and Their Analogues for
  Nested types}\label{sec:ft-adt}

We can derive in our calculus even those free theorems for polymorphic
functions over ADTs that are not consequences of naturality.  We can,
e.g., prove the free theorem for $\mathit{filter}$'s type as follows:

%\begin{lemma}\label{lem:list-graph}
%If $g : A \to B$, $\rho : \relenv$, and $\rho\alpha = (A, B,
%\graph{g})$, then $\relsem{\alpha; \emptyset \vdash List \, \alpha}
%\rho = \graph{map_{\mathit{List}} \, g}$.
%\end{lemma}
%\begin{proof}
%The result follows by straightforward calculation using
%Definition~\ref{def:rel-sem} and Equation~\ref{eq:mu}, together with
%the facts that $\mathit{List} \,(A, B, \graph{g}) =
%\graph{\mathit{map}_{\mathit{List}} \,g}$ and, if $H = \onet + \beta
%\times\phi \beta$ {\color{blue} Why not $H = \onet + \alpha \times
%  \beta$? Does it matter?}, then $(T_{H,\rho}^n K_0)^* R =
%\Sigma_{i=0}^n R^i$ for all $n \in \nat$ and $R \in \rel$ by induction
%on $n$.
%\end{proof}

\begin{thm} 
If $g : A \to B$, $\rho : \relenv$, $\rho \alpha = (A, B, \graph{g})$,
$(a, b) \in \relsem{\alpha ;\emptyset \vdash \Delta} \rho$, $(s \circ
g, s) \in \relsem{\alpha; \emptyset \vdash \Nat^\emptyset \alpha \,
  \mathit{Bool}} \rho$, and % for $s : A \to \mathit{Bool}$, and
%$\alpha; \emptyset \,|\, \Delta \vdash t :
%\filtype$, if
$\mathit{filter} = \setsem{\alpha; \emptyset \,|\, \Delta \vdash t :
  \filtype}$ for some $t$, then
\[  \mathit{map}_{\mathit{List}} \,g \circ \mathit{filter} \, (\pi_1
\rho) \, a \, (s \circ g) = \mathit{filter}\, (\pi_2\rho) \, b \, s
\circ \mathit{map}_{\mathit{List}} \,g\]
\end{thm}
\begin{proof}
By Theorem~\ref{thm:at-gen-rel}, \[(\mathit{filter}\, (\pi_1 \rho)\, a,
\mathit{filter}\, (\pi_2 \rho)\, b) \in \relsem{\alpha; \emptyset
  \vdash \filtype} \rho\] so if $(s', s) \in \relsem{\alpha; \emptyset
  \vdash \Nat^\emptyset \alpha \, \mathit{Bool}} \rho = \rho\alpha \to
\Eq_{\mathit{Bool}}$ and $(xs', xs) \in \relsem{\alpha; \emptyset
  \vdash List \, \alpha} \rho$ then
% then
%  \begin{align*}
%    (t (\pi_1 \rho) \,a \,s, t (\pi_2 \rho) \,b \,s') &\in \relsem{\alpha; \emptys%et \vdash \Nat^\emptyset (List \, \alpha) \, (List \, \alpha)} \rho \\
%   &= \relsem{\alpha; \emptyset \vdash List \, \alpha} \rho \to \relsem{\alpha; \e%mptyset \vdash List \, \alpha} \rho \\
%  \end{align*}
%  So if $(xs, xs') \in \relsem{\alpha; \emptyset \vdash List \, \alpha} \rho$ then,
\begin{equation}\label{eq:filter-thm-list}
  (\mathit{filter}\, (\pi_1\rho) \,a \,s' \,xs', \mathit{filter} \,
  (\pi_2\rho) \,b \,s \,xs) \in \relsem{\alpha; \emptyset \vdash
    \mathit{List} \, \alpha} \rho
\end{equation}
If $\rho\alpha = (A, B, \graph{g})$, then $\relsem{\alpha; \emptyset
  \vdash \mathit{List} \, \alpha} \rho =
\graph{\mathit{map}_{\mathit{List}} \, g}$ by Lemma~\ref{lem:graph}
and Equation~\ref{thm:demotion-objects}.  Moreover, $xs =
\mathit{map}_{\mathit{List}} \,g \,xs'$ and $(s', s) \in \graph{g} \to
\Eq_{\mathit{Bool}}$, so $s' = s \circ g$. The result
follows from % Instantiating
Equation~\ref{eq:filter-thm-list}.\end{proof}
%gives the result.
% \begin{align*}
%    &(t (\pi_1\rho) \,a \,(s' \circ g) \,xs, t (\pi_2\rho) \,b \,s' \,(\mathit{map%}_{\mathit{List}} \,g \,xs)) \in \graph{\mathit{map}_{\mathit{List}} \,g}, \\ 
%    & i.e., \\ 
%    &\mathit{map}_{\mathit{List}} \,g \, (t (\pi_1\rho) \,a \,(s' \circ g) \,xs) =% t (\pi_2\rho) \,b \,s' \,(\mathit{map}_{\mathit{List}} \,g \,xs), \\ 
%    & i.e., \\
%    &\mathit{map}_{\mathit{List}} \,g \circ t (\pi_1 \rho) \, a \, (s' \circ g) = %t (\pi_2\rho) \, b \, s' \circ \mathit{map}_{\mathit{List}} \,g
%  \end{align*}
%  as desired.
%\end{proof}

\begin{comment}
\begin{thm}\label{thm:at-gen-rel}
If \,$\Gamma; \Phi \,|\, \Delta \vdash t : \tau$ and \,$\rho \in \relenv$,
  and if \,$(a, b) \in \relsem{\Gamma; \Phi \vdash \Delta} \rho$,
  then \\
  $(\setsem{\Gamma; \Phi \,|\, \Delta \vdash t : \tau} (\pi_1 \rho) \,a \, ,
      \setsem{\Gamma; \Phi \,|\, \Delta \vdash t : \tau } (\pi_2 \rho) \,b) \in 
    \relsem{\Gamma; \Phi \vdash \tau} \rho$
\end{thm}
\begin{proof}
 Immediate from Theorem~\ref{thm:at-gen}.
\end{proof}
\end{comment}

\begin{comment}
\begin{thm} 
  If $g : A \to B$, 
  $\rho : \relenv$, 
  $\rho \alpha = (A, B, \graph{g})$,
  $(a, b) \in \relsem{\alpha ;\emptyset \vdash \Delta} \rho$, 
  $(s \circ g, s) \in \relsem{\alpha; \emptyset \vdash \Nat^\emptyset \alpha \, \mathit{Bool}} \rho$,
  and, for some well-formed term $\mathit{filter}$, \\
  $$t = \setsem{\alpha; \emptyset \,|\, \Delta \vdash \mathit{filter} : \filtype} \emph{, then }$$
  \begin{align*}
  \mathit{map}_{\mathit{List}} \,g \circ t (\pi_1 \rho) \, a \, (s \circ g) = t (\pi_2\rho) \, b \, s \circ \mathit{map}_{\mathit{List}} \,g
  \end{align*}
\end{thm}
\begin{proof}
  By Theorem~\ref{thm:at-gen-rel},
  $(t (\pi_1 \rho) a, t (\pi_2 \rho) b) \in \relsem{\alpha; \emptyset \vdash \filtype} \rho$.
  Thus if 
  $(s, s') \in \relsem{\alpha; \emptyset \vdash \Nat^\emptyset \alpha \, \mathit{Bool}} \rho = \rho\alpha \to \Eq_{\mathit{Bool}}$,
  then 
  \begin{align*}
    (t (\pi_1 \rho) \,a \,s, t (\pi_2 \rho) \,b \,s') &\in \relsem{\alpha; \emptyset \vdash \Nat^\emptyset (List \, \alpha) \, (List \, \alpha)} \rho \\
   &= \relsem{\alpha; \emptyset \vdash List \, \alpha} \rho \to \relsem{\alpha; \emptyset \vdash List \, \alpha} \rho \\
  \end{align*}
  So if $(xs, xs') \in \relsem{\alpha; \emptyset \vdash List \, \alpha} \rho$ then,
  \begin{equation}\label{eq:filter-thm}
  (t (\pi_1\rho) \,a \,s \,xs, t (\pi_2\rho) \,b \,s' \,xs') \in \relsem{\alpha; \emptyset \vdash List \, \alpha} \rho
  \end{equation}

  Consider the case in which $\rho\alpha = (A, B, \graph{g})$. Then $\relsem{\alpha; \emptyset \vdash List \, \alpha} \rho
  = \graph{\mathit{map}_{\mathit{List}} \, g}$, by Lemma~\ref{lem:list-graph}, and $(xs, xs') \in \graph{\mathit{map}_{\mathit{List}} \,g}$ 
  implies $xs' = \mathit{map}_{\mathit{List}} \,g \,xs$. We also have that 
  $(s, s') \in \graph{g} \to \Eq_{\mathit{Bool}}$ implies 
  $\forall (x, g x) \in \graph{g}. \,\, s x = s' (g x)$ and thus
  $s = s' \circ g$ due to the definition of morphisms between relations.
  %% TODO show (s, s') \in <g> -> \mathit{Bool} implies s = s' \circ g %% 
  With these instantiations, Equation~\ref{eq:filter-thm} becomes
  \begin{align*}
    &(t (\pi_1\rho) \,a \,(s' \circ g) \,xs, t (\pi_2\rho) \,b \,s' \,(\mathit{map}_{\mathit{List}} \,g \,xs)) \in \graph{\mathit{map}_{\mathit{List}} \,g}, \\ 
    & i.e., \\ 
    &\mathit{map}_{\mathit{List}} \,g \, (t (\pi_1\rho) \,a \,(s' \circ g) \,xs) = t (\pi_2\rho) \,b \,s' \,(\mathit{map}_{\mathit{List}} \,g \,xs), \\ 
    & i.e., \\
    &\mathit{map}_{\mathit{List}} \,g \circ t (\pi_1 \rho) \, a \, (s' \circ g) = t (\pi_2\rho) \, b \, s' \circ \mathit{map}_{\mathit{List}} \,g
  \end{align*}
  as desired.
\end{proof}
\end{comment}

%\subsection{Free Theorem for Type of $\mathit{filter}$ for
%  $\GRose$}\label{sec:filter-grose} 

A similar proof establishes the analogous result for, say, generalized
rose trees. 
\begin{thm} 
  If $g : A \to B$,
$F, G : \set \to \set$,
  $\eta : F \to G$ in $\set$, $\rho : \relenv$, $\rho \alpha =
 (A, B, \graph{g})$, $\rho \psi = (F, G, \graph{\eta})$, $(a, b) \in
 \relsem{\alpha, \psi ;\emptyset \vdash \Delta} \rho$, $(s \circ
 g, s) \in \relsem{\alpha; \emptyset \vdash \Nat^\emptyset \alpha \,
   \mathit{Bool}} \rho$, and
 \[ \mathit{filter} = \setsem{\alpha, \psi; \emptyset \,|\, \Delta
      \vdash t : \filtypeGRose}  \]
for some $t$, then
\[ \semmap_{\mathit{GRose}}\, \eta\, (g + 1) \circ \mathit{filter} \,
(\pi_1 \rho) \, a \, (s \circ g) = \mathit{filter} \, (\pi_2\rho) \, b
\, s \circ 
\semmap_{\mathit{GRose}}\, \eta\, g\]
\end{thm}

\noindent
This is not surprising since rose trees are essentially
ADT-like. However, as noted in Section~\ref{sec:terms}, our calculus
cannot express the type of a polymorphic filter function for a proper
nested type.

\subsection{Short Cut Fusion for Lists}\label{sec:short-cut}

We can recover standard short cut fusion for lists~\cite{glp93} in our
calculus: 
\begin{thm}
If \,$\vdash F$, $\vdash H$, and 
%$\beta; \emptyset \,|\, \emptyset \vdash g : \Nat^{\emptyset}
%(\Nat^{\emptyset} (\onet + \tau \times \beta)\, \beta)\, \beta$. 
%If
$G \, = \, \setsem{\beta; \emptyset \,|\, \emptyset \vdash g :
  \Nat^{\emptyset} (\Nat^{\emptyset} (\onet + F \times \beta)\,
  \beta)\, \beta}$ for some $g$, then
\[\mathit{fold}_{1 + \setsem{\vdash F} \times \_}\, n\, c\; (G\; (\mathit{List}\,
\setsem{\vdash F})\,\mathit{nil} \,\mathit{cons}) = G \,\setsem{\vdash
  H}\, n\, c \]
\end{thm}
\begin{proof}
%Let $\vdash \tau : \F$ and $\vdash \tau' : \F$, let
%\[\beta; \emptyset \,|\, \emptyset \vdash g : \Nat^{\emptyset}
%(\Nat^{\emptyset} (\onet + \tau \times \beta)\, \beta)\, \beta\]
%and let
%\[G = \setsem{\beta; \emptyset \,|\, \emptyset
%  \vdash g : \Nat^{\emptyset} (\Nat^{\emptyset} (\onet + \tau \times
  %  \beta)\, \beta)\, \beta}\] Then
Theorem~\ref{thm:abstraction} gives
that, for any $\rho : \relenv$,
%and any $(a, b) \in
%\relsem{\beta; \emptyset \vdash \emptyset}\rho = 1$, then (eliding the
%only possible instantiations of $a$ and $b$) we have
\[(G \,(\pi_1 \rho), G\, (\pi_2 \rho))
 \in  \relsem{\beta; \emptyset \vdash \Nat^{\emptyset} (\Nat^{\emptyset}
  (\onet + F \times \beta)\, \beta)\, \beta} \rho\\
\cong (((\relsem{\vdash F} \rho \times
\rho\beta) \to \rho\beta) \times \rho\beta) \to \rho\beta\] 
%\[\begin{array}{lll}
%(G \,(\pi_1 \rho), G\, (\pi_2 \rho))
% & \in & \relsem{\beta; \emptyset \vdash \Nat^{\emptyset} (\Nat^{\emptyset}
%  (\onet + \tau \times \beta)\, \beta)\, \beta} \rho\\
%& \cong& (((\relsem{\vdash \tau} \rho \times
%\rho\beta) \to \rho\beta) \times \rho\beta) \to \rho\beta 
%\end{array}\]
%
%Since
%\[\begin{array}{rl}
% & \relsem{\beta; \emptyset \vdash \Nat^{\emptyset}
%  (\Nat^{\emptyset} (\onet + \tau \times \beta)\, \beta)\, \beta} \rho\\  
%=& \relsem{\beta; \emptyset \vdash \Nat^{\emptyset} (\onet +
%  \tau \times \beta)\, \beta} \rho \to \rho\beta \\ 
%=& (\relsem{\beta; \emptyset \vdash \onet + \tau \times \beta}
%\rho \to \rho\beta) \to \rho\beta \\ 
%=& ((\onet + \relsem{\vdash \tau} \rho \times
%\rho\beta) \to \rho\beta) \to \rho\beta \\ 
%\cong& (((\relsem{\vdash \tau} \rho \times
%\rho\beta) \to \rho\beta) \times \rho\beta) \to \rho\beta 
%\end{array}\]
%we have that
so if $(c', c) \in \relsem{\vdash F} \rho \times
\rho\beta \to \rho\beta$ and $(n', n) \in \rho\beta$ then
$(G \,(\pi_1 \rho)\, n'\, c', G\, (\pi_2 \rho)\, n\, c)
\in \rho \beta$.
In addition,
\[\setsem{\vdash \fold_{\onet + F
    \times \beta}^{H} : \Nat^{\emptyset} (\Nat^{\emptyset} (\onet
  + F \times H)\, H)\, (\Nat^{\emptyset} (\mu \alpha. \onet
  + F \times \alpha)\, H)} =
\mathit{fold}_{1 + \setsem{\vdash F} \times \_}\] so that if $c \in
\setsem{\vdash F} \,\times\, \setsem{\vdash H} \to
\setsem{\vdash H}$ and $n \in \setsem{\vdash H}$, then
$(n, c) \in \setsem{\vdash \Nat^{\emptyset} (\onet + F \times H)\,
  H}$. The instantiation
$\pi_1 \rho \beta = \setsem{\vdash \mu \alpha. \onet + F \times
  \alpha}=\mathit{List}\,\setsem{\vdash F}$,\, 
$\pi_2 \rho \beta = \setsem{\vdash H}$,\,
$\rho \beta = \graph{\mathit{fold}_{1 + \setsem{\vdash F} \times \_}\, n\, c} :
\rel(\pi_1 \rho \beta, \pi_2 \rho \beta)$,\,
$c' = \mathit{cons}$,\, and 
$n' = \mathit{nil}$
%Consider the instantiation:
%\[\begin{array}{rcl}
%\pi_1 \rho \beta &=& \setsem{\vdash \mu \alpha. \onet + \tau \times
%  \alpha} \;=\;\List\,\setsem{\vdash \tau}\\   
%\pi_2 \rho \beta &=& \setsem{\vdash \tau'}\\
%\rho \beta &=& \graph{\mathit{fold}_{1 + \tau \times \_}\, n\, c} :
%\rel(\pi_1 \rho \beta, \pi_2 \rho \beta) \\ 
%c' &=& \mathit{cons}\\
%n' &=& \mathit{nil}
%\end{array}\]
%Clearly, $(\mathit{nil}, n) \in \rho\beta =
%\graph{\mathit{fold}_{1 + \tau \times \_}\, n\, c}$ because $
%\mathit{fold}_{1 + \tau \times \_}\, n\, c \,\mathit{nil} = n$.  Moreover,
%$(\mathit{cons}, c) \in \relsem{\vdash \tau} \,\times\, \rho\beta \to
%\rho\beta$ since if $(x, x') \in \relsem{\vdash \tau}$, i.e., $x =
%x'$, and if $(y, y') \in \rho\beta =
%\graph{\mathit{fold}_{1 + \tau \times \_} n\, c}$, i.e., $y' =
%\mathit{fold}_{1 + \tau \times \_} n\, c\, y$, then
%\[(\mathit{cons}\, x\, y, c\, x\, (\mathit{fold}_{1 + \tau \times \_}\, n\,
%c\, y)) \in \graph{\mathit{fold}_{1 + \tau \times \_}\, n\, c}\]
%i.e.,
%\[c\, x\, (\mathit{fold}_{1 + \tau \times \_}\, n\, c\, y)
%= \mathit{fold}_{1 + \tau \times \_}\, n\, c\, (\mathit{cons} \,x\, y)\]
%holds by definition of $\mathit{fold}_{1 + \tau \times \_}$.  We
%therefore conclude that
thus gives that $(G \;(\mathit{List}\,\setsem{\vdash
  F})\,\mathit{nil} \,\mathit{cons}, G \,\setsem{\vdash H} \,
n\, c) \in \graph{\mathit{fold}_{1 + \setsem{\vdash F} \times \_}\, n\, c}$, i.e.,
that $\mathit{fold}_{1 + \setsem{\vdash F} \times \_}\, n\, c\; (G\;
(\mathit{List}\,\setsem{\vdash F})\, \mathit{nil}\, \mathit{cons})
= G \,\setsem{\vdash H}\, n\, c$.
\end{proof}

We can extend short cut fusion results to arbitrary ADTs, as
in~\cite{joh02,pit98}.

\begin{comment}
\subsection{Short Cut Fusion for Arbitrary ADTs}\label{sec:short-cut-adt}

\begin{thm}
Let $\ol{\vdash \tau}$, let $\vdash \tau'$, let $\ol{\alpha}; \beta
\vdash F$, and let $\beta; \emptyset  \,|\,
\emptyset \vdash g : \Nat^{\emptyset} (\Nat^{\emptyset} F[\ol{\alpha
    := \tau}]\, \beta)\, \beta$.  If we regard
\[\begin{array}{lll}
H & = & \setsem{\emptyset;\beta \vdash F[\ol{\alpha :=
      \tau}]}\\
G & = & \setsem{\beta; \emptyset \,|\, \emptyset \vdash g :
  \Nat^{\emptyset} (\Nat^{\emptyset}\, F[\ol{\alpha := \tau}]\,
  \beta)\, \beta}
\end{array}\]
as functors in $\beta$, then for every $B \in H \setsem{\vdash \tau'}
\rightarrow \setsem{\vdash \tau'}$ we have
\[\mathit{fold}_H\, B \; (G\; \mu H \; in_H) = G \,\setsem{\vdash \tau'}\, B\]
\end{thm}

\vspace*{0.2in}

\begin{proof}
  We first note that the type of $g$ is well-formed, since
  $\emptyset;\beta \vdash F[\ol{\alpha := \tau}]$ so our
  promotion theorem gives that $\beta;\emptyset\vdash F[\ol{\alpha :=
      \tau}]$, and $\emptyset;\beta\vdash\beta$ so that our
  promotion theorem gives $\beta;\emptyset\vdash\beta$. From
  these facts we deduce that $\beta;\emptyset \vdash
  \Nat^\emptyset\,F[\ol{\alpha := \tau}]\,\beta : \T$, and thus that
  $\beta; \emptyset \vdash \Nat^{\emptyset} (\Nat^{\emptyset}
  F[\ol{\alpha := \tau}]\, \beta)\, \beta : \T$.

  Theorem~\ref{thm:abstraction} gives that, for any $\rho : \relenv$
  and any $(a, b) \in \relsem{\beta; \emptyset \vdash \emptyset}\rho =
  1$, eliding the only possible instantiations of $a$ and $b$ gives
  that
\[(G \,(\pi_1 \rho), G\, (\pi_2 \rho))
\in \relsem{\beta; \emptyset \vdash \Nat^{\emptyset} (\Nat^{\emptyset}
  F[\ol{\alpha := \tau}]\, \beta)\, \beta} \rho\]
Since
\[\begin{array}{rl}
 & \relsem{\beta; \emptyset \vdash \Nat^{\emptyset}
  (\Nat^{\emptyset} F[\ol{\alpha := \tau}]\, \beta)\, \beta} \rho\\  
=& \relsem{\beta; \emptyset \vdash \Nat^{\emptyset} F[\ol{\alpha :=
      \tau}] \, \beta} \rho \to \rho\beta \\ 
\end{array}\]
we have that if $(A, B) \in \relsem{\beta; \emptyset \vdash
  \Nat^{\emptyset} F[\ol{\alpha := \tau}] \, \beta} \rho$
then
\[(G \,(\pi_1 \rho)\, A, G\, (\pi_2 \rho)\, B)
\in \rho \beta\]
Now note that
\[\setsem{\vdash \fold_{F[\ol{\alpha := \tau}]}^{\tau'} :
  \Nat^{\emptyset}\, (\Nat^{\emptyset}\, F[\ol{\alpha := \tau}][\beta
    := \tau'] \, \tau')\, (\Nat^{\emptyset} \,(\mu
  \beta. F[\ol{\alpha := \tau}] \, \tau')} =
\mathit{fold}_H\]
and consider the instantiation
\[\begin{array}{lll}
A &=& \mathit{in}_H :  H (\mu H) \to \mu H\\
B & : & H\setsem{\vdash \tau'} \to \setsem{\vdash \tau'}\\
\rho \beta &=& \graph{\mathit{fold}_H\, B}
\end{array}\]
(Note that all the types here are well-formed.)  This gives
\[\begin{array}{lll}
\pi_1 \rho \beta &=& \setsem{\vdash \mu \beta. F[\ol{\alpha := \tau}]}
\; = \; \mu H\\
\pi_2 \rho \beta &=& \setsem{\vdash \tau'}\\
\rho \beta &:& \rel(\pi_1 \rho \beta, \pi_2 \rho \beta)\\
A & : & \setsem{\beta; \emptyset \vdash \Nat^{\emptyset}
  F[\ol{\alpha := \tau}] \, \beta} (\pi_1 \rho)\\
B & : & \setsem{\beta; \emptyset \vdash \Nat^{\emptyset} F[\ol{\alpha
      := \tau}] \, \beta}(\pi_2 \rho)\\
\end{array}\]
since
\[\begin{array}{lll}
A \; = \; \mathit{in}_H & : & H(\mu H) \to \mu H\\
 & = & \setsem{\emptyset;\beta \vdash F[\ol{\alpha := \tau}]}(\mu
\setsem{\emptyset;\beta \vdash F[\ol{\alpha := \tau}]}) \to \mu
\setsem{\emptyset;\beta \vdash F[\ol{\alpha := \tau}]}\\
& = & \setsem{\emptyset;\beta \vdash F[\ol{\alpha :=
      \tau}]}(\pi_1\rho) \to \setsem{\emptyset;\beta \vdash
  \beta}(\pi_1 \rho)\\
& = & \setsem{\beta;\emptyset \vdash F[\ol{\alpha :=
      \tau}]}(\pi_1\rho) \to \setsem{\beta; \emptyset \vdash
  \beta}(\pi_1 \rho) \hspace*{0.25in} {\color{red} \mbox{Daniel's
    trick; now a theorem}} \\ 
& = & \setsem{\beta;\emptyset \vdash \Nat^\emptyset F[\ol{\alpha :=
      \tau}]\,\beta}(\pi_1 \rho) 
\end{array}\]
{\color{red} where ``Daniel's trick'' is the observation that a
  functor can be seen as non-functorial when we only care about its
  action on objects. This is now a theorem.}  We also have
\[\begin{array}{lll}
(A,B) \,=\, (\mathit{in}_H,B) & \in & \relsem{\beta; \emptyset \vdash
  \Nat^{\emptyset} F[\ol{\alpha := \tau}] \, \beta} \rho \\
 & = & \relsem{\beta; \emptyset \vdash F[\ol{\alpha :=
      \tau}]}\rho[\beta := \graph{\mathit{fold}_H\, B}] \to
\graph{\mathit{fold}_H\, B}\\
 & = & \relsem{\beta; \emptyset \vdash F[\ol{\alpha :=
      \tau}]}\graph{\mathit{fold}_H\, B} \to
\graph{\mathit{fold}_H\, B}\\
 & = & \relsem{\emptyset; \beta\vdash F[\ol{\alpha :=
      \tau}]}\graph{\mathit{fold}_H\, B} \to
\graph{\mathit{fold}_H\, B} \hspace*{0.35in} {\color{red}
  \mbox{Daniel's trick; now a theorem}}\\  
& = & \graph{\setsem{\emptyset; \beta \vdash F[\ol{\alpha :=
      \tau}]}\,(\mathit{fold}_H\, B)} \to
\graph{\mathit{fold}_H\, B} \hspace*{0.25in} {\color{red} \mbox{by the
    graph lemma}}\\ 
& = & \graph{\mathit{map}_H \,(\mathit{fold}_H\,B)} \to
\graph{\mathit{fold}_H\, B}\\
\end{array}\]
since if $(x,y) \in \graph{\mathit{map}_H \,(\mathit{fold}_H\,B)}$,
i.e., if $\mathit{map}_H \,(\mathit{fold}_H\,B) \, x = y$, then
$\mathit{fold}_H\, B\, (\mathit{in}_H\,x) = B\,y = B\, (\mathit{map}_H
\,(\mathit{fold}_H\,B) \, x)$ by the definition of $\mathit{fold}_H$
as a (indeed, the unique) morphism from $\mathit{in}_H$ to $B$. Thus,
\[(G \,(\pi_1 \rho)\, A, G\, (\pi_2 \rho)\, B) \in
\graph{\mathit{fold}_H\, B}\]
i.e.,
\[\mathit{fold}_H \, B \, (G\, (\pi_1 \rho) \, \mathit{in}_H) =
G\,(\pi_2 \rho)\,B\] 

\vspace*{0.1in}

\noindent
Since $\beta$ is the only free variable in $G$, this simplifies to
\[\mathit{fold}_H\, B \, (G\, \mu H\, \mathit{in}_H) =
G\,\setsem{\vdash \tau'}\,B\]  
\end{proof}
\end{comment}

\subsection{Short Cut Fusion for Arbitrary Nested
  Types}\label{sec:short-cut-nested} 

%fold/build rule shows that Church encodings for nested types are iso
%(have the same interp) as the nested types themselves. Just like Ex
%2.8 in parpoe, but categorical rather than operational semantics. But
%built-in data types are more versatile in implementations. They can be
%inducted on, e.g. And they are stored in the heap, not the run-time
%stack, and are therefore more efficient.
%``Most higher order type languages meant for human programmers eschew
%fully impredicative polymorphism'' says Andy on p322.

We can also, finally, formally prove correctness of the categorically
inspired short cut fusion for nested types from~\cite{jg10}. Indeed,
we have:
\begin{thm}\label{thm:short-cut-nested}
If $\emptyset;\phi,\alpha \vdash F$, \,$\emptyset; \alpha
\vdash K$, \,
%let $\phi ;\emptyset\,|\,\emptyset\vdash g :
%\Nat^\emptyset\,(\Nat^\alpha\,F\,(\phi\alpha)) \,
%(\Nat^\alpha\,\onet \, (\phi\alpha))$. If we let
$H : [\set,\set] \to [\set,\set]$ is defined by
\[\begin{array}{lll}
H\,f\,x & = & \setsem{\emptyset; \phi, \alpha \vdash F}[\phi :=
  f][\alpha := x]\\
\end{array}\]
and 
\[G = \setsem{\phi;\emptyset\,|\,\emptyset \vdash g :
\Nat^\emptyset\,(\Nat^\alpha\,F\,(\phi\alpha))\,(\Nat^\alpha\,\onet \,
(\phi\alpha))}\] for some $g$, then, for every $B \in H
\setsem{\emptyset;\alpha \vdash K} \rightarrow \setsem{\emptyset;
  \alpha \vdash K}$,
$\mathit{fold}_{H}\, B \, (G\; \mu H \; \mathit{in}_{H}) = G
\,\setsem{\emptyset;\alpha \vdash K}\, B$.
\end{thm}

\begin{proof}
%We first note that the type of $g$ is well-formed since
%$\emptyset;\phi,\alpha \vdash F : \F$ so our promotion theorem gives
%that $\phi;\alpha \vdash F : \F$, and $\phi;\alpha \vdash \phi\alpha :
%\F$, so that $\phi;\emptyset \vdash \Nat^\alpha F\,(\phi\alpha) : \T$
%and $\phi;\emptyset \vdash \Nat^\alpha \onet \,(\phi\alpha) : \T$.
%Then $\phi;\emptyset \vdash \Nat^\alpha F\,(\phi\alpha) : \F$ and
%$\phi;\emptyset \vdash \Nat^\alpha \onet \,(\phi\alpha) : \F$ also
%%%hold, and, finally, 
%$\phi ;\emptyset\vdash 
%\Nat^\emptyset\,(\Nat^\alpha\,F\,(\phi\alpha)) \,
%(\Nat^\alpha\,\onet \, (\phi\alpha)) : \T$
%  
Theorem~\ref{thm:abstraction} gives that, for any 
$\rho : \relenv$,
%and any $(a, b) \in \relsem{\phi,\alpha;\emptyset \vdash
%  \emptyset}\rho = 1$, eliding the only possible instantiations
%of $a$ and $b$ gives that
\[\begin{array}{lll}
(G \,(\pi_1 \rho), G\, (\pi_2 \rho))
& \in & \relsem{\phi;\emptyset\vdash \Nat^{\emptyset} (\Nat^\alpha
  F\, (\phi\alpha))\, (\Nat^\alpha\,\onet \, (\phi\alpha))}
\rho\\ 
& = & \relsem{\phi;\emptyset\vdash \Nat^\alpha F\,
  (\phi\alpha)}\rho \to \relsem{\phi;\emptyset\vdash
  \Nat^\alpha\,\onet \, (\phi\alpha)}\rho\\ 
%& = & \relsem{\phi;\emptyset\vdash \Nat^\alpha F\,
%  (\phi\alpha)}\rho \to (\,\lambda A. 1 \Rightarrow \lambda A.\,(\rho
%\phi) A\,)\\   
%& = & \relsem{\phi;\emptyset\vdash \Nat^\alpha F\,
%  (\phi\alpha)}\rho \to (1 \Rightarrow \rho \phi)\\ 
& = & \relsem{\phi;\emptyset\vdash \Nat^\alpha F\,
  (\phi\alpha)}\rho \to \rho \phi
\end{array}\]
\noindent
so if $(A, B) \in \relsem{\phi;\emptyset\vdash \Nat^\alpha F\,
  (\phi\alpha)}\rho$ then $(G \,(\pi_1 \rho)\, A, G\, (\pi_2 \rho)\,
B) \in \rho \phi$.
In addition,
%$\mathit{fold}_H = \setsem{\vdash \fold_F^K :
%  \Nat^{\emptyset}\, (\Nat^\alpha F[\phi := K]\,K)\, (\Nat^\alpha
%  ((\mu \phi.\lambda\alpha.F)\alpha)\,K)}$.
\[\setsem{\vdash \fold_F^K :
  \Nat^{\emptyset}\, (\Nat^\alpha F[\phi := K]\,K)\, (\Nat^\alpha
  ((\mu \phi.\lambda\alpha.F)\alpha)\,K)} = \mathit{fold}_H\]
Consider the instantiation $A = \mathit{in}_H : H (\mu H) \Rightarrow
\mu H$,\, $B : H\setsem{\emptyset;\alpha\vdash K} \Rightarrow
\setsem{\emptyset;\alpha \vdash K}$,\, $\rho \phi =
\graph{\mathit{fold}_H\, B}$,\, $\pi_1 \rho \phi = \mu H$,\, $\pi_2
\rho \phi = \setsem{\emptyset;\alpha\vdash K}$,\, $\rho \phi :
\rel(\pi_1 \rho \phi, \pi_2 \rho \phi)$,\, $A : \setsem{\phi;
  \emptyset \vdash \Nat^\alpha F \, (\phi \alpha)} (\pi_1 \rho)$,\,
and $B : \setsem{\phi; \emptyset \vdash \Nat^\alpha F \, (\phi
  \alpha)} (\pi_2 \rho)$.
%\[\begin{array}{lll}
%A &=& \mathit{in}_H :  H (\mu H) \Rightarrow \mu H\\
%B & : & H\setsem{\emptyset;\alpha\vdash K} \Rightarrow
%\setsem{\emptyset;\alpha \vdash K}\\
%\rho \phi &=& \graph{\mathit{fold}_H\, B} \hspace*{0.2in} {
%  \color{red} \mbox{a graph of a natural transformation, defined in
%    Enrico's notes}} 
%\end{array}\]
%(Note that all the types here are well-formed.) This gives
%\[\begin{array}{lll}
%\pi_1 \rho \phi &=& \mu H\\
%\pi_2 \rho \phi &=& \setsem{\emptyset;\alpha\vdash K}\\
%\rho \phi &:& \rel(\pi_1 \rho \phi, \pi_2 \rho \phi)\\
%A & : & \setsem{\phi; \emptyset \vdash \Nat^\alpha
%  F \, (\phi \alpha)} (\pi_1 \rho)\\
%B & : & \setsem{\phi; \emptyset \vdash \Nat^\alpha
%  F \, (\phi \alpha)} (\pi_2 \rho)\\
%\end{array}\]
%since
Equation~\ref{thm:demotion-objects} ensures that $A = \mathit{in}_H :
H(\mu H) \Rightarrow \mu H = \setsem{\phi;\emptyset \vdash \Nat^\alpha
  F \,(\phi\alpha)}(\pi_1\rho)$,
%\[\begin{array}{lll}
%A \; = \; \mathit{in}_H & : & H(\mu H) \Rightarrow \mu H\\
%& = & \setsem{\emptyset; \phi, \alpha \vdash F}[\phi := \mu
%  \setsem{\emptyset; \phi, \alpha \vdash F}] \Rightarrow \mu
%  \setsem{\emptyset; \phi, \alpha \vdash F}\\  
%& = & \setsem{\emptyset; \phi, \alpha \vdash F}(\pi_1\rho)
%  \Rightarrow \setsem{\emptyset; \phi,\alpha \vdash \phi\alpha}(\pi_1 \rho)\\
%& = & \setsem{\phi; \alpha \vdash F}(\pi_1\rho)
%  \Rightarrow \setsem{\phi;\alpha \vdash \phi\alpha}(\pi_1
%  \rho) \hspace*{0.25in} {\color{red} \mbox{Daniel's trick; now a theorem}}\\
%& = & \setsem{\phi;\emptyset \vdash \Nat^\alpha F
%    \,(\phi\alpha)}(\pi_1\rho) 
%\end{array}\]
and Equation~\ref{thm:demotion-objects} and Lemma~\ref{lem:graph}
together give that
\[\begin{array}{lll}
(A,B) \,=\, (\mathit{in}_H,B) & \in & \relsem{\phi;\emptyset\vdash
  \Nat^\alpha F\, (\phi\alpha)}\rho\\
% & = & \lambda A. \relsem{\phi;\alpha\vdash F}\rho[\alpha := A]
%\Rightarrow \lambda A. (\rho\phi) A\\
& = & \lambda A. \relsem{\phi;\alpha\vdash F}[\phi :=
  \graph{\mathit{fold}_H\, B}][\alpha := A] \Rightarrow 
 \graph{\mathit{fold}_H\, B} \\ 
%& = & \lambda A. \relsem{\emptyset;\phi,\alpha\vdash F}[\phi :=
%  \graph{\mathit{fold}_H\, B}][\alpha := A] \Rightarrow 
%\graph{\mathit{fold}_H\, B}  \hspace*{0.25in} {\color{red}
%  \mbox{Daniel's trick; now a theorem}}\\  
& = & \relsem{\emptyset;\phi,\alpha\vdash F}
  \graph{\mathit{fold}_H\, B} \Rightarrow \graph{\mathit{fold}_H\,
    B}\\
  & = & \graph{\setsem{\emptyset;\phi,\alpha\vdash F}
    \,(\mathit{fold}_H\,B)} \Rightarrow \graph{\mathit{fold}_H\, B}\\
%\hspace*{0.25in} {\color{red} \mbox{Graph Lemma}}\\
  & = & \graph{\mathit{map}_H \,(\mathit{fold}_H\,B)} \Rightarrow
\graph{\mathit{fold}_H\, B}\\
\end{array}\]
since if $(x,y) \in \graph{\mathit{map}_H \,(\mathit{fold}_H\,B)}$,
%i.e., if $\mathit{map}_H \,(\mathit{fold}_H\,B) \, x = y$,
then $\mathit{fold}_H\, B\, (\mathit{in}_H\,x) = B\,y = B\,
(\mathit{map}_H \,(\mathit{fold}_H\,B) \, x)$ by the definition of
$\mathit{fold}_H$ as a (indeed, the unique) morphism from
$\mathit{in}_H$ to $B$.  Thus, $(G \,(\pi_1 \rho)\, A, G\, (\pi_2
\rho)\, B) \in \graph{\mathit{fold}_H\, B}$, i.e., $\mathit{fold}_H \,
B \, (G\, (\pi_1 \rho) \, \mathit{in}_H) = G\,(\pi_2 \rho)\,B$.  But
since $\phi$ is the only free variable in $G$, this simplifies to
$\mathit{fold}_H\, B \, (G\, \mu H\, \mathit{in}_H) =
G\,\setsem{\emptyset;\alpha\vdash K}\,B$. 
\end{proof}

\vspace*{-0.08in}

As in~\cite{jg10}, replacing $\onet$ with any type $\emptyset;\alpha
\vdash C$ generalizes
%with $\setsem{\emptyset;\alpha \vdash c}\rho = C$
Theorem~\ref{thm:short-cut-nested} to deliver more general a free
theorem whose conclusion is $\mathit{fold}_{H}\, B \; \circ \; G\; \mu
H \; \mathit{in}_{H} = G \,\setsem{\emptyset;\alpha \vdash K}\, B$.
Although it is standard to prove that the parametric model constructed
verifies the existence of initial algebras, this is unnecessary here
since initial algebras are built directly into our model.

\section{Conclusion and Directions for Future Work}\label{sec:conclusion}

We have constructed a parametric model for a calculus
providing primitives for constructing nested types directly as
fixpoints.
%rather than representing them via their Church encodings. We
We have also used the Abstraction Theorem for this model to derive
free theorems in the presence of nested types. This was not possible
before~\cite{jp19} because the nested types in our calculus were not
previously known to have well-defined interpretations in locally
finitely presentable categories like $\set$ and $\rel$. No calculus
for terms of these types existed, either. The key to obtaining our
parametric model is
%{\color{blue} adjusting our type syntax to respect the accessibility
%  cardinal for the semantic category and}
the delicate threading of functoriality and its accompanying
naturality conditions throughout the model construction.

Even when nested types have well-defined interpretations in a semantic
category, the types of standard functions over them may not. This is
because all recursion in our calculus must be coded using standard
folds.  Since folds for nested types can only express computations
that return natural transformations, their expressivity has long been
a vexing issue, and this is naturally inherited by our calculus.
%indeed, such folds
%Our calculus naturally inherits these constraints.
%Of course our calculus inherits the constraints
%standard folds for nested types impose, and thus is perhaps not as
%expressive as we would ideally like.
In addition, while there are many papers on higher-kinded types, we
know of none that considers expressibility issues arising from the
local $\lambda$-presentability cardinal $\lambda$ of the categories in
which higher-kinded types are interpreted. Because $\lambda = \omega$
for $\set$ and $\rel$, the expressivity of our
%$\set$/$\rel$-based parametric model
calculus is, unfortunately, not easily improved there. Construction of
a $\set$/$\rel$-based parametric model for our calculus is
nevertheless worthwhile.  For one thing, the expressivity issue is
orthogonal to constructing parametric models,
%in the presence of nested types built from primitives,
and trying to address both in a single paper would
detract from the conceptual clarity of our model construction.
%our current focus on deriving principled parametricity
%results for practical programming languages, such as Haskell and Agda,
%that directly construct nested types as fixpoints.
%
%conceptual clarity of this paper.
For another, if the construction in this paper
%we couldn't
%construct a $\set$/$\rel$-based parametric model for the calculus
%presented here,
weren't possible, then trying to construct a parametric model from
richer semantic categories for fancier data types and/or recursion
schemes would be futile. We naturally expect the construction reported
here to guide its generalization to the locally $\lambda$-presentable
categories for $\lambda > \omega$ that will be needed to accommodate
more general data types and recursion schemes for them.

% As is, the results reported here provide a
%blueprint for deriving principled parametricity results for practical
%programming languages, such as Haskell and Agda, that directly
%construct nested types as fixpoints.

%{\color{blue} Perhaps surprisingly, the accessibility cardinal
%$\omega$ for the semantic categories $\set$ and $\rel$ also impacts
%the types of functions (and thus the functions themselves), even over
%expressible data types, that can be expressed. Although there are
%many papers on higher-kinded types, no other work that we know of
%even considers expressibility issues resulting from the semantic
%settings in which they are interpreted.}
%{\color{blue} In light of the aforementioned
%  restrictions imposed by the accessibility cardinal of $\set$ and
%  $\rel$, this paper is perhaps best read as a proof-of-concept for
%  constructing parametric models in the locally finitely presentable
%  categories $\set$ and $\rel$ for calculi that construct nested types
%  and other advanced data types as fixed points (rather than
%  representing them via their Church encodings) and that support
%  structured recursion over them. If we couldn't construct such a
%  model even in this restricted setting, then there'd be no point in
%  trying to do so for more robust categories, data types, and/or
%  recursion schemes. Moreover, our constructions in this simplest
%  possible setting will guide their generalizations to the locally
%  $\lambda$-presentable categories fopr $\lambda > \omega$ required to
%  handle more general data types, structured recursive functions over
%  then, and more general fixpoints.}



%But since this expressivity issue is orthogonal to constructing
%parametric models in the presence of nested types built from
%primitives, and since it would detract from the conceptual clarity of
%our presentation, we have deliberately chosen not to address it in
%this paper. (However, we discuss some ideas for increasing
%expressivity in the next paragraph.) Despite the limitations of
%standard folds, our results provide a blueprint for deriving
%principled parametricity results for practical programming languages,
%such as Haskell and Agda, that directly construct nested types as
%fixpoints.



%All recursion in our calculus must be coded using folds. Expressivity
%of standard folds for nested types has long been a vexing issue,
%%indeed, such folds
%since they can only express computations that return natural
%transformations; our calculus naturally inherits these constraints.
%%Of course our calculus inherits the constraints
%%standard folds for nested types impose, and thus is perhaps not as
%%expressive as we would ideally like.
%But since this expressivity issue
%is orthogonal to constructing parametric models in the presence of
%nested types built from primitives, and since it would detract from
%the conceptual clarity of our presentation, we have deliberately
%chosen not to address it in this paper. (However, we discuss some
%ideas for increasing expressivity in the next paragraph.) Despite the
%limitations of standard folds, our results provide a blueprint for
%deriving principled parametricity results for practical programming
%languages, such as Haskell and Agda, that directly construct nested
%types as fixpoints.

%Many extensions of standard folds have been
%proposed. Perhaps the most significant of these are
Generalized folds~\cite{bp99} are an extension of standard folds that
%and Mendler iterators~\cite{amu05}.
%which
can express computations whose results are not natural
transformations. These were shown in~\cite{jg10} to be equivalent to
standard folds in the presence of object-level {\em right} Kan
extensions.
%; interpreting such
%a construct in $\set$ and $\rel$ should be unproblematic {\color{blue}
%  since these categories have all(?) limits}.
It was also shown in~\cite{jg08} that GADTs can be represented using
object-level {\em left} Kan extensions, and
%
%This suggests
%extending our term calculus with such object-level constructs.
%
%{\color{blue} We may need to impose restrictions inspired
%  by those for $\mu$-types on LKEs.}
adding a carefully designed left Kan extension construct to our
calculus was shown in~\cite{jp19} to preserve the cocontinuity needed
for GADTs to have well-defined interpretations. (Note, however, that
%not necessarily in
%However, this will not, in general, be
%the case in locally finitely presentable categories. Indeed, as shown
%in~\cite{jp19},
locally $\lambda$-presentable categories for $\lambda > \aleph_1$ are
required to interpret even commonly used GADTs.) This suggests
extending our calculus with Kan extension constructs and
%augmenting our type formation rules with such a construct.
%The constructions of this paper should all be possible
carrying out our model construction in a locally $\lambda$-presentable
cartesian closed category (lpccc) $\cal C$ whose category of
(abstract) relations, obtained by pullback as in~\cite{jac99},
is also a lpccc and appropriately fibred over $\cal C$.  This would
%extend the results presented here along the lines of~\cite{gjfor15},
%thus giving
give a framework for constructing parametric models for calculi
with nested types built from primitives that is based on locally
$\lambda$-presentable fibrations, for some appropriate definition
thereof.  Another option is to add term-level fixpoints
%, as in~\cite{pit00},
to the calculus presented here. Of course, this would require the
categories interpreting types to be not just locally
$\lambda$-presentable, but to support some kind of domain structure as
well.
%Unfortunately, $\omega$-CPO, the most obvious category
%of domains to replace $\set$, is not locally finitely presentable.

\pagebreak

\noindent

%Won't print in anonymous mode.
\begin{acks}
We thank Andrew Polonsky for valuable feedback and fruitful
discussions. Supported by NSF awards CCR-1906388 and 1420175.
\end{acks}


\bibliography{references}

\end{document}


  
fixpoints at term level ala Pitts:

I'm not sure if we actually want to do this or not (because not all
fixpoints will necessarily exist, and this will have consequences, and
because of the restriction to strict functions it will entail and the
fact that I haven't yet thought about how those will thread through
our calculus), but another idea we might consider is adding fixpoints
at the term level. This is done for System F in Wadler's section
7. [It is also done in Pitts' Parametric Polymorphism and Operational
  Equivalence paper, where the term introduction rule is SEE SOURCE

%Gamma \vdash F : \tau \to \tau
%-------------------------------
%Gamma \vdash fix (F) : tau

But of course the model there is entirely operational rather than
categorical.]


On the other hand, check out the last paragraph of Wadler's paper, which
suggests that (at least in 1989) there was some interest in calculi like
ours:

"The desire to derive theorems from types therefore suggests that it would be
valuable to explore programming languages that prohibit recursion or only
allow its restricted use. In theory, this is well understood; we have already
noted that any computable function that is provably total in second-order
Peano arithmetic can be defined in the pure polymorphic lambda calculus,
without using the fixpoint as a primitive. However, practical languages based
on this notion remain terra incognita."

Of course we are not working in System F, but perhaps the same desire applies
here, and we do get the same kinds of theorems as Wadler, many just as a
consequence of our interpretation, without invoking parametricity.

In any case, I guess Wadler could be cited as justifying restricting
our attention to our calculus since it could be seen as a way to have
a practical language that ensures that all programs are
terminating. This has been considered in the past, e.g., in ADL,
Charity, PolyP.


TERMINATING RECURSION
Another possible solution to the expressivity issue is extend folds to
track of deep structure of nested types as in~\cite{jp19}, so that
specialization of fixpoint can be computed as fixpoint of
specialization.

Add more polymorphism (all foralls), even though most free theorems
only use one level (or maybe two, like short cut).


%test



