% For double-blind review submission, w/o CCS and ACM Reference (max
% submission space)
\documentclass[acmsmall,screen,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2021}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations
%\citestyle{acmnumeric}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\usepackage[utf8]{inputenc}
\usepackage{ccicons}
\usepackage{verbatim}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amscd}
%\usepackage{MnSymbol}
\usepackage{xcolor}

\usepackage{bbold}
\usepackage{url}
\usepackage{upgreek}
%\usepackage{stmaryrd}

\usepackage{lipsum}
\usepackage{tikz-cd}
\usetikzlibrary{cd}
\usetikzlibrary{calc}
\usetikzlibrary{arrows}

\usepackage{bussproofs}
\EnableBpAbbreviations

\input{macros}
\input{mytheorem}

\theoremstyle{definition}
\newtheorem{exmpl}{Example}

\renewcommand{\greyout}[1]{}

\newcommand{\new}[1]{{\color{blue} {#1}}}


\newcommand{\emptyfun}{{[]}}
\newcommand{\cal}{\mathcal}
\newcommand{\F}{\mathcal{F}}
\renewcommand{\G}{\mathcal{G}}
\newcommand{\N}{\mathcal{N}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\B}{\mathcal{B}}
\renewcommand{\P}{\mathcal{A}}
\newcommand{\pred}{\mathsf{Fam}}
\newcommand{\env}{\mathsf{Env}}
\newcommand{\set}{\mathsf{Set}}
\renewcommand{\S}{\mathcal S}
\renewcommand{\C}{\mathcal{C}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\A}{\mathcal{A}}
\renewcommand{\id}{\mathit{id}}
\newcommand{\map}{\mathsf{map}}
\newcommand{\pid}{\underline{\mathit{id}}}
\newcommand{\pcirc}{\,\underline{\circ}\,}
\newcommand{\pzero}{\underline{0}}
\newcommand{\pone}{\underline{1}}
\newcommand{\psum}{\,\underline{+}\,}
\newcommand{\pinl}{\underline{\mathit{inL}}\,}
\newcommand{\pinr}{\underline{\mathit{inR}}\,}
\newcommand{\ptimes}{\,\underline{\times}\,}
\newcommand{\ppi}{\underline{\pi_1}}
\newcommand{\pppi}{\underline{\pi_2}}
\newcommand{\pmu}{\underline{\mu}}
\newcommand{\semmap}{\mathit{map}}
\newcommand{\subst}{\mathit{subst}}

\newcommand{\tb}[1]{~~ \mbox{#1} ~~}
\newcommand{\listt}[1]{(\mu \phi. \lambda \beta . \onet + \beta \times
  \phi \beta) #1} 
\newcommand{\filtype}{\Nat^\emptyset 
 (\Nat^\emptyset \, \alpha \, \mathit{Bool})\, (\Nat^\emptyset 
  (List \, \alpha) \, (List \, \alpha))} 
\newcommand{\filtypeGRose}{\Nat^\emptyset 
 (\Nat^\emptyset \, \alpha \, \mathit{Bool})\, (\Nat^\emptyset 
  (\mathit{GRose}\,\psi \, \alpha) \, (\mathit{GRose}\,\psi \, (\alpha
  + \onet)))} 
\newcommand{\maplist}{\mathit{map}_{\lambda A. \setsem{\emptyset; \alpha
      \vdash \mathit{List} \, \alpha} \rho[\alpha := A]}} 
\newcommand{\PLeaves}{\mathsf{PLeaves}}
\newcommand{\swap}{\mathsf{swap}}
\newcommand{\reverse}{\mathsf{reverse}}
\newcommand{\Bcons}{\mathit{Bcons}}
\newcommand{\Bnil}{\mathit{Bnil}}


\title[Parametricity in the Presence of GADTs]{Parametricity in the
  Presence of GADTs}

\author{Patricia Johann, Enrico Ghiorzi, and Daniel Jeffries}
\affiliation{ \institution{Appalachian State University}}
\email{johannp@appstate.edu, ghiorzie@appstate.edu,
  jeffriesd@appstate.edu}

\begin{document}

\begin{abstract}
{\color{red} FIX ME!} There are two ways to represent/interpret
GADTs. They are not the same, and how we view GADTs has profound
consequences for how we program with, and reason about, them.
\end{abstract}

\maketitle

\section{Introduction}\label{sec:intro}
{\color{blue} map vs. fmap throughout.} {\color{blue} Add polynomial
  throughout?}
{\color{blue} We say "naturality consequences of parametricity"
when in fact we have naturality without having any parametricity at all.
Change the wording to indicate that naturality follows from
functoriality of the interp.}

There are two standard ways to represent data types when studying
modern functional languages: via their Church encodings in a (possibly
higher-kinded) extension of System F~\cite{gir72}, the calculus at the
core of all such languages, and by augmenting System F
%a Hindley-Milner style calculus
with primitives for constructing them directly as fixpoints.
%{\color{blue} Something about when each of these representations is
%  used. The former perhaps more closely represents how data types are
%  represented in implementations, but the latter are how they have
%  heretofore primarily been treated theoretically.}
In models that validate the program optimization known as {\em short
  cut fusion}~\cite{glp93} the two representations are, in fact,
semantically equivalent, i.e., both have the same interpretation in
the model. Models in which the Church encodings and primitive
representations of all algebraic data types (ADTs) are semantically
equivalent include the operationally-based model of~\cite{pit98,pit00}
and the categorical models of~\cite{joh02,joh03}.
%\footnote{{\color{blue} Pitts proves the isomorphism only for
%    polynomial ADTs, whereas Johann {\em et al.}  prove it for any
%    data type that is the fixpoint of a first-order functor.}}
Correctness of short cut fusion, and thus semantic equivalence of
Church encodings and primitive representations, was recently extended
to the class of what might be called ``hereditarily polynomial''
{\color{blue} to include truly nested such types} nested types via the
categorical model of~\cite{jgj21}. But, as shown in
Section~\ref{sec:par} below, for some GADTs --- even polynomial ones
--- no such isomorphism holds.

GADTs are traditionally represented via Church encodings. In this
view, GADTs are completely determined by their syntax; for example,
the GADT $\mathsf{Seq}$ defined in Haskell by
\begin{equation}\label{eq:seq}
\begin{array}{l}
\mathsf{data\, Seq\,a\,where}\\
\mathsf{\;\;\;\;\;\;\;\;Const ::\, a \to Seq\,a}\\
\mathsf{\;\;\;\;\;\;\;\;Pair\,\,\,\,\, ::\, Seq \,a \to Seq\,b \to
  Seq\,(a \times b)}\\ 
\end{array}
\end{equation}
\noindent
comprises sequences of any type $\mathsf{a}$ and sequences obtained by
pairing the data in two already existing sequences. By contrast, the
primitive representation sees a GADT as the {\em functorial
  completion}~\cite{jp19} of its syntax. Completing a GADT's syntax to
a {\em functor} is necessary in order to be able to take the least
fixed point~\cite{tfca}, so it is inherent in the view of data types
as their primitive representations. Viewed as its primitive
representation, $\mathsf{Seq}$ comprises not just those data elements
representable in syntax, but also all data elements of the form
$\mathsf{map\,f\,s}$ for all types $\mathsf{t_1}$ and $\mathsf{t_2}$,
all functions $\mathsf{f : t_1 \to t_2}$ definable in the language,
and all $\mathsf{s :: Seq\,t_1}$, as well as all data elements of the
form $\mathsf{map\,g\,s'}$ for each appropriately typed function
$\mathsf{g}$ and each element $\mathsf{s'}$ already added to the data
type, and so on. Functorial completion for $\mathsf{Seq}$ adds, in
particular, data elements of the form
$\mathsf{map\,g\,(Pair\,u_1\,u_2)}$ even though these may not
themselves be of the form $\mathsf{Pair\,v_1\,v_2}$ for any terms
$\mathsf{v_1}$ and $\mathsf{v_2}$. By contrast, functorial completion
adds no new data elements to the syntax of a GADT that is actually a
(polynomial) ADT or a (hereditarily polynomial) nested type, so its
Church encoding and primitive representation coincide. However, these
representations are rarely the same for GADTs.

But does it really matter which way we view GADTs?

A GADT programmer is likely to use GADTs precisely {\em because} they
exhibit different behaviors at different types, and thus to consider a
GADT to be completely specified by its syntax. When used this way, the
shape of a particular element of a GADTs is actually {\em determined}
by the data it contains. As a result, it is not expected to support a
$\mathsf{map}$ function --- i.e., to be an instance of Haskell's
$\mathsf{Functor}$ class --- like other data types. Indeed, the
definition for $\mathsf{Seq}$ above specifies that an element of the
form $\mathsf{Pair\,u_1\,u_2}$ must have the shape of a sequence of
data of pair type rather than a sequence of data of arbitrary type
$\mathsf{e}$.  The clause of $\mathsf{map}$ for the $\mathsf{Pair}$
constructor should therefore feed $\mathsf{map}$ a function $\mathsf{f
  :: (a \times b) \to e}$ and a term of the form $\mathsf{Pair
  \,u_1\,u_2}$ for $\mathsf{u_1 :: Seq\,a}$ and $\mathsf{u_2 ::
  Seq\,b}$, and produce a term $\mathsf{Pair\,v_1\,v_2}$ for some
appropriately typed terms $\mathsf{v_1}$ and $\mathsf{v_2}$. However,
it is not clear how to achieve this since $\mathsf{e}$ need not
necessarily be a product type. And even if $\mathsf{e}$ {\em were}
known to be of the form $\mathsf{w \times z}$, then we still wouldn't
necessarily have a way to produce data of type $\mathsf{w \times z}$
from only $\mathsf{f :: a \times b \to w \times z}$ and $\mathsf{u_1}$
and $\mathsf{u_2}$ unless we knew, e.g., that $\mathsf{f}$ was a pair
of functions $\mathsf{(f_1 :: a \to w, f_2 :: b \to z)}$. When it is
intended to capture this kind of non-uniform behavior, a GADT's
behavior does not generalize that of ADTs as advertised, and the GADT
doesn't even really behave like a traditional data type. In this
situation, the GADT cannot be seen as the least fixpoint of a functor,
and must instead be represented via its Church encoding.

A semanticist, on the other hand, is likely to follow~\cite{bfss90}
and expect GADTs to behave as their names suggests --- i.e., as
generalizations of ADTs. The semanticist is thus likely to expect a
GADT to be able to be used as a ADT is used --- i.e., as a shape
filled with data that can be changed without also changing the
shape. To be used in this way, a GADT must be viewed in terms of its
primitive representation. In fact, the functorial completion of a GADT
inherent in its primitive representation is exactly what is needed to
ensure that the GADT supports a $\mathsf{map}$ function, i.e., is
interpreted as a true categorical functor, and can therefore be made
an instance of Haskell's $\mathsf{Functor}$ class. It is worth noting,
however, that since the functorial completion of a GADT includes
{\color{blue} only?} those data elements that are derivable via
repeated applications of $\mathsf{map}$ starting from those specified
by its syntax, primitive GADTs need not, in general, be nested
types. For example, the functorial completion of the GADT $\mathsf{G}$
defined by
\begin{equation}\label{eq:G}
\begin{array}{l}
\mathsf{data\,G\,a\,where}\\
\mathsf{\;\;\;\;\;\;\;\;c :: G\,1}
\end{array}
\end{equation}
Here, $\mathsf{1}$ is the unit type, whose single element is also
denoted by $\mathsf{1}$, includes elements at any instance
$\mathsf{G\,a}$ for any type $\mathsf{a}$ that is not the empty type
$\mathsf{0}$ since there is always a function from $\mathsf{1}$ to
such an $\mathsf{a}$, but does not include any terms at instance
$\mathsf{G\,0}$. Indeed, $\mathsf{G\,0}$ is not inhabited via the
syntactic specification of $\mathsf{G}$, and is not inhabited via
functorial completion because it is not possible to define a function
from $\mathsf{1}$ into $\mathsf{0}$.

The key observation of this paper is that, while the viewpoints of
both the GADT programmer and the semanticist are both valid, the two
are irreconcilable. Importantly, which point of view is adopted in any
particular setting has deep consequences for the ways GADTs can be
used and reasoned about there. In this paper we show that the choice
of GADT representation has deep implications for parametric reasoning
about structures of those types. In particular, a GADT programmer who
views GADTs as their Church encodings cannot safely use program
transformations or reasoning principles for them that involve
$\mathsf{map}$ functions for them, although they may be able to
program with and reason about GADTs using other consequences of
parametricity, such as type inhabitation results. On the other hand, a
semanticist who views GADTs as primitive data types will have all
naturality-based program transformations and reasoning principles for
GADTs at their disposal, but, since no parametric model can be
constructed for primitive GADTs, non-naturality consequences of
parametric reasoning may not be available to them.

Below we show how the above observations can be made precise, thereby
answering the question we posed above in the affirmative: Yes, it
really does matter which way we view GADTs.

\section{Representations of Algebraic Data Types}\label{sec:adts}

A (polynomial) {\em algebraic data type} (ADT) has the form
\[\mathsf{T\,a} = \mathsf{c_1 t_{11}}...\mathsf{t_{1k_1}}\, |\, ...\, |\,
\mathsf{c_n t_{n1}}...\mathsf{t_{nk_n}}\] where each $\mathsf{t_{ij}}$
is a type also depending only on $\mathsf{a}$. Such a data type can be
thought of as a ``container'' for data of type $\mathsf{a}$. The data
in an ADT are arranged at various {\em positions} in its underlying
{\em shape}, which is determined by the types of its {\em
  constructors} $\mathsf{c_1},...,\mathsf{c_n}$. An ADT's constructors
are used to build the data values of the data type, as well as to
analyze those values using {\em pattern matching}. ADTs are used
extensively in functional programming to structure computations, to
express invariants of the data over which computations are defined,
and to ensure the type safety of programs specifying those
computations.

List types are the quintessential examples of ADTs. The shape of the
container underlying the list type
\[\mathsf{List\,a} = \mathsf{Nil} \,|\, \mathsf{Cons\,a\,(List\,a)}\]
is determined by the types of its two constructors $\mathsf{Nil\, ::\,
  List\, a}$ and $\mathsf{Cons \,::\,a \to \List\,a\to
  List\,a}$. These constructors specify that the data in a list of
type $\mathsf{List\,a}$ are arranged linearly. The shape underlying
the type $\mathsf{List\,a}$ is therefore given by the set $\nat$ of
natural numbers, with each natural number representing a choice of
length for a list structure, and the positions in a structure of shape
$\mathsf{n}$ are given by natural numbers ranging from $\mathsf{0}$ to
$\mathsf{n-1}$. Since the type argument to every occurrence of the
type constructor $\mathsf{List}$ in the right-hand side of above
definition is the same the type instance being defined on its
left-hand side, the type $\mathsf{List\,a}$ enforces the invariant
that all of the data in a structure of this type have the same type
$\mathsf{a}$. In a similar way, the tree type
\[\mathsf{Tree\, a} = \mathsf{Leaf\,a}
\,|\,\mathsf{Node\,(Tree\,a)\,a\,(Tree\,a)}\] of binary trees has as
its underlying shape the type of binary trees of units, and the
positions in a structure of this type are given by sequences of L (for
``left'') and R (for ``right'') navigating a path through the
structure. The type $\mathsf{Tree\, a}$ enforces the invariant that
all of the data at the nodes and leaves in a structure of this type
have the same type $\mathsf{a}$.

Since the shape of an ADT structure --- i.e., a structure whose type
is an instance of an ADT --- is independent of the type of data it
contains, ADTs can be defined polymorphically. As a result, an ADT
structure containing data of type $\mathsf{a}$ can be transformed into
another ADT structure of the exact same shape containing data of
another type $\mathsf{b}$ simply by applying a given function
$\mathsf{f \,:\,a \to b}$ to each of its elements. Indeed, every ADT
$\mathsf{T}$ can be made an instance of Haskell's $\mathsf{Functor}$
class by defining a type-and-data-uniform, structure-preserving,
data-changing $\mathsf{fmap_T}$ function for it.  Moreover, given a
type-independent way of rearranging an ADT structure's shape
$\mathsf{T\,a}$ into the shape for another ADT structure
$\mathsf{T'\,a}$, we get the same structure of type $\mathsf{T'\,b}$
regardless of whether we first rearrange the original structure of
type $\mathsf{T\,a}$ into one of type $\mathsf{T'\,a}$ and then use
$\mathsf{fmap_{T'}}$ to convert that resulting structure to one of
type $\mathsf{T'\,b}$, or we first use $\mathsf{fmap_T}$ to convert
the original structure of type $\mathsf{T\,a}$ to one of type
$\mathsf{T\,b}$ and then rearrange that resulting structure into one
of type $\mathsf{T'\,b}$. For example, if $\mathsf{f : a \to b}$,
$\mathsf{xs \,:\,List\,a}$, and $\mathsf{g : List\,a\to Tree\,a}$
arranges lists into trees in a type-independent way, then we have the
following rearrange-transform property:
\[\mathsf{fmap_{Tree}\,f\,(g \, xs) \,=\, g\,(fmap_{List}\,f\,xs)}\]

\subsection{Church Encodings of ADTs}

One way to represent ADTs is via their Church encodings. A Church
encoding is a representation of a data type as a function in a pure
lambda calculus, such as System F and its higher-kinded
extensions. They, together with other related encodings, have recently
been popularized as various {\em visitor patterns} in object-oriented
programming~\cite{owg08,gon21}.

Church encodings of ADTs can be defined in any language that supports
functions. They can therefore be used to represent ADTs in languages
that do not support primitives for sum types, product types, or
recursion. The Church encodings of the ADTs $\mathsf{List\,a}$ and
$\mathsf{Tree\,a}$, for example, are
\[\mathsf{List\,a} = \mathsf{\forall b.\,b \to (a \to b \to b) \to b}\]
and 
\[\mathsf{Tree\,a} = \mathsf{\forall b.\,(a \to b) \to (b \to a \to b
  \to b) \to b}\] respectively. The argument types are abstractions of
the types of ADTs' constructors. For instance, $\mathsf{b}$ abstracts
the type $\mathsf{List\,a}$ of the constructor $\mathsf{Nil}$ for
lists, and $\mathsf{a \to b \to b}$ abstracts the type $\mathsf{a \to
  List\,a \to List\,a}$ of the constructor $\mathsf{Cons}$.

Because the types of the ``abstract constructors'' for an ADT are
uniform in their argument types, it is always possible to Church
encode the type constructors themselves as well. For example, the
Church encodings of the type constructors $\mathsf{List}$ and
$\mathsf{Tree}$ are
\[\mathsf{List} = \mathsf{\forall a. \forall b.\,b \to (a \to b \to b)
  \to b}\] 
and 
\[\mathsf{Tree} = \mathsf{\forall a. \forall b.\,(a \to b) \to (b \to
  a \to b \to b) \to b}\] respectively. This is what allows an ADT's
associated type constructor to be made an instance of Haskell's
$\mathsf{Functor}$ class. For example, Haskell's built-in
$\mathsf{map}$ function makes the type constructor $\mathsf{List}$ an
instance of the $\mathsf{Functor}$ class, and for $\mathsf{Tree}$ we
can define
\[\begin{array}{lll}
\mathsf{map_{Tree}} & \mathsf{::} & \mathsf{(a \to b) \to Tree\,a \to Tree \,b}\\
\mathsf{map_{Tree}\, f\, (Leaf\,x)} & \mathsf{=} & \mathsf{Leaf\,(f\,x)}\\
\mathsf{map_{Tree}\, f\, (Node\,t_1\,x\,t_2)} & \mathsf{=} &
\mathsf{Node\,(map_{Tree}\, f \,t_1)\,x\,(map_{Tree}\,f\,t_2)}\\
\end{array}\]
Note, however, that the Church encoding of an ADT carries with it no
expectation whatsoever that such a type-and-data-uniform,
structure-preserving, data-changing $\mathsf{map}$ function can be
defined. It therefore need not satisfy any rearrange-transform
property either.

\subsection{ADTs as Primitive Data Types}

By contrast, the ability to define such a $\mathsf{map}$ function is
inherent in the view of ADTs as primitive data types. Such a view is
possible in any language that supports primitives for sum types,
product types, and recursion. In such a language, the primitive
representations of the ADTs $\mathsf{List\,a}$ and $\mathsf{Tree\,a}$
are
\begin{equation}\label{eq:list}
  \mathsf{List\,a} = \mathsf{\mu X.\, 1 + a \times X}
\end{equation}
and 
\begin{equation}\label{eq:tree}
  \mathsf{Tree\,a} = \mathsf{\mu X.\, a + X \times a \times X}
\end{equation}
respectively, where $\mathsf{\mu}$ is a primitive fixpoint operator.

Primitive representations capture in syntax the fact that ADTs can be
considered as fixpoints. For example $\mathsf{List\,a}$ is indeed a
fixpoint of $\mathsf{F_{List\,a}}$, where $\mathsf{F_{List\,a}\,X} =
\mathsf{1 + a \times X}$ as determined by~\eqref{eq:list}, i.e., is
indeed such that
\[\mathsf{List\,a} = \mathsf{1 + a \times List\,a}\] 
since every element of $\mathsf{List\,a}$ is either empty or is
obtained by $\mathsf{Cons}$ing an element of type $\mathsf{a}$ onto an
already-existing structure of type $\mathsf{List\,a}$. In fact, this
fixpoint equation is just a rewriting of the Haskell data type
declaration for $\mathsf{List\,a}$. We therefore have that
$\mathsf{List\, a} = \mathsf{\mu F_{List\,a}}$ is modeled by $\mu
F_{\mathit{List}\,a}$, where the functor $F_{\mathit{List}\,a}$ models
the type constructor $\mathsf{F_{List\,a}}$. Similarly, the ADT
$\mathsf{Tree\,a}$ can be seen to be a fixpoint of
$\mathsf{F_{Tree\,a}}$, where $\mathsf{F_{Tree\,a}\,X} = \mathsf{a + X
  \times a \times X}$ as determined by~\eqref{eq:tree}, so that
$\mathsf{Tree\, a} = \mathsf{ \mu F_{Tree\,a}}$ is modeled by $\mu
F_{\mathit{Tree}\,a}$, where $F_{\mathit{Tree}\,a} $ models
$\mathsf{F_{Tree\,a}}$.
 
These kinds of fixpoint equations are entirely sensible at the level
of types. But to ensure that the syntactic fixpoint representing an
ADT actually denotes a semantic object computed as a real-live
fixpoint, the semantic fixpoint calculation must converge.  If, as is
typical, we interpret our types as sets, then this means that the
fixpoint being taken must be of a {\em functor} on the category
$\mathit{Set}$ of sets and functions between them, rather than of a
mere function between sets~\cite{tfca}.  That is, the function $F$
interpreting the type constructor $\mathsf{F}$ constructing the body
of a syntactic fixpoint must not only have an action on sets, but must
also have a {\em functorial action} on functions between
sets. Reflecting this requirement back into syntax gives that
$\mathsf{F}$ must support a suitable\footnote{The $\mathsf{map}$
  function for $\mathsf{F}$ should satisfy syntactic reflections of
  the functoriality properties in $\mathit{Set}$ --- i.e.,
  preservation of identity functions and composition of functions ---
  even though there is no mechanism in Haskell for enforcing this.}
$\mathsf{map}$ function, i.e., must be an instance of Haskell's
$\mathsf{Functor}$ class.

Requiring $F$ to be a functor will ensure that the interpretation $\mu
F$ of the ADT $\mathsf{T\,a} = \mathsf{\mu F}$ exists. But to ensure
that $\mu F$ is itself a functor, so that the type constructor
$\mathsf{T}$ associated with the ADT $\mathsf{T\,a}$ supports a
$\mathsf{map}$ function as well, we can require that $F$ also be the
fixpoint $\mu H$ of a functor $H$. In this case, however, $H$ must be
a functor on the category $\mathit{Set}^\mathit{Set}$ of functors and
natural transformations on $\mathit{Set}$. That is, $H$ must be a {\em
  higher-order} functor on $\mathit{Set}$. Reflecting this requirement
back into syntax gives that
$\mathsf{T\,a} = \mathsf{(\mu H)\,a}$
for the ``type constructor constructor''
$\mathsf{H}$ that supports suitable\footnote{The $\mathsf{map}$
  function for $\mathsf{H}$ should satisfy syntactic reflections of
  the functoriality properties in $\mathit{Set}^\mathit{Set}$ ---
  i.e., preservation of identity natural transformations and
  composition of natural transformations --- and the $\mathsf{map}$
  function for $\mathsf{H\,F}$ should satisfy syntactic reflections of
  the functoriality properties in $\mathit{Set}$ as in the previous
  footnote. Again, there is no mechanism in Haskell for enforcing
  this.} $\mathsf{map}$ functions. 

%class HFunctor f where
%  ffmap :: Functor g => (a -> b) -> f g a -> f g b
%  hfmap :: (g :~> h) -> f g :~> f h
%
%  type (~>) f g = forall x. f x -> g x
       
      
A concrete example is given by the ADT $\mathsf{List\,a}$. This type
is modeled as the fixpoint $\mu F_{\mathit{List\,a}}$ of the
first-order functor whose action on sets is given by
$F_{\mathit{List}\,a}\,X = 1 + a \times X$ and whose action on
functions is given by $F_{\mathit{List}\,a}\,f = 1 + \id_a \times
f$. The type constructor $\mathsf{List}$ is modeled by the functor
that is the fixpoint $\mu H$ of the higher-order functor $H$ whose
action on a functor $F$ is given by the functor $H\,F$ whose actions
on sets and functions between them are given by $H\,F\,X = 1 + X
\times F\,X$ and $H\,F\,f = \id_1 + f \times F\,f$, respectively, and
whose action on a natural transformation $\eta$ is the natural
transformation whose component at $X$ is given by $(H\,\eta)_X = \id_1
+ \id_X \times \eta_X$. Reflecting the functorial action of $\mu H$
back into syntax gives exactly Haskell's built-in $\mathsf{map}$
function as the type-and-data-uniform, structure-preserving,
data-changing function associated with $\mathsf{List}$.

In a parametric model, short cut fusion can be used to show that the
Church encoding and the primitive representation of an ADT are
isomorphic as sets. Note, however, that whereas it is impossible even
to {\em state} the rearrange-transform property for Church encodings
of ADTs {\color{blue} unless we first define $\mathsf{map}$ functions
  for them}, this property is simply the reflection back into syntax
of the instance of naturality for the type-independent function that
rearranges structures of type $\mathsf{T\,a}$ into ones of type
$\mathsf{T'\,a}$ and the content-transforming functions
$\mathsf{map_T\,f}$ and $\mathsf{map_{T'}\,f}$ for a function
$\mathsf{f :: a \to b}$, where $\mathsf{T}$ and $\mathsf{T'}$ are the
type constructors associated with these ADTs, respectively.

\section{Representations of GADTs}\label{sec:gadts}

GADTs relax the restriction on the type instances appearing in a data
type definition. The special form of GADTs known as {\em nested types}
allow the data constructors of a GADT to take as arguments data whose
types involve type instances of the GADT other than the one being
defined. For example, the definition
\[\mathsf{PTree \, a = PLeaf \,a \,|\, PNode \,(PTree\,(a \times
  a))}\] of the nested type $\mathsf{PTree\,a}$ of perfect trees
introduces the data constructor(s $\mathsf{PLeaf :: a \to PTree\,a}$
and) $\mathsf{PNode :: PTree \,(a\times a) \to PTree\,a}$. It enforces
not only the invariant that all of the data in a structure of type
$\mathsf{PTree\,a}$ is of the same type $\mathsf{a}$, but also the
invariant that all perfect trees have lengths that are powers of
2. More general GADTs allow their constructors both to take as
arguments {\em and return as results} data whose types involve type
instances of the GADT other than the one being defined. An example is
the GADT $\mathsf{Seq}$ given in~\eqref{eq:seq}. Note that since the
return type of the data constructor $\mathsf{Pair}$ is not of the form
$\mathsf{Seq\,a}$ for any variable $\mathsf{a}$, $\mathsf{Seq}$ is a
GADT that is not a nested type.

By contrast with the ADT $\mathsf{List\, a}$, where the type parameter
$\mathsf{a}$ is integral to the type being defined, the type parameter
$\mathsf{a}$ appears in both $\mathsf{PTree\,a}$ and $\mathsf{Seq\,a}$
as a ``dummy'' parameter used only to give the kind \verb|* -> *| of
the type constructors $\mathsf{PTree}$ and $\mathsf{Seq}$. This is
explicitly captured in the alternative ``kind signature'' Haskell
syntax
\[\begin{array}{l}
\mathsf{data\, Seq :: * \to *\,where}\\
\mathsf{\;\;\;\;\;\;\;\;Const ::\, a \to Seq\,a}\\
\mathsf{\;\;\;\;\;\;\;\;Pair\,\,\,\,\, ::\, Seq \,a \to Seq\,b \to
  Seq\,(a \times b)}\\ 
\end{array}\]
A GADT --- even a nested type --- thus does not define a {\em family
  of inductive types}, one for each type argument, like an ADT does,
but instead defines an entire family of types that must be constructed
simultaneously. That is, a GADT defines an {\em inductive family of
  types}.

\subsection{Church Encodings of GADTs}\label{sec:CEs}

The syntax of GADTs is consistent with programmers' use of them in
situations where different behaviors at different type instances is
desired. This is achieved by allowing the programmer to give the type
signatures of the different data constructors independently, and then
using pattern matching to force the desired type refinement.  Typical
applications of GADTs include generic programming, modeling
programming languages via higher-order abstract syntax, maintaining
invariants in data structures, and expressing constraints in embedded
domain-specific languages. They have also been used, e.g., to
implement tagless interpreters~\cite{pl04,pr06,pvww06}, to improve
memory performance~\cite{min15}, and to design APIs~\cite{pen20}.

Allowing non-variable type arguments in the return types of a GADT's
data constructors establishes a strong connection between a GADT's
shape and the data it contains. With ADTs, we first choose the shape
of the container and then fill that container with data of whatever
type we like. Critically, the choice of shape is independent of the
data to be stored. With GADTs, however, the shape of the container may
actually {\em depend} on (the type of) the data to be contained. For
example, $\mathsf{Const}$ can create data of any shape
$\mathsf{Seq\,a}$, but $\mathsf{Pair}$ can produce data of shape
$\mathsf{Seq\,a}$ only if $\mathsf{a}$ is a pair type. As a result,
modifying the data in a GADT may actually change the shape of --- or
may even destroy! --- the GADT.

To determine the possible shapes of a GADT's container we have to
pattern-match on the type of the data to be contained. For this, it is
essential that a GADT calculus support an equality type
$\mathsf{Equal}$ that is a singleton set when its two type arguments
are the same and is the empty set otherwise. That is, the type
$\mathsf{Equal}$ must be the syntactic reflection of semantic equality
function $\mathit{Equal}$. The type $\mathsf{Equal}$ can either be
defined via GADT syntax, as in
\[\begin{array}{l}
\mathsf{data\, Equal\,a\,b\,where}\\
\mathsf{\;\;\;\;\;\;\;\;Refl ::\, Equal\,c\,c}\\
\end{array}\]
\noindent
or, equivalently, represented by its Church encoding
\[\mathsf{Equal\,a\,b} = \mathsf{\forall f.\, (\forall c.\,
  f\,c\,c) \to f\,a\,b}\] in a higher-kinded calculus such as
$F_\omega$~\cite{atk12}. Following the technique in Section~4.5
of~\cite{atk12}, we can represent the GADT $\mathsf{Seq}$ as its
Church encoding
\[\mathsf{Seq\,a} = \mathsf{\forall f.\,(\forall d. \,(f\,d + \exists b
  c.\, f\, b \times f \,c \times \mathsf{Equal}\, d \,(b \times c))
  \to f \,d) \to f\, a}\]
This is logically equivalent to the more intuitive encoding
\[\mathsf{Seq\,a} = \mathsf{\forall f.\, (\forall d.\,d \to f\, d)
  \to (\forall b\,c\,d.\,Equal\,d\,(b\times c) \to f\,b \to f\,c \to
  f\,d) \to f\,a}\]


Importantly, the function $\mathit{Equal}\,a$ cannot be made into a
functor. Equivalently, $\mathsf{Equal\,a}$ (in either representation)
cannot be made an instance of Haskell's $\mathsf{Functor}$
class. Indeed, if $\mathsf{Equal\,a}$ supported a function
\[\mathsf{map_{Equal\,a} :: (b \to c) \to Equal\,a\,b \to
  Equal\,a\,c}\]
then defining
\[\begin{array}{l}
\mathsf{eqElim :: Equal\, a\, b \to b \to a}\\
\mathsf{eqElim\, Refl\, x = x} 
\end{array}\]
would allow us to construct
an element
\[\mathsf{eqElim\, (map_{Equal\,0}\, absurd\, Refl)\, 1}\]
of the empty type $\mathsf{0}$, where $\mathsf{absurd :: 0 \to c}$ is
the
%syntactic reflection of the
empty function from  $\mathsf{0}$
%the empty type set
into
%the interpretation of
$\mathsf{c}$.
%{\color{blue} Is there a way to say this without passing to
%semantics?}
But this should be impossible. It is immediate that a GADT that is not
actually a nested type cannot support a $\mathsf{map}$ function (or a
rearrange-transform property) either. In the case of $\mathsf{Seq}$,
this is already intuitively evident from its Haskell definition as
discussed in Section~\ref{sec:intro}.

\subsection{GADTs as Primitive Data Types}\label{sec:prim-gadts}

The Church encoding of a GADT corresponds to the data type comprising
just those elements specified by the GADT's syntax. By contrast, the
primitive representation of a GADT corresponds to the data type
comprising all data elements in the functorial completion of the
GADT's syntax. In this alternate reading, GADTs can, like ADTs, be
modeled as fixpoints of higher-order functors. Syntactically, the use
of higher-order funct{\em ions} is essential; since the type arguments
to the GADT being defined are not necessarily uniform across all of
its instances in the types of its data constructors, GADTs cannot be
seen as fixpoints of first-order functors the way ADTs
can. Semantically, the use of higher-order funct{\em ors} is
essential, as in the case of ADTs, to guarantee the existence of the
fixpoints being computed~\cite{tfca}.

Consider, again, the GADT $\mathsf{Seq}$. Because its type argument
varies in the instances of $\mathsf{Seq}$ appearing in the types of
its data constructor $\mathsf{Pair}$, $\mathsf{Seq}$ cannot be
modeled as the fixpoint of any first-order functor. As shown
in~\cite{jp19}, it can, however, be modeled as a solution to the
higher-order fixpoint equation
\[H\,f\,a = a \,+\,(Lan_{\lambda c d. c \times d}\, \lambda
c d. f c \times f d)\,a\] {\color{red} Check this equation against
  next displayed one below.}  where $Lan_K \,F$ is the left Kan
extension of the functor $F$ along the functor $K$. In general, the
left Kan extension $Lan_K \,F : {\cal E} \to {\cal D}$ of $F : {\cal
  C} \to {\cal D}$ along $K : {\cal C} \to {\cal E}$ is the best
functorial approximation to $F$ that factors through $K$. Here, ``best
functorial approximation'' means that $Lan_K \,F$ is the smallest
functor that both extends the image of $K$ to $\cal D$ and agrees with
$F$ on $\cal C$, in the sense that, for any other such functor $H$,
there is a morphism of functors (i.e., a natural transformation) from
$Lan_K \,F$ to $H$. This is captured formally by the following
definition~\cite{mac71}:
\begin{definition}\label{def:lke}
If $F : {\cal C} \to {\cal D}$ and $K : {\cal C} \to {\cal E}$ are
functors, then the {\em left Kan extension of $F$ along $K$} is a
functor $\mathit{Lan}_K\,F : {\cal E} \to {\cal D}$ together with a
natural transformation $\eta : F \to (\mathit{Lan}_K\,F) \circ K$ such
that, for every functor $H : {\cal E} \to {\cal D}$ and natural
transformation $\gamma : F \to H \circ K$, there exists a unique
natural transformation $\delta : \mathit{Lan}_K\,F \to H$ such that
$(\delta K) \circ \eta = \gamma$. This is depicted in the diagram
\[\begin{tikzcd}[row sep = huge]
{\cal C}
\ar[rr, "{F}"{name=Fa, above}, ""{name=F, below}]
\ar[rd, "{K}"']
&& {\cal D} \\
& {\cal E}
\ar[Rightarrow, bend right = 25, from=F, "{\eta}"']
\ar[ur, bend left, "{\mathit{Lan}_{K}\,F}"{name=Lan, description}]
\ar[ur, bend right, "{H}"'{name=L, right}, ""'{name=Lr, right}]
\ar[Rightarrow, bend left = 45, from=Fa, to=Lr, "{\gamma}" near start]
\ar[Rightarrow, dashed, from=Lan, to=L, "{\delta}"']
\end{tikzcd}\]
\end{definition}

To represent GADTs as primitive data types in a setting in which types
are interpreted as sets, a calculus must support a primitive construct
$\mathsf{Lan}$ such that the type constructor $\mathsf{Lan_k\,f}$ is
the syntactic reflection of the left Kan extension $\Lan_K \,F$ of the
functor $F$ interpreting $\mathsf{f}$ along the functor $K$
interpreting $\mathsf{k}$. In this setting, the categories
$\mathcal{C}$, $\mathcal{D}$, and $\mathcal{E}$ must all be of the form $\mathit{Set}^n$ for some $n$. Using $\mathsf{Lan}$ we can then
rewrite the type of a constructor $\mathsf{c :: f a \to g(k\,a)}$ as
$\mathsf{c :: (Lan_k\,f)\,a \to g\,a}$ since morphisms (i.e., natural
transformations) from $F$ to $G \circ K$ are in one-to-one
correspondence with those from $\mathit{Lan}_K\,F$ to $G$ (see
e.g.,~\cite{rie16}). That is, writing $F \Rightarrow G$ for the set of
natural transformations from a functor $F$ to a functor $G$, we have
\begin{equation}\label{eq:nat-transfs}
F \Rightarrow G \circ K\; \simeq \; Lan_K\,F \Rightarrow G
\end{equation}
The calculus must also support a primitive type
constructor $\mathsf{\mu}$ that is the syntactic reflection of the
(now higher-order) fixpoint operator on
$\mathit{Set}^\mathit{Set}$. Using $\mu$ and $\Lan$ we can then
represent a GADT as a higher-order higher-order fixpoint. For example,
we can represent the GADT $\mathsf{Seq}$ as
\[\mathsf{Seq\,a} = \mathsf{(\mu \phi.\lambda b.\, b + (Lan_{\lambda c
    d. c \times d} \lambda c d. \phi c \times \phi d)\,b)\,a}\] The
fact that $Lan_K\,G$ is the best functorial approximation to $G$
factoring through $K$ means that the type constructor
$\mathsf{Lan_k\,g}$ computes the smallest collection of data that is
generated by the corresponding GADT data constructor's syntax and also
supports a $\mathsf{map}$ function. The primitive representation of
any GADT thus comprises the smallest data type that both includes the
data specified by that GADT's syntax and also supports a
$\mathsf{map}$ function (and thus a rearrange-transform property). In
the primitive view, then, GADTs are generally underspecified by their
syntax.

In this section we have seen that GADTs can be represented either as
Church encodings or as primitive data types. This exactly mirrors the
situation for ADTs described in Section~\ref{sec:adts}. But whereas
the two representations are always isomorphic for ADTs, they are not,
in general, the same for GADTs. This will be proved in the next
section.

\section{Non-Equivalence of Church Encodings and Primitive
  Representations of GADTs}\label{sec:non-equiv}

{\color{blue} Is G or G\,a the GADT?}

To see that the Church encoding of a GADT and its primitive
representation need not be the same, consider again the GADT
$\mathsf{G}$ defined in~\eqref{eq:G}. Despite its simplicity, this
GADT serves as an informative case study highlighting the differences
between a GADT's Church encoding its primitive representation --- even
if we consider only the data elements it contains, and ignore whether
or not it supports a $\mathsf{map}$ function.

\begin{example}\label{ex:g1}
Syntactically, the GADT $\mathsf{G}$ defined in~\eqref{eq:G} comprises
a single data element, namely $\mathsf{c :: G \, 1}$. This is captured
by $\mathsf{G}$'s Church encoding
\[\mathsf{G\,a} = \mathsf{Equal\,1\,a}\]
from~\cite{atk12}. As its Church encoding makes clear, $\mathsf{G}$'s
effect is simply to test its argument for equality against the unit
type $\mathsf{1}$. The interpretation of the Church encoding of
$\mathsf{G}$ is thus, in accordance with Section~\ref{sec:CEs}, the
function whose value is a singleton set when the interpretation of
$\mathsf{a}$ is $1$ and the empty set otherwise. This perfectly
accords with $\mathsf{G}$'s syntax, which indeed delivers just one
data element when $\mathsf{a}$ is $\mathsf{1}$ and no elements
otherwise.

{\color{blue} Use $\mathsf{1}$ in place of $\mathsf{*}$ here?}
To compute the interpretation of $\mathsf{G}$'s primitive
representation we first note that the type of $\mathsf{G}$'s solitary
constructor $\mathsf{c :: G\,1}$ can be equivalently expressed as
$\mathsf{c :: 1 \to G\,1}$ or, using~\eqref{eq:nat-transfs}, as
$\mathsf{c :: (Lan_{\lambda *. 1}\,\lambda *. 1)\,a \to G\, a}$, where
$\mathsf{\lambda *. 1}$ is the syntactic reflection of the constantly
$1$-valued functor from the category with a single object $*$ to
$\mathit{Set}$. We can therefore represent $\mathsf{G}$ as
\[\mathsf{G\,a} = \mathsf{(\mu \phi. \lambda b.
 (Lan_{\lambda *. 1} \,\lambda *.  1)\,b)\,a}\] The interpretation of
$\mathsf{G}$ is therefore the application to $\mathsf{a}$ of the
fixpoint of the interpretation of the body $\mathsf{\lambda
  b. (Lan_{\lambda *. 1} \,\lambda *. 1)\,b}$ of the syntactic
fixpoint $\mathsf{\mu \phi. \lambda b.  (Lan_{\lambda *. 1} \,\lambda
  *.  1)\,b}$. But since the recursion variable $\mathsf{\phi}$ does
not appear in this body, the interpretation of the fixpoint is just
the interpretation of the body itself.  The interpretation of
$\mathsf{G\,a}$ is therefore $(\mathit{Lan}_{\lambda *. 1} \lambda
*. 1)\, A$, where $A$ interprets $\mathsf{a}$.
%and $1$ is the {\color{blue} constantly $1$-valued
%  functor $\ast \to \set$ from the category with a single object
%  $\ast$ to $\set$.}
It turns out, however, that, for any set $A$, $(\mathit{Lan}_{\lambda
  *. 1} \lambda *. 1)\,A$ is, in fact, exactly $A$. Indeed,
Proposition~7.1 of~\cite{blw03} gives that $(\mathit{Lan}_{\lambda
  *. 1} \lambda *. 1)\,A$ can be computed as the set of all functions
$a : 1 \to A$ modulo the smallest equivalence relation $\sim$ such
that, for any $f : 1 \to 1$, we have $a \sim a \circ f$.  But this set
is isomorphic to $A$, because the only function $f : 1 \to 1$ is the
identity function.


Putting it all together, we see that the Church encoding of
$\mathsf{G}$ and its primitive representation are not semantically
equivalent: the interpretation of the former has exactly one data
element at instance $\mathsf{G\,1}$ and no elements at any other
instances, whereas the interpretation of the latter has data elements
at every instance other than $\mathsf{G\,0}$.
%Indeed,
These additional data elements can be obtained by reflecting back into
syntax the elements $\mathit{map}_G\,f_a\,c : G\,A$ resulting from
applying the functorial action $\mathit{map}_G$ of $\mathsf{G}$'s
interpretation $G$ to the functions $f_a : 1 \to A$ determined by the
elements $a$ of $A \not = \emptyset$ and the interpretation $c$ of
$\mathsf{c}$.
\end{example}

Forced to choose, a programmer would likely find the idea that a GADT
contains data not specified by its syntax more than a little
disturbing. What, they might ask, should a data type contain other
than data that are constructed using its data constructors? Why should
a GADT contain ``hidden'' elements that are not specified by the
GADT's syntax and are only accessible via applications of
$\mathsf{map}$ {\color{blue} and other elements, too?}? A semanticist,
on the other hand, would likely find the primitive representation of
GADTs entirely reasonable. Indeed, they would likely find the
nonfunctorial nature of a GADT's Church encoding unnerving at
best. After all, they would likely argue, the data in a GADT shouldn't
disappear just because you map a function over it! The fact that this
happens when GADTs are represented by their Church encodings actually
highlights how GADTs {\em do not} generalize the essential,
container-ish nature of ADTs at all. A semanticist might therefore
conclude that GADTs are seriously misnamed. They might even go on to
wonder: in what sense do GADTs really deserve to be considered {\em
  data types} at all?

The reader familiar with short cut fusion will quickly see that the
non-uniform nature of GADTs that are not nested types entails that
short cut fusion cannot be validated for their Church encodings. In
fact, it is not even possible to define a $\mathsf{build}$ function,
which is a crucial ingredient in short cut fusion, for the Church
encoding of a GADT that is not a nested type. But the fact that not
all of the elements in the functorial completion of a GADT that is not
a nested type are directly representable as applications of data
constructors means that it is also impossible to define a
$\mathsf{build}$ function for the primitive representation of such a
GADT.  This is not surprising, however: if short cut fusion were to
hold for a GADT then its Church encoding and primitive representation
would necessarily be semantically equivalent.

In addition to not being semantically equivalent, the two
representations of GADTs have very different implications for
parametricity. We explore the differences in parametricity results for
GADTs with respect to the two representations in the next section.

\section{Parametricity in the Presence of GADTs}\label{sec:par}

{\em Relational parametricity} encodes a powerful notion of
type-uniformity, or representation independence, for data types in
functional languages. It formalizes the intuition that a polymorphic
program must act uniformly on all of its possible type instantiations
by requiring that every such program preserves all relations between
pairs of types at which it is instantiated. Parametricity was
originally put forth by Reynolds~\cite{rey83} for System F. It was
later popularized as Wadler's ``theorems for free''~\cite{wad89}, so
called because it can deduce properties of programs in such languages
solely from their types, i.e., with no knowledge whatsoever of the
text of the programs involved.  Most of Wadler's free theorems are
consequences of naturality for polymorphic list-processing
functions. However, parametricity can also derive results that go
beyond just naturality, such as proving equivalence of Church
encodings and primitive representations of ADTs and {\color{blue}
  hereditarily polynomial} nested types by validating short cut fusion
for them.

To discuss relational parametricity will need to interpret data types
not just in $\mathit{Set}$, but in a suitable category of relations as
well. The following definition is standard:
\begin{definition}
  The category $\mathit{Rel}$ has:
  \begin{itemize}
\item objects: A relation is a triple $(A,B,R)$, where $R$ is a
  relation between sets $A$ and $B$.
\item morphisms: A morphism from $(A,B,R)$ to $(A',B',R')$ is a pair
  $(f : A \to A',g : B \to B')$ of functions in $\mathit{Set}$ such
  that $(f a,g\,b) \in R'$ if $(a,b) \in R$.
\item identities: The identity morphism on $(A,B,R)$ is the pair
  $(\mathit{id}_A : A \to A, \mathit{id}_B : B \to B)$.
\item composition: Composition is the componentwise composition in
  $\mathit{Set}$. 
\end{itemize}
\end{definition}
\noindent
We write $R : \mathit{Rel}\,(A,B)$ for $(A,B,R) \in \mathit{Rel}$.  If
$R : \mathit{Rel}\,(A,B)$ then we write $\pi_1 R$ and $\pi_2 R$ for
the {\em domain} $A$ and {\em codomain} $B$ of $R$,
respectively. Below, we assume $\pi_1$ and $\pi_2$ are surjective, so
that the relations in $\mathit{Rel}$ are {\em onto}. {\color{blue} Say
  why we care about onto?} We write $\mathit{Eq}_A = (A,A,\{(x,x)~|~ x
\in A\})$ for the {\em equality relation} on the set $A$.

The key idea underlying parametricity is to give each type
$\mathsf{G[a]}$ with one free variable $\mathsf{a}$ a {\em set
  interpretation} $G_0$ taking sets to sets and a \emph{relational
  interpretation} $G_1$ taking relations $R : \mathit{Rel}\,(A,B)$ to
relations $G_1 \,R : \mathit{Rel}\,(G_0 \,A, G_0 \,B)$, and to
interpret each term $\mathsf{t\,(a,x) :: G[a]}$ with one free term
variable $\mathsf{x :: F[a]}$ as a function $t$ associating to each
set $A$ a morphism $t \,A : F_0\,A \to G_0\,A$ in $\mathit{Set}$.
These interpretations are given inductively on the structures of
$\mathsf{G}$ and $\mathsf{t}$ in such a way that they imply two
fundamental theorems. The first is an \emph{Identity Extension Lemma},
which states that $G_1\,\mathit{Eq}_A = \mathit{Eq}_{G_0 A}$, and is
the essential property that makes a model relationally parametric
rather than just induced by a logical relation.  The second is an
\emph{Abstraction Theorem}, which states that, for any $R
:\mathit{Rel}\,(A, B)$, $(t\, A, t\,B)$ is a morphism in
$\mathit{Rel}$ from $(F_0\,A,F_0\,B,F_1\,R)$ to
$(G_0\,A,G_0\,B,G_1\,R)$. The Identity Extension Lemma is similar to
the Abstraction Theorem except that it holds for {\em all} elements of
a type's interpretation, not just those that interpret terms.  Similar
theorems are required for types and terms with any number of free
variables.

The existence of parametric models that interpret GADTs as the
interpretations of their Church encodings follows from, e.g., the
existence of the parametric model of $F_\omega$ constructed
in~\cite{atk12}.  In that model, types are interpreted ``in parallel''
in $\mathit{Set}$ and $\mathit{Rel}$ in the usual way, including the
familiar ``cutting down'' of the interpretations of $\forall$-types to
just those elements that are ``parametric''~\cite{rey83,wad89} to
ensure that the Identity Extension Lemma holds. If {\color{blue} the
  set interpretation of $\mathsf{Equal}$ is the function
  $\mathit{Equal}$ and its relational interpretation is $\mathit{Eq}$}
as intended, then the parametricity property for a GADT is an
inhabitation result saying that the set interpreting any instance of
that GADT contains exactly the interpretations of the data elements
that can be formed using its data constructors and whose type is that
instance. In terms of syntax the parametricity property for a GADT's
Church encoding gives that the GADT is inhabited at any instance for
which data elements can be formed using its data constructors. In
particular, the parametricity property for the GADT $\mathsf{G}$
from~\eqref{eq:G} gives that $\mathsf{G\,a}$ contains a single data
element if $\mathsf{a}$ is semantically equivalent to $\mathsf{1}$ and
none otherwise:

\begin{example}\label{ex:CE-par}
Let $\mathsf{t}$ be a term of type $\mathsf{G}$ for the GADT
$\mathsf{G}$ defined in~\eqref{eq:G}, let $G = (G_0,G_1)$ be the
interpretation of the Church encoding of $\mathsf{G}$, let $t$ be the
interpretation of $\mathsf{t}$, and let $R :
\mathit{Rel}\,(A,B)$. Then $t\, A \in G_0\,A$ and $t\,B \in G_0\,B$
and, by the Abstraction Theorem (Theorem~3) in~\cite{atk12}, $t\,A$
and $t\,B$ must be related in $G_1\,R$. However, under the semantics
given in~\cite{atk12}, {\color{blue} which includes the aforementioned
  interpretations of $\mathsf{Equal}$}, the relational interpretation
$G_1\,R$ of $\mathsf{G}$ is {\color{blue} $\mathit{Eq}_1$ when $R$ is
  the relational interpretation $\mathit{Eq}_1$ of $\mathsf{1}$, and
  the empty relation whenever $R$ differs from
  $\mathit{Eq}_1$}. Reflecting back into syntax we deduce that there
can be no term in the type that is the Church encoding of
$\mathsf{G\,a}$ unless $\mathsf{a}$ is semantically equivalent to
$\mathsf{1}$.
\end{example}

For primitive representations of GADTs the story is completely
different. If, as intended, the set interpretation of
$\mathsf{Lan_k\,f}$ is $\mathit{Lan}_K\,F$, where $K$ is the set
interpretation of $\mathsf{k}$ and $F$ is the set interpretation of
$\mathsf{f}$, then the exact same reasoning give that the relational
interpretation of $\mathsf{Lan_k\,f}$ is $\mathit{Lan}_K\,F$, where
$K$ is the relational interpretation of $\mathsf{k}$ and $F$ is the
relational interpretation of $\mathsf{f}$. But under these
interpretations there can be no parametric model, as the following
example shows.

\begin{example}\label{ex:prim-par}
In any parametric model we must give both a set interpretation and a
relational interpretation for every type as described at the start of
this section. In particular, for every GADT $\mathsf{G}$ we must give
an interpretation $G = (G_0,G_1)$ such that, for every relation $R :
\mathit{Rel}\,(A, B)$, we have $G_1\,R : \mathit{Rel}\,(G_0\,A,
G_0\,B)$. But, as we now show, this is not generally possible when
GADTs are interpreted as the interpretations of their primitive
representations.

Consider again the GADT $\mathsf{G}$ given by~\eqref{eq:G}. The set
interpretation of $\mathsf{G}$ is $\mathit{Lan}_{\lambda
  *\!. 1}\,\lambda *\!. 1$, i.e., is, by the reasoning of
Example~\ref{ex:g1}, the identity functor on $\mathit{Set}$. By the
exact same reasoning, this time in $\mathit{Rel}$ rather than in
$\mathit{Set}$, the relational interpretation of $\mathsf{G}$ is
$\mathit{Lan}_{\lambda *\!.\,\mathit{Eq}_1} \,\lambda
*\!.\,\mathit{Eq}_1$, where $\lambda *\!.\,\mathit{Eq}_1$ is the
constantly $\mathit{Eq}_1$-valued functor from the category with a
single object $*$ to $\mathit{Rel}$.  Indeed, the interpretation is
still a left Kan extension, but now it is the left Kan extension
determined by the functor interpreting the type $\mathsf{\lambda
  *\!. 1}$ in $\mathit{Rel}$. For the Identity Extension Lemma to hold
we would need that, for every relation $R : \mathit{Rel}\,(A, B)$, we
have that $(\mathit{\Lan}_{\lambda *\!.\,\mathit{Eq}_1} \,\lambda
*\!.\,\mathit{Eq}_1)\, R$ is a relation between the sets
$(\mathit{Lan}_{\lambda *. 1}\,\lambda *\!. 1)\, A$ and
$(\mathit{Lan}_{\lambda *. 1}\,\lambda *\!. 1)\,B$, i.e., between the
sets $A$ and $B$. However, we now give a counterexample showing that
this need not be the case.

Consider the relation $R = (1, 2, 1 \times 2)$, where $1 \times 2$ is
the total relation on $1$ and $2$, and thus is onto. We expect
$(\mathit{Lan}_{\lambda *\!.\,\mathit{Eq}_1} \lambda
*\!.\,\mathit{Eq}_1)\, R$ to be a relation with domain $1$. Since left
Kan extensions preserve projections~\cite{rie16}, we can compute the
domain as
\[\pi_1\,\big( (\mathit{Lan}_{\lambda *\!.\,\mathit{Eq}_1} \lambda
*\!.\,\mathit{Eq}_1) \, R \big)\;=\; (\mathit{Lan}_{\lambda
 *\!.\,\mathit{Eq}_1} \lambda *\!. \,1)\, R\] (Note that the left Kan
 extension of $\lambda *\!. \,1$ along $\lambda *\!.\,\mathit{Eq}_1$
 is a functor from $\mathit{Rel}$ to $\mathit{Set}$.) By
 Proposition~7.1 of~\cite{blw03} the left Kan extension on the
 right-hand side can be computed as
\[ \big( \bigcup_{m\, :\, \mathit{Eq}_1 \to R} 1 \big) \; /\; \approx\]
where $\approx$ is the smallest equivalence relation such that $(\ast,
m) \approx (\ast, m')$ for $m, m' : \mathit{Eq}_1 \to R$ if there
exists $f : \mathit{Eq}_1 \to \mathit{Eq}_1$ such that $f (\ast, \ast)
= (\ast, \ast)$ and the following diagram commutes:
\[
\begin{tikzcd}
\mathit{Eq}_1 \ar[rr, "{f}"] \ar[dr, "m"']
&&\mathit{Eq}_1 \ar[dl, "m'"] \\
&R
\end{tikzcd}
\]
The only morphism $f : \mathit{Eq}_1 \to \mathit{Eq}_1$ is $f = (!,
!)$. Since this morphism does satisfy the condition $f (\ast, \ast) =
(\ast, \ast)$, we have that $(\ast, m) \approx (\ast, m')$ if and only
if $m = m'$. Thus
\[ \big( \bigcup_{m\, :\,
  \mathit{Eq}_1 \to R} 1 \big) \; /\; \approx \;\;\; = \;\; \{m :
\mathit{Eq}_1 \to R\} \;=\; \{(!, k_0), (!, k_1)\}\] where $k_0, k_1 :
1 \to 2$ are the constantly $0$-valued and $1$-valued functions in
$\mathit{Set}$, respectively, and therefore $\pi_1\,\big(
(\mathit{Lan}_{\lambda *\!.\,\mathit{Eq}_1} \lambda
*\!.\,\mathit{Eq}_1) \, R \big)$ is not $1$, as would be needed for
the Identity Extension Lemma to hold.  Since the Identity Extension
Lemma does not hold for models in which GADTs are interpreted by the
interpretations of their primitive representations, such models cannot
possibly be parametric.
\end{example}

Taken together, Examples~\ref{ex:CE-par} and~\ref{ex:prim-par} show
that the parametricity properties of GADTs differ greatly depending on
whether they are represented as their Church encodings or represented
as primitive data types. This contrasts sharply with the fact that
both ADTs and nested types have the same parametricity properties
regardless of whether they are represented by their Church encodings
or their primitive representations. {\color{blue} Double-check that
  this last part is true.}

\section{Conclusion}

{\color{blue} Combine these two paragraphs.}

We have shown that GADTs can be considered as data types in two
contrasting ways: as completely determined by their syntax, in which
case they are represented by their Church encodings, or as the
functorial completion of their syntax, in which case they are
represented as primitive data types.  But, regardless of which
representation we choose, GADTs fail to be have the expected
parametricity properties. Indeed, we can read the results of
Section~\ref{sec:par} as showing that i) some standard parametricity
results (e.g., inhabitation results) for calculi representing GADTs as
their Church encodings cannot be extended to calculi that represent
GADTs as primitive data types may not be possible, and ii) some
naturality results (e.g., rearrange-transform properties) for calculi
representing GADTs as primitive cannot be extended to calculi that
represent GADTs as their Church encodings. So, with neither
representation can we obtain {\em both} the naturality consequences of
parametricity {\em and} the non-naturality consequences of
parametricity. Intuitively speaking, this is because a GADT is not a
data type in the usual sense of being a container, and completing it
so that it becomes one destroys the relationally uniform behavior it
must exhibit in a parametric model. Which representation of GADTs the
user chooses can therefore have profound consequences for how they are
able to program with, and reason about, them.

All is not lost, however. Despite there being no parametric models for
calculi incorporating GADTs as primitive data types, we still get all
possible rearrange-transform properties for these types. This means
that analogues of most of Wadler's free theorems for ADTs hold for
GADTs, since almost all of the specific consequences of parametricity
given in~\cite{wad89} (see especially Figure~1) are actually of this
form for list types. In fact, even though such naturality properties
are generally regarded as consequences of {\em parametricity}, they
are actually consequences of data types' {\em functorial semantics}.
On the other hand, despite there being no models interpreting type
constructors as functors for calculi incorporating GADTs as Church
encodings, and thus there being no models validating all
rearrange-transform properties for these types, parametric models for
such calculi do exist, and these can be used, e.g., to determine which
instances of a GADT are inhabited. {\color{blue} Is this all?}

{\color{blue} Comparison with Stephanie and Dmitrios? Comparison with
  Bob's Parametric Model? Other conclusions????} 

\bibliography{gadt-story-references}

\end{document}


That parametricity properties for GADTs in Bob's system are as we
described before is interesting because, for ADTs and nested types,
which GADTs claim to generalize, we expect naturality to be a special
case of parametricity. However, we don't actually get non-trivial
naturality consequences of parametricity for GADTs in Bob's
system. Why? Because this would require GADTs to be interpreted as
functors, which, in Bob's system, requires the programmer to supply a
map function on the interpretation of every GADT defined.  (Bob
requires map functions for fixpoint but then doesn't use them.)
Moreover, each such map function would have to behave
functorially. Bob's system does indeed deliver non-trivial naturality
results for every GADT for which the user can define a map function
that behaves functorially. The problem is that there may not be many
such GADTs (in fact it will not be possible for proper GADTs, i.e.,
GADTs that are not actually nested types).

Perhaps expecting naturality as a special case of parametricity is
wrongheaded, though, since, with its arbitrary forall-types and arrow
types, System F is inherently non-functorial. Using Church encodings,
Bob's system handles arbitrary GADT syntax. However, GADTs are not
guaranteed to behave functorially in his system, and the user is
ultimately tasked with supplying the relevant map functions (and
proving their properties) for any GADTs they want to work with. That
the user must supply the map function for a GADT of interest makes
sense: Church encodings cannot say anything about functorial nature of
data types since they describe only the data (and not the action on
morphisms since they are not required to support map functions).
But Bob doesn't use the map function, and his Church encodings don't
produce data types that support map functions.

Wrt Bob's system we can ask: what good is parametricity for GADTs in a
system that derives only trivial naturality consequences of
parametricity for them? It may be possible to get non-naturality
consequences of parametricity (such as short cut fusion or
VYTINIOTIS'?) for GADTs in Bob's system (IS IT?), but since many of
the most useful consequences of parametricity for ADTs and nested
types are actually naturality results (IS THIS TRUE? MAYBE NOT FOR
GADTs), we'd be missing out on a very large class of expected and
useful free theorems. Indeed, many of Wadler's free theorems are
precisely naturality results for functions over data types (mainly
lists, there). If GADTs really do generalize ADTs (and nested types)
then we would expect to be able to derive analogues for GADTs of the
parametricity results --- including naturality results --- that we can
derive for ADTs. Yet, by design we cannot. 

Tellingly, Bob gives no parametricity properties for GADTs.

In our system we can show that we can recover the expected naturality
consequences of parametricity for (at least a large class of) GADTs
(that can be characterized by a grammar for which every type is
interpreted as a functor, including those characterized as least
fixpoints, i.e., as carriers of initial algebras of functors, i.e., as
primitive data types). The way our system achieves this is by
interpreting GADTs as their functorial completions. So in our system
the interpretations of GADTs are guaranteed to have fmap functions ---
i.e., to be functorial --- and to satisfy the expected naturality
properties. And our free theorems really are free for GADTs that fit
our syntax. But now the bump is elsewhere under the rug: First,
semantically we don't really have the same GADT anymore (functoriality
adds extra data to the data type), and second, our counterexample
shows that we don't get non-naturality consequences of parametricity
even for the data types defined by our grammar.  So this isn't really
what we wanted either.

