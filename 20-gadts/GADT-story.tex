% For double-blind review submission, w/o CCS and ACM Reference (max
% submission space)
\documentclass[acmsmall,screen,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2021}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations
%\citestyle{acmnumeric}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\usepackage[utf8]{inputenc}
\usepackage{ccicons}
\usepackage{verbatim}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amscd}
%\usepackage{MnSymbol}
\usepackage{xcolor}

\usepackage{bbold}
\usepackage{url}
\usepackage{upgreek}
%\usepackage{stmaryrd}

\usepackage{lipsum}
\usepackage{tikz-cd}
\usetikzlibrary{cd}
\usetikzlibrary{calc}
\usetikzlibrary{arrows}

\usepackage{bussproofs}
\EnableBpAbbreviations

\input{macros}
\input{mytheorem}

\theoremstyle{definition}
\newtheorem{exmpl}{Example}

\renewcommand{\greyout}[1]{}

\newcommand{\new}[1]{{\color{blue} {#1}}}


\newcommand{\emptyfun}{{[]}}
\newcommand{\cal}{\mathcal}
\newcommand{\F}{\mathcal{F}}
\renewcommand{\G}{\mathcal{G}}
\newcommand{\N}{\mathcal{N}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\B}{\mathcal{B}}
\renewcommand{\P}{\mathcal{A}}
\newcommand{\pred}{\mathsf{Fam}}
\newcommand{\env}{\mathsf{Env}}
\newcommand{\set}{\mathsf{Set}}
\renewcommand{\S}{\mathcal S}
\renewcommand{\C}{\mathcal{C}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\A}{\mathcal{A}}
\renewcommand{\id}{\mathit{id}}
\newcommand{\map}{\mathsf{map}}
\newcommand{\pid}{\underline{\mathit{id}}}
\newcommand{\pcirc}{\,\underline{\circ}\,}
\newcommand{\pzero}{\underline{0}}
\newcommand{\pone}{\underline{1}}
\newcommand{\psum}{\,\underline{+}\,}
\newcommand{\pinl}{\underline{\mathit{inL}}\,}
\newcommand{\pinr}{\underline{\mathit{inR}}\,}
\newcommand{\ptimes}{\,\underline{\times}\,}
\newcommand{\ppi}{\underline{\pi_1}}
\newcommand{\pppi}{\underline{\pi_2}}
\newcommand{\pmu}{\underline{\mu}}
\newcommand{\semmap}{\mathit{map}}
\newcommand{\subst}{\mathit{subst}}

\newcommand{\tb}[1]{~~ \mbox{#1} ~~}
\newcommand{\listt}[1]{(\mu \phi. \lambda \beta . \onet + \beta \times
  \phi \beta) #1} 
\newcommand{\filtype}{\Nat^\emptyset 
 (\Nat^\emptyset \, \alpha \, \mathit{Bool})\, (\Nat^\emptyset 
  (List \, \alpha) \, (List \, \alpha))} 
\newcommand{\filtypeGRose}{\Nat^\emptyset 
 (\Nat^\emptyset \, \alpha \, \mathit{Bool})\, (\Nat^\emptyset 
  (\mathit{GRose}\,\psi \, \alpha) \, (\mathit{GRose}\,\psi \, (\alpha
  + \onet)))} 
\newcommand{\maplist}{\mathit{map}_{\lambda A. \setsem{\emptyset; \alpha
      \vdash \mathit{List} \, \alpha} \rho[\alpha := A]}} 
\newcommand{\PLeaves}{\mathsf{PLeaves}}
\newcommand{\swap}{\mathsf{swap}}
\newcommand{\reverse}{\mathsf{reverse}}
\newcommand{\Bcons}{\mathit{Bcons}}
\newcommand{\Bnil}{\mathit{Bnil}}

\title[Parametricity Consequences of GADTs
  Representations]{Parametricity Consequences of GADTs
  Representations}

\author{Patricia Johann, Enrico Ghiorzi, and Daniel Jeffries}
\affiliation{ \institution{Appalachian State University}}
\email{johannp@appstate.edu, ghiorzie@appstate.edu,
  jeffriesd@appstate.edu}

\begin{document}

\begin{abstract}
{\color{red} FIX ME!} GADTs are misnamed. They don't really generalize
ADTs. And they don't behave the way we expect data types to behave. In
particular, they force us to choose between the naturality properties
we expect of their fmap functions and other parametricity results for
them, causing us to question in what sense GADTs are data types, and
what the value of the parametricity results for them as determined by
their syntax really is.
\end{abstract}

\maketitle

\section{Introduction}\label{sec:intro}
{\color{blue} map vs. fmap throughout.} {\color{blue} Add polynomial
  throughout?}

There are two standard ways to represent data types when studying
modern functional languages: via their Church encodings in a (possibly
higher-kinded) extension of System F~\cite{gir72}, the calculus at the
core of all such languages, and by augmenting System F
%a Hindley-Milner style calculus
with primitives for constructing them directly as fixpoints.
%{\color{blue} Something about when each of these representations is
%  used. The former perhaps more closely represents how data types are
%  represented in implementations, but the latter are how they have
%  heretofore primarily been treated theoretically.}
In models that validate the program optimization known as {\em short
  cut fusion}~\cite{glp93} the two representations are, in fact,
semantically equivalent, i.e., both have the same interpretation in
the model. Models in which the Church encodings and primitive
representations of all algebraic data types (ADTs) are semantically
equivalent include the operationally-based model of~\cite{pit98,pit00}
and the categorical models of~\cite{joh02,joh03}.
%\footnote{{\color{blue} Pitts proves the isomorphism only for
%    polynomial ADTs, whereas Johann {\em et al.}  prove it for any
%    data type that is the fixpoint of a first-order functor.}}
Correctness of short cut fusion, and thus semantic equivalence of
Church encodings and primitive representations, was recently extended
to the class of what might be called ``hereditarily polynomial''
{\color{blue} to include truly nested such types} nested types via the
categorical model of~\cite{jgj21}. But, as shown in
Section~\ref{sec:par} below, for some GADTs --- even polynomial ones
--- no such isomorphism holds.

GADTs are traditionally represented via Church encodings. In this
view, GADTs are completely determined by their syntax; for example,
the GADT $\mathsf{Seq}$ defined in Haskell by
\begin{equation}\label{eq:seq}
\begin{array}{l}
\mathsf{data\, Seq\,a\,where}\\
\mathsf{\;\;\;\;\;\;\;\;Const ::\, a \to Seq\,a}\\
\mathsf{\;\;\;\;\;\;\;\;Pair\,\,\,\,\, ::\, Seq \,a \to Seq\,b \to
  Seq\,(a \times b)}\\ 
\end{array}
\end{equation}
\noindent
comprises sequences of any type $\mathsf{a}$ and sequences obtained by
pairing the data in two already existing sequences. By contrast, the
primitive representation sees a GADT as the {\em functorial
  completion}~\cite{jp19} of its syntax. Completing a GADT's syntax to
a {\em functor} is necessary in order to be able to take the least
fixed point~\cite{tfca}, so it is inherent in the view of data types
as their primitive representations. Viewed as its primitive
representation, $\mathsf{Seq}$ comprises not just those data elements
representable in syntax, but also all data elements of the form
$\mathsf{map\,f\,s}$ for all types $\mathsf{t_1}$ and $\mathsf{t_2}$,
all functions $\mathsf{f : t_1 \to t_2}$ definable in the language,
and all $\mathsf{s :: Seq\,t_1}$, as well as all data elements of the
form $\mathsf{map\,g\,s'}$ for each appropriately typed function
$\mathsf{g}$ and each element $\mathsf{s'}$ already added to the data
type, and so on. Functorial completion for $\mathsf{Seq}$ adds, in
particular, data elements of the form
$\mathsf{map\,g\,(Pair\,u_1\,u_2)}$ even though these may not
themselves be of the form $\mathsf{Pair\,v_1\,v_2}$ for any terms
$\mathsf{v_1}$ and $\mathsf{v_2}$. By contrast, functorial completion
adds no new data elements to the syntax of a GADT that is actually a
(polynomial) ADT or a (hereditarily polynomial) nested type, so its
Church encoding and primitive representation coincide. However, these
representations are rarely the same for GADTs.

But does it really matter which way we view GADTs?

A GADT programmer is likely to use GADTs precisely because they
exhibit different behaviors at different types, and thus to consider a
GADT to be completely specified by its syntax. When used this way, the
shape of a particular element of a GADTs is actually {\em determined}
by the data it contains. As a result, it is not expected to support a
$\mathsf{map}$ function --- i.e., to be an instance of Haskell's
$\mathsf{Functor}$ class --- like other data types. Indeed, the
definition for $\mathsf{Seq}$ above specifies that an element of the
form $\mathsf{Pair\,u_1\,u_2}$ must have the shape of a sequence of
data of pair type rather than a sequence of data of arbitrary type
$\mathsf{e}$.  The clause of $\mathsf{map}$ for the $\mathsf{Pair}$
constructor should therefore feed $\mathsf{map}$ a function $\mathsf{f
  :: (a \times b) \to e}$ and a term of the form $\mathsf{Pair
  \,u_1\,u_2}$ for $\mathsf{u_1 :: Seq\,a}$ and $\mathsf{u_2 ::
  Seq\,b}$, and produce a term $\mathsf{Pair\,v_1\,v_2}$ for some
appropriately typed terms $\mathsf{v_1}$ and $\mathsf{v_2}$. However,
it is not clear how to achieve this since $\mathsf{e}$ need not
necessarily be a product type. And even if $\mathsf{e}$ {\em were}
known to be of the form $\mathsf{w \times z}$, then we still wouldn't
necessarily have a way to produce data of type $\mathsf{w \times z}$
from only $\mathsf{f :: a \times b \to w \times z}$ and $\mathsf{u_1}$
and $\mathsf{u_2}$ unless we knew, e.g., that $\mathsf{f}$ was a pair
of functions $\mathsf{(f_1 :: a \to w, f_2 :: b \to z)}$. When it is
intended to capture this kind of non-uniform behavior, a GADT's
behavior does not generalize that of ADTs as advertised, and the GADT
doesn't even really behave like a traditional data type. In this
situation, the GADT cannot be seen as the least fixpoint of a functor,
and must instead be represented via its Church encoding.

A computer scientist interested in the semantics of functional
languages, on the other hand, is likely to follow~\cite{bfss90} and
expect GADTs to behave as their names suggests --- i.e., as
generalizations of ADTs. The semanticist is thus likely to expect a
GADT to be able to be used as a ADT is used --- i.e., as a shape
filled with data that can be changed without also changing the
shape. To be used in this way, a GADT must be viewed in terms of its
primitive representation. In fact, the functorial completion of a GADT
inherent in its primitive representation is exactly what is needed to
ensure that the GADT supports a $\mathsf{map}$ function, i.e., is
interpreted as a true categorical functor, and can therefore be made
an instance of Haskell's $\mathsf{Functor}$ class. It is worth noting,
however, that since the functorial completion of a GADT includes only
those data elements that are derivable via repeated applications of
$\mathsf{map}$ starting from those specified by its syntax, primitive
GADTs need not, in general, be nested types. For example, the
functorial completion of the GADT $\mathsf{G}$ defined by
\begin{equation}\label{eq:G}
\begin{array}{l}
\mathsf{data\,G\,a\,where}\\
\mathsf{\;\;\;\;\;\;\;\;c : G\,1}
\end{array}
\end{equation}
{\color{blue} Use $\top$ instead of $1$ throughout?} includes elements
at any instance $\mathsf{G\,a}$ for any type $\mathsf{a} \not =
\mathsf{0}$ since there is always a function from $\mathsf{1}$ to such
an $\mathsf{a}$. But $\mathsf{G}$ does not include any terms at
instance $\mathsf{G\,0}$ because $\mathsf{G\,0}$ is not inhabited via
the syntactic specifiation of $\mathsf{G}$, and it is not inhabited
via functorial completion because it is not possible to define a
function from $\mathsf{1}$ into $\mathsf{0}$. {\color{blue} Use $\bot$
  instead of $0$ here?}

The key observation of this paper is that, while the viewpoints of
both the GADT programmer and the semanticist are both valid, the two
are irreconcilable. Importantly, which point of view is adopted in any
particular setting has deep consequences for the ways GADTs can be
used and reasoned about there. In this paper we show that the choice
of GADT representation has deep implications for parametric reasoning
about structures of those types. In particular, a GADT programmer who
views GADTs as their Church encodings cannot safely use program
transformations or reasoning principles for them that involve
$\mathsf{map}$ functions for them, although they may be able to
program with and reason about GADTs using other consequences of
parametricity, such as type inhabitation results. On the other hand, a
semanticist who views GADTs as primitive data types will have all
naturality-based program transformations and reasoning principles for
GADTs at their disposal, but, since no parametric model can be
constructed for primitive GADTs, non-naturality consequences of
parametric reasoning may not be available to them.

The goal of this paper we show how these observations can be made
precise, and therefore to show that how GADTs are viewed has
significant consequences. This paper thus answers the question we
posed above in the affirmative: Yes, it really does matter.

\section{Representations of Algebraic Data Types}\label{sec:adts}

A (polynomial) {\em algebraic data type} (ADT) has the form
\[\mathsf{T\,a} = \mathsf{c_1 t_{11}}...\mathsf{t_{1k_1}}\, |\, ...\, |\,
\mathsf{c_n t_{n1}}...\mathsf{t_{nk_n}}\] where each $\mathsf{t_{ij}}$
is a type also depending only on $\mathsf{a}$. Such a data type can be
thought of as a ``container'' for data of type $\mathsf{a}$. The data
in an ADT are arranged at various {\em positions} in its underlying
{\em shape}, which is determined by the types of its {\em
  constructors} $\mathsf{c_1},...,\mathsf{c_n}$. An ADT's constructors
are used to build the data values of the data type, as well as to
analyze those values using {\em pattern matching}. ADTs are used
extensively in functional programming to structure computations, to
express invariants of the data over which computations are defined,
and to ensure the type safety of programs specifying those
computations.

List types are the quintessential examples of ADTs. The shape of the
container underlying the list type
\[\mathsf{List\,a} = \mathsf{Nil} \,|\, \mathsf{Cons\,a\,(List\,a)}\]
is determined by the types of its two constructors $\mathsf{Nil\, ::\,
  List\, a}$ and $\mathsf{Cons \,::\,a \to \List\,a\to
  List\,a}$. These constructors specify that the data in a list of
type $\mathsf{List\,a}$ are arranged linearly. The shape underlying
the type $\mathsf{List\,a}$ is therefore given by the set $\nat$ of
natural numbers, with each natural number representing a choice of
length for a list structure, and the positions in a structure of shape
$\mathsf{n}$ are given by natural numbers ranging from $\mathsf{0}$ to
$\mathsf{n-1}$. Since the type argument to every occurrence of the
type constructor $\mathsf{List}$ in the right-hand side of above
definition is the same the type instance being defined on its
left-hand side, the type $\mathsf{List\,a}$ enforces the invariant
that all of the data in a structure of this type have the same type
$\mathsf{a}$. In a similar way, the tree type
\[\mathsf{Tree\, a} = \mathsf{Leaf\,a}
\,|\,\mathsf{Node\,(Tree\,a)\,a\,(Tree\,a)}\] of binary trees has as
its underlying shape the type of binary trees of units, and the
positions in a structure of this type are given by sequences of L (for
``left'') and R (for ``right'') navigating a path through the
structure. The type $\mathsf{Tree\, a}$ enforces the invariant that
all of the data at the nodes and leaves in a structure of this type
have the same type $\mathsf{a}$.

Since the shape of an ADT structure --- i.e., a structure whose type
is an instance of an ADT --- is independent of the type of data it
contains, ADTs can be defined polymorphically. As a result, an ADT
structure containing data of type $\mathsf{a}$ can be transformed into
another ADT structure of the exact same shape containing data of
another type $\mathsf{b}$ simply by applying a given function
$\mathsf{f \,:\,a \to b}$ to each of its elements. Indeed, every ADT
$\mathsf{T}$ can be made an instance of Haskell's $\mathsf{Functor}$
class by defining a type-and-data-uniform, structure-preserving,
data-changing $\mathsf{fmap_T}$ function for it.  Moreover, given a
type-independent way of rearranging an ADT structure's shape
$\mathsf{T\,a}$ into the shape for another ADT structure
$\mathsf{T'\,a}$, we get the same structure of type $\mathsf{T'\,b}$
regardless of whether we first rearrange the original structure of
type $\mathsf{T\,a}$ into one of type $\mathsf{T'\,a}$ and then use
$\mathsf{fmap_{T'}}$ to convert that resulting structure to one of
type $\mathsf{T'\,b}$, or we first use $\mathsf{fmap_T}$ to convert
the original structure of type $\mathsf{T\,a}$ to one of type
$\mathsf{T\,b}$ and then rearrange that resulting structure into one
of type $\mathsf{T'\,b}$. For example, if $\mathsf{f : a \to b}$,
$\mathsf{xs \,:\,List\,a}$, and $\mathsf{g : List\,a\to Tree\,a}$
arranges lists into trees in a type-independent way, then
\[\mathsf{fmap_{Tree}\,f\,(g \, xs) \,=\, g\,(fmap_{List}\,f\,xs)}\]

\subsection{Church Encodings of ADTs}

One way to represent ADTs is via their Church encodings. A Church
encoding is a representation of a data type as a function in a pure
lambda calculus, such as System F and its higher-kinded
extensions. They, together with other related encodings, have recently
been popularized as various {\em visitor patterns} in object-oriented
programming~\cite{owg08,gon21}.

Church encodings of ADTs can be defined in any language that supports
functions. They can therefore be used to represent ADTs in languages
that do not support primitives for sum types, product types, or
recursion. The Church encodings of the ADTs $\mathsf{List\,a}$ and
$\mathsf{Tree\,a}$, for example, are
\[\mathsf{List\,a} = \mathsf{\forall b.\,b \to (a \to b \to b) \to b}\]
and 
\[\mathsf{Tree\,a} = \mathsf{\forall b.\,(a \to b) \to (b \to a \to b
  \to b) \to b}\] respectively. The argument types are abstractions of
the types of ADTs' constructors. For instance, $\mathsf{b}$ abstracts
the type $\mathsf{List\,a}$ of the constructor $\mathsf{Nil}$ for
lists, and $\mathsf{a \to b \to b}$ abstracts the type $\mathsf{a \to
  List\,a \to List\,a}$ of the constructor $\mathsf{Cons}$.

Because the types of the ``abstract constructors'' for an ADT are
uniform in their argument types, it is always possible to Church
encode the type constructors themselves as well. For example, the
Church encodings of the type constructors $\mathsf{List}$ and
$\mathsf{Tree}$ are
\[\mathsf{List} = \mathsf{\forall a. \forall b.\,b \to (a \to b \to b)
  \to b}\] 
and 
\[\mathsf{Tree} = \mathsf{\forall a. \forall b.\,(a \to b) \to (b \to
  a \to b \to b) \to b}\] respectively. This is what allows an ADT's
associated type constructor to be made an instance of Haskell's
$\mathsf{Functor}$ class. For example, Haskell's built-in
$\mathsf{map}$ function makes the type constructor $\mathsf{List}$ an
instance of the $\mathsf{Functor}$ class, and for $\mathsf{Tree}$ we
can define
\[\begin{array}{lll}
\mathsf{map_{Tree}} & \mathsf{::} & \mathsf{(a \to b) \to Tree\,a \to Tree \,b}\\
\mathsf{map_{Tree}\, f\, (Leaf\,x)} & \mathsf{=} & \mathsf{Leaf\,(f\,x)}\\
\mathsf{map_{Tree}\, f\, (Node\,t_1\,x\,t_2)} & \mathsf{=} &
\mathsf{Node\,(map_{Tree}\, f \,t_1)\,x\,(map_{Tree}\,f\,t_2)}\\
\end{array}\]
Note, however, that the Church encoding of an ADT carries with it no
expectation whatsoever that such a type-and-data-uniform,
structure-preserving, data-changing $\mathsf{map}$ function can be
defined.

\subsection{ADTs as Primitive Data Types}

By contrast, the ability to define such a $\mathsf{map}$ function is
inherent in the view of ADTs as primitive data types. Such a view is
possible in any language that supports primitives for sum types,
product types, and recursion. In such a language, the primitive
representations of the ADTs $\mathsf{List\,a}$ and $\mathsf{Tree\,a}$
are
\begin{equation}\label{eq:list}
  \mathsf{List\,a} = \mathsf{\mu X.\, 1 + a \times X}
\end{equation}
and 
\begin{equation}\label{eq:tree}
  \mathsf{Tree\,a} = \mathsf{\mu X.\, a + X \times a \times X}
\end{equation}
respectively, where $\mathsf{\mu}$ is a primitive fixpoint operator.

Primitive representations capture in syntax the fact that ADTs can be
considered as fixpoints. For example $\mathsf{List\,a}$ is indeed a
fixpoint of $\mathsf{F_{List\,a}}$, where $\mathsf{F_{List\,a}\,X} =
\mathsf{1 + a \times X}$ as determined by~\eqref{eq:list}, i.e., is
indeed such that
\[\mathsf{List\,a} = \mathsf{1 + a \times List\,a}\] 
since every element of $\mathsf{List\,a}$ is either empty or is
obtained by $\mathsf{Cons}$ing an element of type $\mathsf{a}$ onto an
already-existing structure of type $\mathsf{List\,a}$. In fact, this
fixpoint equation is just a rewriting of the Haskell data type
declaration for $\mathsf{List\,a}$. We therefore have that
$\mathsf{List\, a} = \mathsf{\mu F_{List\,a}}$ is modelled by $\mu
F_{\mathit{List}\,a}$, where the functor $F_{\mathit{List}\,a}$ models
the type constructor $\mathsf{F_{List\,a}}$. Similarly, the ADT
$\mathsf{Tree\,a}$ can be seen to be a fixpoint of
$\mathsf{F_{Tree\,a}}$, where $\mathsf{F_{Tree\,a}\,X} = \mathsf{a + X
  \times a \times X}$ as determined by~\eqref{eq:tree}, so that
$\mathsf{Tree\, a} = \mathsf{ \mu F_{Tree\,a}}$ is modelled by $\mu
F_{\mathit{Tree}\,a}$, where $F_{\mathit{Tree}\,a} $ models
$\mathsf{F_{Tree\,a}}$.
 
These kinds of fixpoint equations are entirely sensible at the level
of types. But to ensure that the syntactic fixpoint representing an
ADT actually denotes a semantic object computed as a real-live
fixpoint, the semantic fixpoint calculation must converge.  If we
interpret our types as sets, then this means that the fixpoint being
taken must be of a {\em functor} on the category $\mathit{Set}$ of
sets and functions between them, rather than of a mere function
between sets~\cite{tfca}.  That is, the function $F$ interpreting the
type constructor $\mathsf{F}$ constructing the body of a syntactic
fixpoint must not only have an action on sets, but must also have a
{\em functorial action} on functions between sets. Reflecting this
requirement back into syntax gives that $\mathsf{F}$ must support a
suitable\footnote{The $\mathsf{map}$ function for $\mathsf{F}$ should
  satisfy syntactic reflections of the functoriality properties in
  $\mathit{Set}$ --- i.e., preservation of identity functions and
  composition of functions --- even though there is no mechanism in
  Haskell for enforcing this.} $\mathsf{map}$ function, i.e., must be
an instance of Haskell's $\mathsf{Functor}$ class.

Requiring $F$ to be a functor will ensure that the interpretation $\mu
F$ of the ADT $\mathsf{T\,a} = \mathsf{\mu F}$ exists. But to ensure
that $\mu F$ is itself a functor, so that the type constructor
$\mathsf{T}$ associated with the ADT $\mathsf{T\,a}$ supports a
$\mathsf{map}$ function as well, we can require that $F$ also be the
fixpoint $\mu H$ of a functor $H$. In this case, however, $H$ must be
a functor on the category $\mathit{Set}^\mathit{Set}$ of functors and
natural transformations on $\mathit{Set}$. That is, $H$ must be a {\em
  higher-order} functor on $\mathit{Set}$. Reflecting this requirement
back into syntax gives that
$\mathsf{T\,a} = \mathsf{(\mu H)\,a}$
for the ``type constructor constructor''
$\mathsf{H}$ that supports suitable\footnote{The $\mathsf{map}$
  function for $\mathsf{H}$ should satisfy syntactic reflections of
  the functoriality properties in $\mathit{Set}^\mathit{Set}$ ---
  i.e., preservation of identity natural transformations and
  composition of natural transformations --- and the $\mathsf{map}$
  function for $\mathsf{H\,F}$ should satisfy syntactic reflections of
  the functoriality properties in $\mathit{Set}$ as in the previous
  footnote. Again, there is no mechanism in Haskell for enforcing
  this.} $\mathsf{map}$ functions. 

%class HFunctor f where
%  ffmap :: Functor g => (a -> b) -> f g a -> f g b
%  hfmap :: (g :~> h) -> f g :~> f h
%
%  type (~>) f g = forall x. f x -> g x
       
      
A concrete example is given by the ADT $\mathsf{List\,a}$. This type
is modelled as the fixpoint $\mu F_{\mathit{List\,a}}$ of the
first-order functor whose action on sets is given by
$F_{\mathit{List}\,a}\,X = 1 + a \times X$ and whose action on
functions is given by $F_{\mathit{List}\,a}\,f = 1 + \id_a \times
f$. The type constructor $\mathsf{List}$ is modelled by the functor
that is the fixpoint $\mu H$ of the higher-order functor $H$ whose
action on a functor $F$ is given by the functor $H\,F$ whose actions
on sets and functions between them are given by $H\,F\,X = 1 + X
\times F\,X$ and $H\,F\,f = \id_1 + f \times F\,f$, respectively, and
whose action on a natural transformation $\eta$ is the natural
transformation whose component at $X$ is given by $(H\,\eta)_X = \id_1
+ \id_X \times \eta_X$. Reflecting the functorial action of $\mu H$
back into syntax gives exactly Haskell's built-in $\mathsf{map}$
function as the type-and-data-uniform, structure-preserving,
data-changing function associated with $\mathsf{List}$.

In a parametric model, short cut fusion can be used to show that the
Church encoding and the primitive representation of an ADT are
isomorphic as sets. Note, however, that whereas it is impossible even
to {\em state} the rearrange-transform property for Church encodings
of ADTs, this property is simply the reflection back into syntax of
the instance of naturality for the type-independent function that
rearranges structures of type $\mathsf{T\,a}$ into ones of type
$\mathsf{T'\,a}$ and the content-transforming functions
$\mathsf{map_T\,f}$ and $\mathsf{map_{T'}\,f}$ for a function
$\mathsf{f :: a \to b}$, where $\mathsf{T}$ and $\mathsf{T'}$ are the
type constructors associated with these ADTs, respectively.

\section{Representations of GADTs}\label{sec:gadts}

GADTs relax the restriction on the type instances appearing in a data
type definition. The special form of GADTs known as {\em nested types}
allow the data constructors of a GADT to take as arguments data whose
types involve type instances of the GADT other than the one being
defined. For example, the definition
\[\mathsf{PTree \, a = PLeaf \,a \,|\, PNode \,(PTree\,(a \times
  a))}\] of the nested type $\mathsf{PTree\,a}$ of perfect trees
introduces the data constructor(s $\mathsf{PLeaf :: a \to PTree\,a}$
and) $\mathsf{PNode :: PTree \,(a\times a) \to PTree\,a}$. It enforces
not only the invariant that all of the data in a structure of type
$\mathsf{PTree\,a}$ is of the same type $\mathsf{a}$, but also the
invariant that all perfect trees have lengths that are powers of
2. More general GADTs allow their constructors both to take as
arguments {\em and return as results} data whose types involve type
instances of the GADT other than the one being defined. An example is
the GADT $\mathsf{Seq}$ given in~\eqref{eq:seq}. Note that since the
return type of the data constructor $\mathsf{Pair}$ is not of the form
$\mathsf{Seq\,a}$ for any variable $\mathsf{a}$, $\mathsf{Seq}$ is a
GADT that is not a nested type.

By contrast with the ADT $\mathsf{List\, a}$, where the type parameter
$\mathsf{a}$ is integral to the type being defined, the type parameter
$\mathsf{a}$ appears in both $\mathsf{PTree\,a}$ and $\mathsf{Seq\,a}$
as a ``dummy'' parameter used only to give the kind \verb|* -> *| of
the type constructors $\mathsf{PTree}$ and $\mathsf{Seq}$. This is
explicitly captured in the alternative ``kind signature'' Haskell
syntax
\[\begin{array}{l}
\mathsf{data\, Seq :: * \to *\,where}\\
\mathsf{\;\;\;\;\;\;\;\;Const ::\, a \to Seq\,a}\\
\mathsf{\;\;\;\;\;\;\;\;Pair\,\,\,\,\, ::\, Seq \,a \to Seq\,b \to
  Seq\,(a \times b)}\\ 
\end{array}\]
A GADT --- even a nested type --- thus does not define a {\em family
  of inductive types}, one for each type argument, like an ADT does,
but instead defines an entire family of types that must be constructed
simultaneously. That is, a GADT defines an {\em inductive family of
  types}.

\subsection{Church Encodings of GADTs}\label{sec:CEs}

The syntax of GADTs is consistent with programmers' use of them in
situations where different behaviors at different type instances is
desired. This is achieved by allowing the progammer to give the type
signatures of the different data constructors independently, and then
using pattern matching to force the desired type refinement.  Typical
applications of GADTs include generic programming, modeling
programming languages via higher-order abstract syntax, maintaining
invariants in data structures, and expressing constraints in embedded
domain-specific languages. They have also been used, e.g., to
implement tagless interpreters~\cite{pl04,pr06,pvww06}, to improve
memory performance~\cite{min15}, and to design APIs~\cite{pen20}.

Allowing non-variable type arguments in the return types of a GADT's
data constructors establishes a strong connection between a GADT's
shape and the data it contains. With ADTs, we first choose the shape
of the container and then fill that container with data of whatever
type we like. Critically, the choice of shape is independent of the
data to be stored. With GADTs, however, the shape of the container may
actually {\em depend} on (the type of) the data to be contained. For
example, $\mathsf{Const}$ can create data of any shape
$\mathsf{Seq\,a}$, but $\mathsf{Pair}$ can produce data of shape
$\mathsf{Seq\,a}$ only if $\mathsf{a}$ is a pair type. As a result,
modifying the data in a GADT may actually change the shape of --- or
may even destroy! --- the GADT.

To determine the possible shapes of a GADT's container we have to
pattern-match on the type of the data to be contained. For this, it is
essential that a GADT calculus support an equality type
$\mathsf{Equal}$ that is inhabited when its two type arguments are the
same and is uninhabited otherwise. That is, the type $\mathsf{Equal}$
must be the syntactic reflection of semantic equality function
$\mathit{Equal}$. The type $\mathsf{Equal}$ can either be defined via
GADT syntax, as in
\[\begin{array}{l}
\mathsf{data\, Equal\,a\,b\,where}\\
\mathsf{\;\;\;\;\;\;\;\;Refl ::\, Equal\,c\,c}\\
\end{array}\]
\noindent
or, equivalently, represented by its own Church encoding
\[\mathsf{Equal\,a\,b} = \mathsf{\forall f.\, (\forall c.\,
  f\,c\,c) \to f\,a\,b}\]
The GADT $\mathsf{Seq}$ can then be represented as its Church encoding
\[\mathsf{Seq\,a} = \mathsf{\forall f.\, (\forall a.\,a \to f\, a)
  \to (\forall a\,b\,c.\,Equal\,a\,(b\times c) \to f\,b \to f\,c \to
  f\,a) \to f\,a}\]
in a higher-kinded calculus such as $F_\omega$.

Importantly, the function $\mathit{Equal}\,a$ cannot be made into a
functor. Equivalently, $\mathsf{Equal\,a}$ (in either representation)
cannot be made an instance of Haskell's $\mathsf{Functor}$
class. Indeed, if $\mathsf{Equal\,a}$ supported a function
\[\mathsf{map_{Equal\,a} :: (b \to c) \to Equal\,a\,b \to
  Equal\,a\,c}\]
then defining
\[\begin{array}{l}
\mathsf{eqElim :: Equal\, a\, b \to b \to a}\\
\mathsf{eqElim\, Refl\, x = x} 
\end{array}\]
would allow us to construct an element 
\[\begin{array}{l}
\mathsf{emptyFromMapEquala :: (\forall b\, c.\, (b \to c) \to Equal\, a\,
  b \to Equal\, a \,c) \to Void}\\ 
\mathsf{emptyFromMapEquala \,map_{Equal\,a} = eqElim\, (map_{Equal\,a}\,
  absurd\, Refl)\, ()}  
\end{array}\]
of type $\mathsf{Void}$. {\color{blue} Use same type conventions as in
  Intro.} But this should be impossible. It is immediate that no GADT
that is not actually a nested type can support a $\mathsf{map}$
function either. In the case of $\mathsf{Seq}$, this is already
intuitively evident from its Haskell definition as discussed in
Section~\ref{sec:intro}.

\subsection{GADTs as Primitive Data Types}\label{sec:prim-gadts}

{\color{red} HERE!!!}

Primitive representations of GADTs capture in syntax the fact that
GADTs can, like ADTs, be considered as fixpoints of higher-order
functors. Syntactically, the use of higher-order funct{\em ions} is
essential, since the type arguments to the GADT being defined are not
uniform across all of its instances in the types of its data
constructors. Semantically, the use of higher-order funct{\em ors} is
essential, as for ADTs, to the very existence of the fixpoints being
computed~\cite{tfca}.
%We will consider GADTs' semantics in more detail in
%Section~\ref{sec:GADT-semantics}.

Consider, again, the GADT $\mathsf{Seq}$. Because its type argument
varies in the instances of $\mathsf{Seq}$ appearing in the types of
its data constructor $\mathsf{Pair}$, $\mathsf{Seq}$ simply cannot be
characterized by any first-order fixpoint equation.  {\color{blue}
  Compare with ADT situation.}  It can, however, be viewed as a
solution to the higher-order fixpoint equation
\[H\,f\,a = a \,+\,Lan_{\lambda a b. a \times b}\, \lambda
a b. f a \times f b\] where $Lan_K \,G$ is the left Kan extension of
$G$ along $K$.  In general, the left Kan extension $Lan_K \,G : {\cal
  E} \to {\cal D}$ of the functor $G : {\cal C} \to {\cal D}$ along
the functor $K : {\cal C} \to {\cal E}$ is the best functorial
approximation to $G$ that factors through $K$. Here, ``best functorial
approximation'' means that $Lan_K \,G$ is the smallest functor that
both extends the image of $K$ to $\cal D$ and coincides with $G$ on
$\cal C$, in the sense that, for any other such functor $H$, there is
a morphism of functors (i.e., a natural transformation) from $Lan_K
\,G$ to $H$. This is captured formally by the following
definition~\cite{mac71}:
\begin{definition}\label{def:lke}
If $G : {\cal C} \to {\cal D}$ and $K : {\cal C} \to {\cal E}$ are
functors, then the {\em left Kan extension of $G$ along $K$} is a
functor $\mathit{Lan}_K\,G : {\cal E} \to {\cal D}$ together with a
natural transformation $\eta : G \to (\mathit{Lan}_K\,G) \circ K$
such that, for every functor $H : {\cal E} \to {\cal D}$ and natural
transformation $\gamma : G \to H \circ K$, there exists a unique
natural transformation $\delta : \mathit{Lan}_K\,G \to H$ such that $(\mu
K) \circ \eta = \gamma$. This is depicted in the diagram
\[\begin{tikzcd}[row sep = huge]
{\cal C}
\ar[rr, "{G}"{name=Fa, above}, ""{name=F, below}]
\ar[rd, "{K}"']
&& {\cal D} \\
& {\cal E}
\ar[Rightarrow, bend right = 25, from=F, "{\eta}"']
\ar[ur, bend left, "{\mathit{Lan}_{K}\,G}"{name=Lan, description}]
\ar[ur, bend right, "{H}"'{name=L, right}, ""'{name=Lr, right}]
\ar[Rightarrow, bend left = 45, from=Fa, to=Lr, "{\gamma}" near start]
\ar[Rightarrow, dashed, from=Lan, to=L, "{\delta}"']
\end{tikzcd}\]
\end{definition}

To represent GADTs as primitive data types a calculus must support a
primitive fixpoint constructor $\mathsf{\mu}$ that is the syntactic
reflection of the higher-order fixpoint operator on the category of
functors on the category interpretating types, as well as a primitive
type constructor $\mathsf{Lan}$ such that $\mathsf{Lan_k\,g}$ is the
syntactic reflection of the left Kan extension $\Lan_K \,G$ of the
functor $G$ interpreting $\mathsf{g}$ along the functor $K$
interpreting $\mathsf{k}$. Using the $\mu$ and $\Lan$ type
constructors we can represent, e.g., the GADT $\mathsf{Seq}$ as
\[\mathsf{Seq\,a} = \mathsf{\mu \phi.\, a + Lan_{\lambda c d. c \times d}
  \lambda c d. \phi c \times \phi d}\]


{\color{blue} This is the least commitment
  thing primitive representations can require. Fixpoints were elided
  in ADT case. Why? Tie together better.}  The type constructor
$\mathsf{Lan}$ thus computes the smallest data type that is generated
by a GADT's {\color{blue} GADT or constructor?} syntax and also
supports a $\mathsf{map}$ function. That is, $\mathsf{Lan}$ computes
the functorial completion of the data type determined by a GADT's
syntax, filling it out with data elements that are derivable via
repeated applications of $\mathsf{map}$ starting from those elements
specified by its syntax. In the primitive view, GADTs are, in general,
underspecified by their syntax.

Just as for ADTs, we can represent GADTs as either Church encodings or
primitive data types. But whereas the two representations are always
isomorphic for ADTs, they are not, in general, for GADTs. We will see
this in the next section.

{\color{blue} rearrange-transform property for GADTs?}

\section{Non-Equivalence of Church Encodings and Primitive
  Representations of GADTs}\label{sec:non-equiv}

{\color{red} Check all fonts!! Syntax vs. semantics!}  Intuitively it
seems the two representations might be different. One is functorial,
one is not. It is possible they could always have the same data
elements even if not the same morphisms. But as we will see in
Example~\ref{ex:g1}, this turns out not to be the case.

Non-uniform nature of GADTs renders build, therefore short cut, for
GADTs impossible. Can't even formulate! Of course, there could be
another way to prove equivalence.  But, in fact, CEs and primitive
representations are not equivalent for arbitrary GADTs, as the
following example shows.
{\color{blue} Our favorite GADT isn't a hereditarily
  polynomial nested type.}

\begin{example}\label{ex:g1}
Consider the following GADT, defined in a Haskell-like syntax:
\begin{equation}\label{eq:example-GADT}
\begin{array}{l}
\mathsf{data\,G : * \to *\,where}\\
\mathsf{\;\;\;\;\;\;\;\;c : G\,1}
\end{array}
\end{equation}
Syntactically, this GADT comprises a single data element, namely
$\mathsf{c :: G \, 1}$. Despite the simplicity of this GADT, it serves
as an informative case study highlighting the differences between the
Church encoding of a GADT and that GADT's representation as a
primitive data type.

The Church encoding of $\mathsf{G}$ is
\[\mathsf{G\,a} = \mathsf{\forall f.\, (\forall b.\,
  f\,b) \to f\,1} \] In other words, $\mathsf{G\,a =
  \mathsf{Equal}\,1\,a}$, so $\mathsf{G}$'s effect is simply to test
its argument for equality against the unit type $\mathsf{1}$.

Recall from the Section~\ref{sec:CEs} that the semantic interpretation
of $\mathsf{Equal\,1\,a}$ is given by a characteristic function, in
the sense that it is the singleton $1$ when the interpretation of
$\mathsf{a}$ is $1$, and is the empty set otherwise.  Thus, as a data
type represented by Church encoding, $\mathsf{G}$ will be the data
type containing one (and only one) piece of data when instantiated on
$\mathsf{1}$, and uninhabited otherwise.  This perfectly mirrors the
syntax of $\mathsf{G}$, which indeed provides just one constructor
when the type is instantiated on $\mathsf{1}$, and none otherwise.
Thus, given a set $A$ interpreting $\mathsf{a}$, the set
interpretation $G_0(A)$ is $1$ if $A = 1$ and $\emptyset$ otherwise.

We now want a primitive representation of $\mathsf{G}$.  Recall that
$\mathsf{G}$ has a unique constructor $\mathsf{c : G\,1}$, which can
be equivalently expressed as $\mathsf{c: 1 \to G\,1}$.  By using a
a$\Lan$ type, we can express $\mathsf{c}$ as a constructor
$\mathsf{(Lan_1\, 1)\alpha \to G \alpha}$.  Thus, as a primitive data
type, we represent $\mathsf{G}$ as $\mu \phi. \lambda
\alpha. (\Lan^{\emptyset}_1 \,1)\alpha$.  {\color{blue} (WHERE?)
  Notice that the constructors of a GADT have to be functors, because
  the GADT is the fixpoint of a higher order functor. Also, we're not
  using the superscript notation on $\Lan$.}

The semantic interpretation of $\mathsf{\mu \phi. \lambda
  \alpha. (\Lan^{\emptyset}_1\, 1)\alpha}$ is given by the fixpoint of
the functor yielded by the semantic interpretation of
$\mathsf{Lan^{\emptyset}_1\, 1}$, the body of the $\mathsf{\mu}$-type.
Notice, though, that the recursive variable $\mathsf{\phi}$ does not
appear in the body of the $\mathsf{\mu}$-type.  Thus, the semantic
interpretation is actually just the semantic interpretation of the
body itself.  Therefore, the semantic interpretation is
$\mathsf{Lan_1 1}$, where $1$ is the constantly $1$-valued functor
$\ast \to \set$ from the category with a single object $\ast$ to
$\set$.

{\color{red} Syntax? Semantics? Which are we talking here?}
It turns out that $\mathsf{\Lan}_1 1$ is, in fact, none other than the
identity functor on $\set$.  Indeed, for any set $A$,
$(\mathsf{\Lan}_1 1) A$ is the set of all functions $a : 1 \to A$
modulo the smallest equivalence relation $\sim$ such that, for any $f
: 1 \to 1$, we have $a \sim a \circ f$.  But this is isomorphic to
$A$, because the only function $1 \to 1$ is the identity~\cite{blw03}.

The Church encoding representation of $G$ and the primitive
representation of $G$ are thus non-equivalent: while the former only
holds one data element in the instance $G\,1$ and none in other
instances, the latter is inhabited in all instances with the exception
of $G\,\emptyset$.  This makes sense if one remembers that the left
Kan extension, reflected into the syntactic type $\Lan$, is a functor,
and thus it comes with a functorial map.  This means that, for every
element $a \in A$, we can map the associated function $\bar{a} : 1 \to
A$ along $G$ to get a function $\map_{G}\,\bar{a} : G\,1 \to G\,A$,
and thus we have an element in $G\,A$ given by $\map_{G}\,\bar{a}\, c$
where $c \in G\,1$ is the element provided by the constructor.
\end{example}

Forced to choose, a programmer would likely find the idea that a GADT
contains data that are not specified by its syntax more than a little
disturbing. What, they might ask, should a data type contain other
than data that are constructed using its data constuctors? Why should
a GADT contain ``hidden'' elements that are only accessible by
mapping? On the other hand, a semanticist would likely find the
primitive representation of GADTs more reasonable. Indeed, they would
likely find the nonfunctorial nature of the Church encoding unnerving
at best. After all, they would likely argue, the data in a GADT
shouldn't disappear just because you map a function over it! The fact
that this happens when GADTs are represented by their Church encodings
actually highlights how GADTs {\em do not} generalize the essential,
container-ish nature of ADTs at all. A semanticist might therefore
conclude that GADTs are seriously misnamed. They might even go on to
wonder: in what sense are GADTs data types at all?

The disappointment that GADTs don't validate any such equivalence is
further compounded by the fact that the the two representations have
very different parametricity properties.  {\color{blue} For example,
  we get rearrange-transform property for primitive rep since this is
  a consequence of functoriality, but don't get it for Church
  Encodings.} We explore the differences in parametricity results for
the two representations in the next section.

\section{Parametricity in the Presence of GADTs}\label{sec:par}

{\em Relational parametricity} encodes a powerful notion of
type-uniformity, or representation independence, for data types in
functional languages. It formalizes the intuition that a polymorphic
program must act uniformly on all of its possible type instantiations
by requiring that every such program preserves all relations between
pairs of types at which it is instantiated. Parametricity was
originally put forth by Reynolds~\cite{rey83} for System F. It was
later popularized as Wadler's ``theorems for free''~\cite{wad89}, so
called because it can deduce properties of programs in such languages
solely from their types, i.e., with no knowledge whatsoever of the
text of the programs involved.  Most of Wadler's free theorems are
consequences of naturality for polymorphic list-processing
functions. However, parametricity can also derive results that go
beyond just naturality, such as establishing {\color{blue} proving}
the equivalence of the Church encodings and the primitive
representations of ADTs and {\color{blue} hereditarily polynomial}
nested types by validating the aforementioned short cut fusion
transformation for them.

{\color{blue} Say somewhere: A relation is a triple $(A,B,R)$, where
  $R$ is a relation between sets $A$ and $B$.  A function from
  $(A,B,R)$ to $(A',B',R')$ is a pair $(f : A \to A',g : B \to B')$ of
  functions on sets such that $(f a,g\,b) \in R'$ if $(a,b) \in R$. We
  may write $R : \rel(A,B)$ for $(A,B,R)$.  If $R : \rel(A,B)$ we
  write $\pi_1 R$ and $\pi_2 R$ for the {\em domain} $A$ of $R$ and
  the {\em codomain} $B$ of $R$, respectively, and assume $\pi_1$ and
  $\pi_2$ are surjective. We write $\Eq_A = (A,A,\{(x,x)~|~ x \in
  A\})$ for the {\em equality relation} on the set $A$. ALSO, WANT OUR
RELATIONS TO BE ONTO.}

{\color{red} This might not be relevant, since we only care about the
  fibredness.} 
The key idea underlying Reynolds' parametricity is to give each type
$F(\alpha)$ with one free variable $\alpha$ a {\em set interpretation}
$F_0$ taking sets to sets and a \emph{relational interpretation} $F_1$
taking relations $R : \rel(A,B)$ to relations $F_1 (R) : \rel(F_0 (A),
F_0 (B))$, and to interpret each term $t(\alpha,x) : F(\alpha)$ with
one free term variable $x : G(\alpha)$ as a map $t_0$ associating to
each set $A$ a function $t_0(A) : G_0(A) \to F_0(A)$. These
interpretations are given inductively on the structures of $F$ and $t$
in such a way that they imply two fundamental theorems. The first is
an \emph{Identity Extension Lemma}, which states that $F_1(\Eq_A) =
\Eq_{F_0(A)}$, and is the essential property that makes a model
relationally parametric rather than just induced by a logical
relation. The second is an \emph{Abstraction Theorem}, which states
that, for any $R :\rel(A, B)$, $(t_0(A),t_0(B))$ is a morphism in
$\rel$ from $(G_0(A),G_0(B),G_1(R))$ to $(F_0(A),F_0(B),F_1(R))$. The
Identity Extension Lemma is similar to the Abstraction Theorem except
that it holds for {\em all} elements of a type's interpretation, not
just those that interpret terms.  Similar theorems are required for
types and terms with any number of free variables.

\begin{example}
{\color{red} PRIMITIVE REP DOESN'T HAVE FIBRED SEMANTICS, AS REQUIRED
  FOR PAR} To
even consider the question of whether our semantics is parametric we
first need to define a relational semantics for our types, i.e., a
relational interpretation for every type $G : \ast \to \ast$ such
that, for every relation $R : \rel(A, B)$, we have $G_1(R) :
\rel(G_0(A), G_0(B))$.

We shall show that this is not generally possible for the primitive
representation of data types, by considering the previously defined
type $G$ in Equation~\ref{eq:G}.  Recall that the semantic
interpretation of $G$ is given by $\mathsf{\Lan}_1 1$ which, in fact,
is none other than the identity functor on $\set$.

Analogously to the set interpretation, the relational interpretation
for $G$ is given by $\mathsf{\Lan}_{\Eq_1} \Eq_1$.  Notice that the
interpretation still essentially relies on a left Kan extension, but
this time it is an extension of $\rel$-valued functors.  We would need
to prove that, for every relation $R : \rel(A, B)$, we have that
$(\mathsf{\Lan}_{\Eq_1} \Eq_1) R$ is a relation on $(\mathsf{\Lan}_1
1) A$ and $(\mathsf{\Lan}_1 1)B$, i.e., $A$ and $B$.  Instead, we will
provide a counterexample showing that this is not true.

Consider the relation $R = (1, \emptyset, \emptyset)$.  We would thus
expect $(\mathsf{\Lan}_{\Eq_1} \Eq_1) R$ to be a relation with domain
$1$.  Because the left Kan extension preserves
projections~\cite{rie16} we can compute the domain as
$(\mathsf{\Lan}_{\Eq_1} 1) R$ (notice that the left Kan extension of
$1 : \ast \to \set$ along $\Eq_1 : \ast \to \rel$ is a functor $\rel
\to \set$).

Following~\cite{blw03} we know that $(\mathsf{\Lan}_{\Eq_1} 1) R$ is
the set of all morphisms of relations $f : \Eq_1 \to R$ modulo an
equivalence relation; but there can be no morphism of relations $\Eq_1
\to R$ because its second component would have to be a function $1 \to
\emptyset$, and there can be no such function.  Thus,
$(\mathsf{\Lan}_{\Eq_1} 1) R = \emptyset$, which is not the domain we
would have expected.
\end{example}

The above example shows that the set interpretation and the relational
interpretation for the primitive representation of a data type are
inconsistent with each other, and thus it is not even possible to
consider the question of whether the semantics is parametric.

One could regard the above example as artificial, as it employs an
empty relation on a non-empty domain.  Though, it is possible to apply
the same argument, with a slightly more complex calculation, even to a
total relation such as $(1, 2, 1 \times 2)$.

We still get naturality properties, though.

\vspace*{0.2in}

As we have seen in the previous Section~\ref{sec:adts}, GADTs
represented as Church encodings do not necessarily have a map or a
functorial semantics.  In particular, this means that we cannot
possibly derive naturality results for those types, event though their
semantics is parametric.  Indeed, even though naturality is sometimes
seen as a consequence of parametricity, that is only true in case we
have a functorial semantics and types supporting a map.  Still, GADTs
represented as Church encodings can still exhibit consequences of
paramentricity other than naturality, as they do admit parametric
semantics~\cite{atk12}.

\begin{example}
{\color{blue} In this paragraph, $\mathsf{G}$ and $\mathsf{t}$
  represent syntax, so should be sans-serif, but in the notes, the
  paragraph about set/relational interpretation and
  parametricity/IEL/AT uses serif font.} For example, consider the
Church encoding of the GADT $\mathsf{G}$ defined in
Equation~\ref{eq:G}.  If $\mathsf{t}$ is a term of type
$\mathsf{G}$ and $R$ is a relation on the sets $A$ and $B$, then
$t_0(A) \in G_0(A)$ and $t_0(B) \in G_0(B)$, and by the abstraction
theorem we have that $t_0(A)$ and $t_0(B)$ are related in $G_1(R)$.
{\color{blue} Here, $G = (G_0,G_1)$ is the interpretation of
  $\mathsf{G}$.}  We also know that $G_1(R)$ is the empty relation
whenever $R$ is not $\mathit{Equal}\,1$.  We thus deduce that there
can be no term of type $\mathsf{G\,a}$ unless $\mathsf{a}$ is
semantically equivalent to $\mathsf{1}$.  This result is the syntactic
counterpart of the inhabitation result for $\mathsf{G}$ {\color{blue}
  are inhabitation results about semantics or syntax?}  showing that
all of the instances of $\mathsf{G}$ are uninhabited, with the
exception of the instance for $\mathsf{1}$.  Of course, we could not
possibly have a term of an uninhabited type.
\end{example}

%%% Primitive representation of GADT is non parametric, but functorial
On the contrary, as we have shown in Section~\ref{sec:gadts}, a
GADT represented as a primitive data type does not necessarily admit a
parametric semantics, but, as a fixpoint of a higher-order functor, it
does admit a functorial semantics and, consequently, a functorial map.
In particular, every type that has a functorial map also benefits from
naturality properties.  In other words, there is a suitable
rearrange-transform property as explained in Section~\ref{sec:gadts}.

%%% Example with G
For example, $\mathsf{G}$ is associated to a functorial map,
$\map_{\mathsf{G}}$, such that, for every function $\mathsf{f : a \to
  b}$, we get a function $\map_{\mathsf{G}}\,\mathsf{f} : \mathsf{G\,a
  \to G\,b}$.  Then we have a term $\map_{\mathsf{G}}\,\mathsf{f\,c} :
\mathsf{G\,a}$ for every function $\mathsf{f : \mathsf{1} \to a}$,
where $\mathsf{c : G\,\mathsf{1}}$ is the constructor provided by the
definition of $\mathsf{G}$.


We can read our counterexample as showing that parametricity results
for calculi representing GADTs as their Church encodings cannot be
extended to calculi that represent GADTs as primitive data types. And
functoriality results for calucli representing GADTs as primitive
cannot be extended to calculi that represent GADTs as their Church
encodings.  So the user is forced to make a choice between naturality
consequences of parametricity and other consequences of
parametricity. If GADTs really did generalize ADTs, and really were
data types in a normal sense, then these would coincide and the user
would not have to choose.


\begin{comment}
{\color{violet} This is already in the paper, split in multiple places.}
An analysis of the Eq A B type in Bob's systems shows that the set
interpretation is empty whenever the A and B have different set
interpretations.  Likewise, its relational interpretation is the empty
relation whenever the A and B have different relational
interpretations (even when the underlying set interpretations are the
same).  The consequences of parametricity are thus immediate: there
can be no term of type Eq A B if A and B are different types.
Moreover, this behavior is fundamentally non-functorial, so that there
is no hope of defining a map for Eq.  In particular, that means we
cannot expect to retrieve non-trivial naturality properties for the Eq
type, despite these are usually considered to be a special case of
parametricity properties.  Indeed, the common understanding that
parametricity generalizes naturality only makes sense for functorial
types.  We can specialize these considerations to the type Eq 1 B,
representing G, our example GADT defined by a unique constructor c ::
G 1.
\end{comment}

\vspace*{1in}

NOTES:

{\color{violet} TRUE????}
FOR ADTs and Nesteds, it does not depend. We get the same par property
whether they are seen as primitives or we use their CE.


\subsection{Comparison with Stephanie and Dmitrios}


\subsection{Comparison with Bob's Parametric Model}

GADTs don't really fit into his scheme because the two reps of GADTs
aren't the same. Bob's stuff only works for functorial data types of
any kind -- so not GADTs. So last section is misleading.





Moreover, the consequences of parametricity that one has in Bob's
system do not hold in our system, as we can construct terms of type
$(Lan_1 1)$ B for instances of B other than 1.  Thus, either our
system does not admit any parametric model, or, if it does, the
consequences of parametricity are different.  That the consequences of
parametricity depended on the model or the representation of GADTs is
to be expected, however. (IT IS. CONSIDER INTERPRETING BASE TYPES AS
ORDERED SETS. THIS GIVES DIFFERENT PARAMETRICITY PROPERTIES THAN
INTERPRETING THEM AS DIAGONAL RELATIONS.)

It is possible to give a parametric model that models GADTs
represented as Church encodings~\cite{atk12}.  But given the
non-uniformity captured by GADTs by purposeful design, that should be
both completely unexpected and alarming! However, upon reflection it's
not really all that surprising once we realize what the parametricity
properties of GADTs represented as Church encodings look like. Bob
requires map functions for fixpoint but then doesn't use them.

Tellingly, Bob gives no parametricity properties for GADTs. If he had,
it would have illustrated the phenomenon we are describing, raised the
question: What good is a par property for a GADT or another type using
the Eq type?

That parametricity properties for GADTs in Bob's system are as we
described before is interesting because, for ADTs and nested types,
which GADTs claim to generalize, we expect naturality to be a special
case of parametricity. However, we don't actually get non-trivial
naturality consequences of parametricity for GADTs in Bob's
system. Why? Because this would require GADTs to be interpreted as
functors, which, in Bob's system, requires the programmer to supply a
map function on the intepretation of every GADT defined. Moreover,
each such map function would have to behave functorially. Bob's system
does indeed deliver non-trivial naturality results for every GADT for
which the user can define a map function that behaves
functorially. The problem is that there may not be many such GADTs (in
fact it will not be possible for proper GADTs, i.e., GADTs that are
not actually nested types).

Perhaps expecting naturality as a special case of parametricity is
wrongheaded, though, since, with its arbitrary forall-types and arrow
types, System F is inherently non-functorial. Using Church encodings,
Bob's system handles arbitrary GADT syntax. However, GADTs are not
guaranteed to behave functorially in his system, and the user is
ultimately tasked with supplying the relevant map functions (and
proving their properties) for any GADTs they want to work with. That
the user must supply the map function for a GADT of interest makes
sense: Church encodings cannot say anything about functorial nature of
data types since they describe only the data (and not the action on
morphisms since they are not required to support map functions).  Our
approach is different. By contrast with Bob's system, we restrict to
GADTs generated by a specific grammar, and this grammar is designed
specifically to guarantee functoriality of all data types definable in
it. We also treat GADTs as primitive data types --- i.e., as fixpoints
of (higher-order) functors --- rather than via their Church encodings
since this more closely aligns with how ADTs are treated in
implemented programming languages.

Wrt Bob's system we can ask: what good is parametricity for GADTs in a
system that derives only trivial naturality consequences of
parametricity for them? It may be possible to get non-naturality
consequences of parametricity (such as short cut fusion or
VYTINIOTIS'?) for GADTs in Bob's system (IS IT?), but since many of
the most useful consequences of parametricity for ADTs and nested
types are actually natuality results (IS THIS TRUE? MAYBE NOT FOR
GADTs), we'd be missing out on a very large class of expected and
useful free theorems. Indeed, many of Wadler's free theorems are
precisely naturality results for functions over data types (mainly
lists, there). If GADTs really do generalize ADTs (and nested types)
then we would expect to be able to derive analogues for GADTs of the
parametricity results --- including naturality results --- that we can
derive for ADTs. Yet, by design we cannot. So are GADTs actually
misnamed? In what sense are they data types, and in what sense do they
generalize ADTs? Perhaps what are now known as nested types should
really be called GADTs since *they* are actually the (level-2)
higher-kinded generalizations of ADTs.

{\color{violet} We say "naturality consequences of parametricity"
when in fact we have naturality without having any parametricity at all.
Change the wording to indicate that naturality follows from
functoriality of the interp.}
In our system we can show that we can recover the expected naturality
consequences of parametricity for (at least a large class of) GADTs
(that can be characterized by a grammar for which every type is
interpreted as a functor, including those characterized as least
fixpoints, i.e., as carriers of initial algebras of functors, i.e., as
primitive data types). The way our system achieves this is by
interpreting GADTs as their functorial completions. So in our system
the interpretations of GADTs are guaranteed to have fmap functions ---
i.e., to be functorial --- and to satisfy the expected naturality
properties. And our free theorems really are free for GADTs that fit
our syntax. But now the bump is elsewhere under the rug: First,
semantically we don't really have the same GADT anymore (functoriality
adds extra data to the data type), and second, our counterexample
shows that we don't get non-naturality consequences of parmetricity
even for the data types defined by our grammar.  So this isn't really
what we wanted either.



\pagebreak

\begin{verbatim}
  
Daniel:

I have tried reconstructing my example using our simpler GADT with a single
constructor c :: G 1. I don't think it is possible to modify my example for a
GADT with only a single constructor. In particular, I don't see a way to
exploit the map function unless we have constructors for G X and G Y where X
!= Y.
If we assume a map function exists, then given f :: 1 -> A we can produce
(map f c) :: G A. But I don't know what to do from there.

I was able to simplify the types in the example slightly though. The example
I gave before can be adapted to use either

data G3 b where
    G3unit :: G3 ()
    G3id    :: b -> G3 (Either b ())

or

data G5 b where
    G5unit   :: G5 ()
    G5void   :: Void -> G5 Bool

as the problematic GADT.

Enrico:

Just to make sure I understand it correctly: when we define the function

unGbool :: G c Bool -> c
unGbool (Gbool x) = x

we are doing so in Haskell, right?
In our system, it would not be possible to define unGbool (because we could
not define it only on the constructor Gbool of G). For this reason, this
example provides a contradiction in Haskell (+functoriality), but not in our
system. Is that correct?

Daniel:

The example is Haskell and relies on Haskell's rules for
pattern matching.








Enrico:

By the way, as a general remark not directly related to the introduction you
wrote, I think that the set semantics of our type G is

[[G \alpha]]^set [\alpha := A] = A

Indeed, (Lan_1 1) A = A for every set A. Intuitively this makes sense,
because for every a : A there is a fuction

k_a : 1 —> A

and thus an element

map k_a \ast : G A

In particular, [[G 0]]^set = \emptyset.

Still, it is NOT true that its relational interpretation is [[G \alpha]]^rel
[\alpha := R] = R (and indeed the relational interpretation is not fibered
over the set interpretation)!
\end{verbatim}

\section{Conclusion}

The upshot is that we can consider GADTs as data types (i.e., we can
compute the semantics of GADTs) in two ways: just as determined by
their syntax, as when they are represented by their Church encodings,
or as the functorial completion of their syntax, as obtained by
supplying a suitable map construct, when they are represented as
primitive data types. But, either way, GADTs fail to be well-behaved
wrt parametricity. In the first case, GADTs don't have fmaps so their
parametricity properties can't include naturality properties. In the
second case, we still can't get non-naturality consequences of
parametricity. That is, we can't get BOTH the naturality consequences
of parametricity AND the non-naturality consequences of parametricity
at the same time.



\bibliography{gadt-story-references}

\end{document}
